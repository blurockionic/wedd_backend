
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model Checklist
 * 
 */
export type Checklist = $Result.DefaultSelection<Prisma.$ChecklistPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventVendors
 * 
 */
export type EventVendors = $Result.DefaultSelection<Prisma.$EventVendorsPayload>
/**
 * Model EventTask
 * 
 */
export type EventTask = $Result.DefaultSelection<Prisma.$EventTaskPayload>
/**
 * Model SubEvent
 * 
 */
export type SubEvent = $Result.DefaultSelection<Prisma.$SubEventPayload>
/**
 * Model SubEventVendors
 * 
 */
export type SubEventVendors = $Result.DefaultSelection<Prisma.$SubEventVendorsPayload>
/**
 * Model SubEventTask
 * 
 */
export type SubEventTask = $Result.DefaultSelection<Prisma.$SubEventTaskPayload>
/**
 * Model OrderDetails
 * 
 */
export type OrderDetails = $Result.DefaultSelection<Prisma.$OrderDetailsPayload>
/**
 * Model PaymentDetails
 * 
 */
export type PaymentDetails = $Result.DefaultSelection<Prisma.$PaymentDetailsPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model EventSchedule
 * 
 */
export type EventSchedule = $Result.DefaultSelection<Prisma.$EventSchedulePayload>
/**
 * Model Guest
 * 
 */
export type Guest = $Result.DefaultSelection<Prisma.$GuestPayload>
/**
 * Model InvitationTemplate
 * 
 */
export type InvitationTemplate = $Result.DefaultSelection<Prisma.$InvitationTemplatePayload>
/**
 * Model UserDataTemplate
 * 
 */
export type UserDataTemplate = $Result.DefaultSelection<Prisma.$UserDataTemplatePayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model LikedBlog
 * 
 */
export type LikedBlog = $Result.DefaultSelection<Prisma.$LikedBlogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const TaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const GuestStatus: {
  NOT_INVITED: 'NOT_INVITED',
  INVITED: 'INVITED'
};

export type GuestStatus = (typeof GuestStatus)[keyof typeof GuestStatus]


export const template_category: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM'
};

export type template_category = (typeof template_category)[keyof typeof template_category]

}

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type GuestStatus = $Enums.GuestStatus

export const GuestStatus: typeof $Enums.GuestStatus

export type template_category = $Enums.template_category

export const template_category: typeof $Enums.template_category

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklist`: Exposes CRUD operations for the **Checklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checklists
    * const checklists = await prisma.checklist.findMany()
    * ```
    */
  get checklist(): Prisma.ChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventVendors`: Exposes CRUD operations for the **EventVendors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventVendors
    * const eventVendors = await prisma.eventVendors.findMany()
    * ```
    */
  get eventVendors(): Prisma.EventVendorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventTask`: Exposes CRUD operations for the **EventTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTasks
    * const eventTasks = await prisma.eventTask.findMany()
    * ```
    */
  get eventTask(): Prisma.EventTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subEvent`: Exposes CRUD operations for the **SubEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubEvents
    * const subEvents = await prisma.subEvent.findMany()
    * ```
    */
  get subEvent(): Prisma.SubEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subEventVendors`: Exposes CRUD operations for the **SubEventVendors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubEventVendors
    * const subEventVendors = await prisma.subEventVendors.findMany()
    * ```
    */
  get subEventVendors(): Prisma.SubEventVendorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subEventTask`: Exposes CRUD operations for the **SubEventTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubEventTasks
    * const subEventTasks = await prisma.subEventTask.findMany()
    * ```
    */
  get subEventTask(): Prisma.SubEventTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderDetails`: Exposes CRUD operations for the **OrderDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDetails
    * const orderDetails = await prisma.orderDetails.findMany()
    * ```
    */
  get orderDetails(): Prisma.OrderDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentDetails`: Exposes CRUD operations for the **PaymentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentDetails
    * const paymentDetails = await prisma.paymentDetails.findMany()
    * ```
    */
  get paymentDetails(): Prisma.PaymentDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventSchedule`: Exposes CRUD operations for the **EventSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventSchedules
    * const eventSchedules = await prisma.eventSchedule.findMany()
    * ```
    */
  get eventSchedule(): Prisma.EventScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **Guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): Prisma.GuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitationTemplate`: Exposes CRUD operations for the **InvitationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationTemplates
    * const invitationTemplates = await prisma.invitationTemplate.findMany()
    * ```
    */
  get invitationTemplate(): Prisma.InvitationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDataTemplate`: Exposes CRUD operations for the **UserDataTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDataTemplates
    * const userDataTemplates = await prisma.userDataTemplate.findMany()
    * ```
    */
  get userDataTemplate(): Prisma.UserDataTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likedBlog`: Exposes CRUD operations for the **LikedBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikedBlogs
    * const likedBlogs = await prisma.likedBlog.findMany()
    * ```
    */
  get likedBlog(): Prisma.LikedBlogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Booking: 'Booking',
    Cart: 'Cart',
    Checklist: 'Checklist',
    Event: 'Event',
    EventVendors: 'EventVendors',
    EventTask: 'EventTask',
    SubEvent: 'SubEvent',
    SubEventVendors: 'SubEventVendors',
    SubEventTask: 'SubEventTask',
    OrderDetails: 'OrderDetails',
    PaymentDetails: 'PaymentDetails',
    Review: 'Review',
    EventSchedule: 'EventSchedule',
    Guest: 'Guest',
    InvitationTemplate: 'InvitationTemplate',
    UserDataTemplate: 'UserDataTemplate',
    Blog: 'Blog',
    Comment: 'Comment',
    LikedBlog: 'LikedBlog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db_postgres?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "booking" | "cart" | "checklist" | "event" | "eventVendors" | "eventTask" | "subEvent" | "subEventVendors" | "subEventTask" | "orderDetails" | "paymentDetails" | "review" | "eventSchedule" | "guest" | "invitationTemplate" | "userDataTemplate" | "blog" | "comment" | "likedBlog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      Checklist: {
        payload: Prisma.$ChecklistPayload<ExtArgs>
        fields: Prisma.ChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          findFirst: {
            args: Prisma.ChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          findMany: {
            args: Prisma.ChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>[]
          }
          create: {
            args: Prisma.ChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          createMany: {
            args: Prisma.ChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>[]
          }
          delete: {
            args: Prisma.ChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          update: {
            args: Prisma.ChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          deleteMany: {
            args: Prisma.ChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>[]
          }
          upsert: {
            args: Prisma.ChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistPayload>
          }
          aggregate: {
            args: Prisma.ChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklist>
          }
          groupBy: {
            args: Prisma.ChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<ChecklistCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventVendors: {
        payload: Prisma.$EventVendorsPayload<ExtArgs>
        fields: Prisma.EventVendorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventVendorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventVendorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          findFirst: {
            args: Prisma.EventVendorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventVendorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          findMany: {
            args: Prisma.EventVendorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>[]
          }
          create: {
            args: Prisma.EventVendorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          createMany: {
            args: Prisma.EventVendorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventVendorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>[]
          }
          delete: {
            args: Prisma.EventVendorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          update: {
            args: Prisma.EventVendorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          deleteMany: {
            args: Prisma.EventVendorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventVendorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventVendorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>[]
          }
          upsert: {
            args: Prisma.EventVendorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventVendorsPayload>
          }
          aggregate: {
            args: Prisma.EventVendorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventVendors>
          }
          groupBy: {
            args: Prisma.EventVendorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventVendorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventVendorsCountArgs<ExtArgs>
            result: $Utils.Optional<EventVendorsCountAggregateOutputType> | number
          }
        }
      }
      EventTask: {
        payload: Prisma.$EventTaskPayload<ExtArgs>
        fields: Prisma.EventTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          findFirst: {
            args: Prisma.EventTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          findMany: {
            args: Prisma.EventTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>[]
          }
          create: {
            args: Prisma.EventTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          createMany: {
            args: Prisma.EventTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>[]
          }
          delete: {
            args: Prisma.EventTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          update: {
            args: Prisma.EventTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          deleteMany: {
            args: Prisma.EventTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>[]
          }
          upsert: {
            args: Prisma.EventTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTaskPayload>
          }
          aggregate: {
            args: Prisma.EventTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventTask>
          }
          groupBy: {
            args: Prisma.EventTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTaskCountArgs<ExtArgs>
            result: $Utils.Optional<EventTaskCountAggregateOutputType> | number
          }
        }
      }
      SubEvent: {
        payload: Prisma.$SubEventPayload<ExtArgs>
        fields: Prisma.SubEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          findFirst: {
            args: Prisma.SubEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          findMany: {
            args: Prisma.SubEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>[]
          }
          create: {
            args: Prisma.SubEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          createMany: {
            args: Prisma.SubEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>[]
          }
          delete: {
            args: Prisma.SubEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          update: {
            args: Prisma.SubEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          deleteMany: {
            args: Prisma.SubEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>[]
          }
          upsert: {
            args: Prisma.SubEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventPayload>
          }
          aggregate: {
            args: Prisma.SubEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubEvent>
          }
          groupBy: {
            args: Prisma.SubEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubEventCountArgs<ExtArgs>
            result: $Utils.Optional<SubEventCountAggregateOutputType> | number
          }
        }
      }
      SubEventVendors: {
        payload: Prisma.$SubEventVendorsPayload<ExtArgs>
        fields: Prisma.SubEventVendorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubEventVendorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubEventVendorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          findFirst: {
            args: Prisma.SubEventVendorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubEventVendorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          findMany: {
            args: Prisma.SubEventVendorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>[]
          }
          create: {
            args: Prisma.SubEventVendorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          createMany: {
            args: Prisma.SubEventVendorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubEventVendorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>[]
          }
          delete: {
            args: Prisma.SubEventVendorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          update: {
            args: Prisma.SubEventVendorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          deleteMany: {
            args: Prisma.SubEventVendorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubEventVendorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubEventVendorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>[]
          }
          upsert: {
            args: Prisma.SubEventVendorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventVendorsPayload>
          }
          aggregate: {
            args: Prisma.SubEventVendorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubEventVendors>
          }
          groupBy: {
            args: Prisma.SubEventVendorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubEventVendorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubEventVendorsCountArgs<ExtArgs>
            result: $Utils.Optional<SubEventVendorsCountAggregateOutputType> | number
          }
        }
      }
      SubEventTask: {
        payload: Prisma.$SubEventTaskPayload<ExtArgs>
        fields: Prisma.SubEventTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubEventTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubEventTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          findFirst: {
            args: Prisma.SubEventTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubEventTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          findMany: {
            args: Prisma.SubEventTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>[]
          }
          create: {
            args: Prisma.SubEventTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          createMany: {
            args: Prisma.SubEventTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubEventTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>[]
          }
          delete: {
            args: Prisma.SubEventTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          update: {
            args: Prisma.SubEventTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          deleteMany: {
            args: Prisma.SubEventTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubEventTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubEventTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>[]
          }
          upsert: {
            args: Prisma.SubEventTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubEventTaskPayload>
          }
          aggregate: {
            args: Prisma.SubEventTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubEventTask>
          }
          groupBy: {
            args: Prisma.SubEventTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubEventTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubEventTaskCountArgs<ExtArgs>
            result: $Utils.Optional<SubEventTaskCountAggregateOutputType> | number
          }
        }
      }
      OrderDetails: {
        payload: Prisma.$OrderDetailsPayload<ExtArgs>
        fields: Prisma.OrderDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          findFirst: {
            args: Prisma.OrderDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          findMany: {
            args: Prisma.OrderDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>[]
          }
          create: {
            args: Prisma.OrderDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          createMany: {
            args: Prisma.OrderDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>[]
          }
          delete: {
            args: Prisma.OrderDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          update: {
            args: Prisma.OrderDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OrderDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>[]
          }
          upsert: {
            args: Prisma.OrderDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          aggregate: {
            args: Prisma.OrderDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderDetails>
          }
          groupBy: {
            args: Prisma.OrderDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailsCountAggregateOutputType> | number
          }
        }
      }
      PaymentDetails: {
        payload: Prisma.$PaymentDetailsPayload<ExtArgs>
        fields: Prisma.PaymentDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          findFirst: {
            args: Prisma.PaymentDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          findMany: {
            args: Prisma.PaymentDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>[]
          }
          create: {
            args: Prisma.PaymentDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          createMany: {
            args: Prisma.PaymentDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>[]
          }
          delete: {
            args: Prisma.PaymentDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          update: {
            args: Prisma.PaymentDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          aggregate: {
            args: Prisma.PaymentDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentDetails>
          }
          groupBy: {
            args: Prisma.PaymentDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailsCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      EventSchedule: {
        payload: Prisma.$EventSchedulePayload<ExtArgs>
        fields: Prisma.EventScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          findFirst: {
            args: Prisma.EventScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          findMany: {
            args: Prisma.EventScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>[]
          }
          create: {
            args: Prisma.EventScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          createMany: {
            args: Prisma.EventScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>[]
          }
          delete: {
            args: Prisma.EventScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          update: {
            args: Prisma.EventScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          deleteMany: {
            args: Prisma.EventScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>[]
          }
          upsert: {
            args: Prisma.EventScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSchedulePayload>
          }
          aggregate: {
            args: Prisma.EventScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventSchedule>
          }
          groupBy: {
            args: Prisma.EventScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<EventScheduleCountAggregateOutputType> | number
          }
        }
      }
      Guest: {
        payload: Prisma.$GuestPayload<ExtArgs>
        fields: Prisma.GuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findFirst: {
            args: Prisma.GuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findMany: {
            args: Prisma.GuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          create: {
            args: Prisma.GuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          createMany: {
            args: Prisma.GuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          delete: {
            args: Prisma.GuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          update: {
            args: Prisma.GuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          deleteMany: {
            args: Prisma.GuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          upsert: {
            args: Prisma.GuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          aggregate: {
            args: Prisma.GuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuest>
          }
          groupBy: {
            args: Prisma.GuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuestCountArgs<ExtArgs>
            result: $Utils.Optional<GuestCountAggregateOutputType> | number
          }
        }
      }
      InvitationTemplate: {
        payload: Prisma.$InvitationTemplatePayload<ExtArgs>
        fields: Prisma.InvitationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findFirst: {
            args: Prisma.InvitationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findMany: {
            args: Prisma.InvitationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          create: {
            args: Prisma.InvitationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          createMany: {
            args: Prisma.InvitationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          delete: {
            args: Prisma.InvitationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          update: {
            args: Prisma.InvitationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.InvitationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.InvitationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          aggregate: {
            args: Prisma.InvitationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationTemplate>
          }
          groupBy: {
            args: Prisma.InvitationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateCountAggregateOutputType> | number
          }
        }
      }
      UserDataTemplate: {
        payload: Prisma.$UserDataTemplatePayload<ExtArgs>
        fields: Prisma.UserDataTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDataTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDataTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          findFirst: {
            args: Prisma.UserDataTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDataTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          findMany: {
            args: Prisma.UserDataTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>[]
          }
          create: {
            args: Prisma.UserDataTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          createMany: {
            args: Prisma.UserDataTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDataTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>[]
          }
          delete: {
            args: Prisma.UserDataTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          update: {
            args: Prisma.UserDataTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          deleteMany: {
            args: Prisma.UserDataTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDataTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDataTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>[]
          }
          upsert: {
            args: Prisma.UserDataTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDataTemplatePayload>
          }
          aggregate: {
            args: Prisma.UserDataTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDataTemplate>
          }
          groupBy: {
            args: Prisma.UserDataTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDataTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDataTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<UserDataTemplateCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      LikedBlog: {
        payload: Prisma.$LikedBlogPayload<ExtArgs>
        fields: Prisma.LikedBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikedBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikedBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          findFirst: {
            args: Prisma.LikedBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikedBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          findMany: {
            args: Prisma.LikedBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>[]
          }
          create: {
            args: Prisma.LikedBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          createMany: {
            args: Prisma.LikedBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikedBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>[]
          }
          delete: {
            args: Prisma.LikedBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          update: {
            args: Prisma.LikedBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          deleteMany: {
            args: Prisma.LikedBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikedBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikedBlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>[]
          }
          upsert: {
            args: Prisma.LikedBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedBlogPayload>
          }
          aggregate: {
            args: Prisma.LikedBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikedBlog>
          }
          groupBy: {
            args: Prisma.LikedBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikedBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikedBlogCountArgs<ExtArgs>
            result: $Utils.Optional<LikedBlogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    booking?: BookingOmit
    cart?: CartOmit
    checklist?: ChecklistOmit
    event?: EventOmit
    eventVendors?: EventVendorsOmit
    eventTask?: EventTaskOmit
    subEvent?: SubEventOmit
    subEventVendors?: SubEventVendorsOmit
    subEventTask?: SubEventTaskOmit
    orderDetails?: OrderDetailsOmit
    paymentDetails?: PaymentDetailsOmit
    review?: ReviewOmit
    eventSchedule?: EventScheduleOmit
    guest?: GuestOmit
    invitationTemplate?: InvitationTemplateOmit
    userDataTemplate?: UserDataTemplateOmit
    blog?: BlogOmit
    comment?: CommentOmit
    likedBlog?: LikedBlogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    reviews: number
    cart: number
    checklists: number
    guests: number
    paymentDetails: number
    orderDetails: number
    userDataTemplate: number
    event: number
    likedBlogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    cart?: boolean | UserCountOutputTypeCountCartArgs
    checklists?: boolean | UserCountOutputTypeCountChecklistsArgs
    guests?: boolean | UserCountOutputTypeCountGuestsArgs
    paymentDetails?: boolean | UserCountOutputTypeCountPaymentDetailsArgs
    orderDetails?: boolean | UserCountOutputTypeCountOrderDetailsArgs
    userDataTemplate?: boolean | UserCountOutputTypeCountUserDataTemplateArgs
    event?: boolean | UserCountOutputTypeCountEventArgs
    likedBlogs?: boolean | UserCountOutputTypeCountLikedBlogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDataTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDataTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedBlogWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    eventTask: number
    eventVendors: number
    subEvent: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventTask?: boolean | EventCountOutputTypeCountEventTaskArgs
    eventVendors?: boolean | EventCountOutputTypeCountEventVendorsArgs
    subEvent?: boolean | EventCountOutputTypeCountSubEventArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTaskWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventVendorsWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSubEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventWhereInput
  }


  /**
   * Count Type SubEventCountOutputType
   */

  export type SubEventCountOutputType = {
    subEventTask: number
    subEventVendors: number
  }

  export type SubEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEventTask?: boolean | SubEventCountOutputTypeCountSubEventTaskArgs
    subEventVendors?: boolean | SubEventCountOutputTypeCountSubEventVendorsArgs
  }

  // Custom InputTypes
  /**
   * SubEventCountOutputType without action
   */
  export type SubEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventCountOutputType
     */
    select?: SubEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubEventCountOutputType without action
   */
  export type SubEventCountOutputTypeCountSubEventTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventTaskWhereInput
  }

  /**
   * SubEventCountOutputType without action
   */
  export type SubEventCountOutputTypeCountSubEventVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventVendorsWhereInput
  }


  /**
   * Count Type InvitationTemplateCountOutputType
   */

  export type InvitationTemplateCountOutputType = {
    paymentDetails: number
    orderDetails: number
  }

  export type InvitationTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentDetails?: boolean | InvitationTemplateCountOutputTypeCountPaymentDetailsArgs
    orderDetails?: boolean | InvitationTemplateCountOutputTypeCountOrderDetailsArgs
  }

  // Custom InputTypes
  /**
   * InvitationTemplateCountOutputType without action
   */
  export type InvitationTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplateCountOutputType
     */
    select?: InvitationTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvitationTemplateCountOutputType without action
   */
  export type InvitationTemplateCountOutputTypeCountPaymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailsWhereInput
  }

  /**
   * InvitationTemplateCountOutputType without action
   */
  export type InvitationTemplateCountOutputTypeCountOrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
  }


  /**
   * Count Type BlogCountOutputType
   */

  export type BlogCountOutputType = {
    comments: number
    likedBy: number
  }

  export type BlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | BlogCountOutputTypeCountCommentsArgs
    likedBy?: boolean | BlogCountOutputTypeCountLikedByArgs
  }

  // Custom InputTypes
  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     */
    select?: BlogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedBlogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    refresh_Token: string | null
    password_hash: string | null
    googleUid: string | null
    resetPassword_Token: string | null
    profile_photo: string | null
    user_name: string | null
    phone_number: string | null
    role: $Enums.Role | null
    wedding_date: Date | null
    wedding_location: string | null
    created_at: Date | null
    is_verified: boolean | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    refresh_Token: string | null
    password_hash: string | null
    googleUid: string | null
    resetPassword_Token: string | null
    profile_photo: string | null
    user_name: string | null
    phone_number: string | null
    role: $Enums.Role | null
    wedding_date: Date | null
    wedding_location: string | null
    created_at: Date | null
    is_verified: boolean | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    refresh_Token: number
    password_hash: number
    googleUid: number
    resetPassword_Token: number
    profile_photo: number
    user_name: number
    phone_number: number
    role: number
    wedding_date: number
    wedding_location: number
    created_at: number
    is_verified: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    refresh_Token?: true
    password_hash?: true
    googleUid?: true
    resetPassword_Token?: true
    profile_photo?: true
    user_name?: true
    phone_number?: true
    role?: true
    wedding_date?: true
    wedding_location?: true
    created_at?: true
    is_verified?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    refresh_Token?: true
    password_hash?: true
    googleUid?: true
    resetPassword_Token?: true
    profile_photo?: true
    user_name?: true
    phone_number?: true
    role?: true
    wedding_date?: true
    wedding_location?: true
    created_at?: true
    is_verified?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    refresh_Token?: true
    password_hash?: true
    googleUid?: true
    resetPassword_Token?: true
    profile_photo?: true
    user_name?: true
    phone_number?: true
    role?: true
    wedding_date?: true
    wedding_location?: true
    created_at?: true
    is_verified?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    refresh_Token: string | null
    password_hash: string | null
    googleUid: string | null
    resetPassword_Token: string | null
    profile_photo: string | null
    user_name: string
    phone_number: string | null
    role: $Enums.Role
    wedding_date: Date | null
    wedding_location: string | null
    created_at: Date
    is_verified: boolean
    updated_at: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    refresh_Token?: boolean
    password_hash?: boolean
    googleUid?: boolean
    resetPassword_Token?: boolean
    profile_photo?: boolean
    user_name?: boolean
    phone_number?: boolean
    role?: boolean
    wedding_date?: boolean
    wedding_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    updated_at?: boolean
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    checklists?: boolean | User$checklistsArgs<ExtArgs>
    guests?: boolean | User$guestsArgs<ExtArgs>
    paymentDetails?: boolean | User$paymentDetailsArgs<ExtArgs>
    orderDetails?: boolean | User$orderDetailsArgs<ExtArgs>
    userDataTemplate?: boolean | User$userDataTemplateArgs<ExtArgs>
    event?: boolean | User$eventArgs<ExtArgs>
    likedBlogs?: boolean | User$likedBlogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    refresh_Token?: boolean
    password_hash?: boolean
    googleUid?: boolean
    resetPassword_Token?: boolean
    profile_photo?: boolean
    user_name?: boolean
    phone_number?: boolean
    role?: boolean
    wedding_date?: boolean
    wedding_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    refresh_Token?: boolean
    password_hash?: boolean
    googleUid?: boolean
    resetPassword_Token?: boolean
    profile_photo?: boolean
    user_name?: boolean
    phone_number?: boolean
    role?: boolean
    wedding_date?: boolean
    wedding_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    refresh_Token?: boolean
    password_hash?: boolean
    googleUid?: boolean
    resetPassword_Token?: boolean
    profile_photo?: boolean
    user_name?: boolean
    phone_number?: boolean
    role?: boolean
    wedding_date?: boolean
    wedding_location?: boolean
    created_at?: boolean
    is_verified?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "refresh_Token" | "password_hash" | "googleUid" | "resetPassword_Token" | "profile_photo" | "user_name" | "phone_number" | "role" | "wedding_date" | "wedding_location" | "created_at" | "is_verified" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    checklists?: boolean | User$checklistsArgs<ExtArgs>
    guests?: boolean | User$guestsArgs<ExtArgs>
    paymentDetails?: boolean | User$paymentDetailsArgs<ExtArgs>
    orderDetails?: boolean | User$orderDetailsArgs<ExtArgs>
    userDataTemplate?: boolean | User$userDataTemplateArgs<ExtArgs>
    event?: boolean | User$eventArgs<ExtArgs>
    likedBlogs?: boolean | User$likedBlogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      cart: Prisma.$CartPayload<ExtArgs>[]
      checklists: Prisma.$ChecklistPayload<ExtArgs>[]
      guests: Prisma.$GuestPayload<ExtArgs>[]
      paymentDetails: Prisma.$PaymentDetailsPayload<ExtArgs>[]
      orderDetails: Prisma.$OrderDetailsPayload<ExtArgs>[]
      userDataTemplate: Prisma.$UserDataTemplatePayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs>[]
      likedBlogs: Prisma.$LikedBlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      refresh_Token: string | null
      password_hash: string | null
      googleUid: string | null
      resetPassword_Token: string | null
      profile_photo: string | null
      user_name: string
      phone_number: string | null
      role: $Enums.Role
      wedding_date: Date | null
      wedding_location: string | null
      created_at: Date
      is_verified: boolean
      updated_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cart<T extends User$cartArgs<ExtArgs> = {}>(args?: Subset<T, User$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    checklists<T extends User$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, User$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    guests<T extends User$guestsArgs<ExtArgs> = {}>(args?: Subset<T, User$guestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    paymentDetails<T extends User$paymentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    orderDetails<T extends User$orderDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$orderDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    userDataTemplate<T extends User$userDataTemplateArgs<ExtArgs> = {}>(args?: Subset<T, User$userDataTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    event<T extends User$eventArgs<ExtArgs> = {}>(args?: Subset<T, User$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    likedBlogs<T extends User$likedBlogsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedBlogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly refresh_Token: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly googleUid: FieldRef<"User", 'String'>
    readonly resetPassword_Token: FieldRef<"User", 'String'>
    readonly profile_photo: FieldRef<"User", 'String'>
    readonly user_name: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly wedding_date: FieldRef<"User", 'DateTime'>
    readonly wedding_location: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly is_verified: FieldRef<"User", 'Boolean'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.cart
   */
  export type User$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.checklists
   */
  export type User$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    where?: ChecklistWhereInput
    orderBy?: ChecklistOrderByWithRelationInput | ChecklistOrderByWithRelationInput[]
    cursor?: ChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChecklistScalarFieldEnum | ChecklistScalarFieldEnum[]
  }

  /**
   * User.guests
   */
  export type User$guestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    cursor?: GuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * User.paymentDetails
   */
  export type User$paymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    where?: PaymentDetailsWhereInput
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    cursor?: PaymentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * User.orderDetails
   */
  export type User$orderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    cursor?: OrderDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * User.userDataTemplate
   */
  export type User$userDataTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    where?: UserDataTemplateWhereInput
    orderBy?: UserDataTemplateOrderByWithRelationInput | UserDataTemplateOrderByWithRelationInput[]
    cursor?: UserDataTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDataTemplateScalarFieldEnum | UserDataTemplateScalarFieldEnum[]
  }

  /**
   * User.event
   */
  export type User$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.likedBlogs
   */
  export type User$likedBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    where?: LikedBlogWhereInput
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    cursor?: LikedBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedBlogScalarFieldEnum | LikedBlogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    negotiated_price: number | null
    totalAmount: number | null
  }

  export type BookingSumAggregateOutputType = {
    negotiated_price: number | null
    totalAmount: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    booking_id: string | null
    service_id: string | null
    vendor_id: string | null
    booking_date: Date | null
    status: string | null
    negotiated_price: number | null
    is_negotiable: boolean | null
    totalAmount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    booking_id: string | null
    service_id: string | null
    vendor_id: string | null
    booking_date: Date | null
    status: string | null
    negotiated_price: number | null
    is_negotiable: boolean | null
    totalAmount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    booking_id: number
    service_id: number
    vendor_id: number
    booking_date: number
    status: number
    negotiated_price: number
    is_negotiable: number
    totalAmount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    negotiated_price?: true
    totalAmount?: true
  }

  export type BookingSumAggregateInputType = {
    negotiated_price?: true
    totalAmount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    booking_id?: true
    service_id?: true
    vendor_id?: true
    booking_date?: true
    status?: true
    negotiated_price?: true
    is_negotiable?: true
    totalAmount?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    booking_id?: true
    service_id?: true
    vendor_id?: true
    booking_date?: true
    status?: true
    negotiated_price?: true
    is_negotiable?: true
    totalAmount?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    booking_id?: true
    service_id?: true
    vendor_id?: true
    booking_date?: true
    status?: true
    negotiated_price?: true
    is_negotiable?: true
    totalAmount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    booking_id: string
    service_id: string
    vendor_id: string
    booking_date: Date
    status: string
    negotiated_price: number | null
    is_negotiable: boolean
    totalAmount: number
    created_at: Date
    updated_at: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    service_id?: boolean
    vendor_id?: boolean
    booking_date?: boolean
    status?: boolean
    negotiated_price?: boolean
    is_negotiable?: boolean
    totalAmount?: boolean
    created_at?: boolean
    updated_at?: boolean
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    service_id?: boolean
    vendor_id?: boolean
    booking_date?: boolean
    status?: boolean
    negotiated_price?: boolean
    is_negotiable?: boolean
    totalAmount?: boolean
    created_at?: boolean
    updated_at?: boolean
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    service_id?: boolean
    vendor_id?: boolean
    booking_date?: boolean
    status?: boolean
    negotiated_price?: boolean
    is_negotiable?: boolean
    totalAmount?: boolean
    created_at?: boolean
    updated_at?: boolean
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    booking_id?: boolean
    service_id?: boolean
    vendor_id?: boolean
    booking_date?: boolean
    status?: boolean
    negotiated_price?: boolean
    is_negotiable?: boolean
    totalAmount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_id" | "service_id" | "vendor_id" | "booking_date" | "status" | "negotiated_price" | "is_negotiable" | "totalAmount" | "created_at" | "updated_at", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userId?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      userId: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      booking_id: string
      service_id: string
      vendor_id: string
      booking_date: Date
      status: string
      negotiated_price: number | null
      is_negotiable: boolean
      totalAmount: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userId<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly booking_id: FieldRef<"Booking", 'String'>
    readonly service_id: FieldRef<"Booking", 'String'>
    readonly vendor_id: FieldRef<"Booking", 'String'>
    readonly booking_date: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly negotiated_price: FieldRef<"Booking", 'Float'>
    readonly is_negotiable: FieldRef<"Booking", 'Boolean'>
    readonly totalAmount: FieldRef<"Booking", 'Float'>
    readonly created_at: FieldRef<"Booking", 'DateTime'>
    readonly updated_at: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    createdAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceId" | "createdAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      createdAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */ 
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly serviceId: FieldRef<"Cart", 'String'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model Checklist
   */

  export type AggregateChecklist = {
    _count: ChecklistCountAggregateOutputType | null
    _min: ChecklistMinAggregateOutputType | null
    _max: ChecklistMaxAggregateOutputType | null
  }

  export type ChecklistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistCountAggregateOutputType = {
    id: number
    userId: number
    items: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChecklistMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistCountAggregateInputType = {
    id?: true
    userId?: true
    items?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checklist to aggregate.
     */
    where?: ChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checklists to fetch.
     */
    orderBy?: ChecklistOrderByWithRelationInput | ChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Checklists
    **/
    _count?: true | ChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecklistMaxAggregateInputType
  }

  export type GetChecklistAggregateType<T extends ChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklist[P]>
      : GetScalarType<T[P], AggregateChecklist[P]>
  }




  export type ChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistWhereInput
    orderBy?: ChecklistOrderByWithAggregationInput | ChecklistOrderByWithAggregationInput[]
    by: ChecklistScalarFieldEnum[] | ChecklistScalarFieldEnum
    having?: ChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecklistCountAggregateInputType | true
    _min?: ChecklistMinAggregateInputType
    _max?: ChecklistMaxAggregateInputType
  }

  export type ChecklistGroupByOutputType = {
    id: string
    userId: string
    items: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ChecklistCountAggregateOutputType | null
    _min: ChecklistMinAggregateOutputType | null
    _max: ChecklistMaxAggregateOutputType | null
  }

  type GetChecklistGroupByPayload<T extends ChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], ChecklistGroupByOutputType[P]>
        }
      >
    >


  export type ChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklist"]>

  export type ChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklist"]>

  export type ChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklist"]>

  export type ChecklistSelectScalar = {
    id?: boolean
    userId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "items" | "createdAt" | "updatedAt", ExtArgs["result"]["checklist"]>
  export type ChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Checklist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      items: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checklist"]>
    composites: {}
  }

  type ChecklistGetPayload<S extends boolean | null | undefined | ChecklistDefaultArgs> = $Result.GetResult<Prisma.$ChecklistPayload, S>

  type ChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChecklistCountAggregateInputType | true
    }

  export interface ChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Checklist'], meta: { name: 'Checklist' } }
    /**
     * Find zero or one Checklist that matches the filter.
     * @param {ChecklistFindUniqueArgs} args - Arguments to find a Checklist
     * @example
     * // Get one Checklist
     * const checklist = await prisma.checklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChecklistFindUniqueArgs>(args: SelectSubset<T, ChecklistFindUniqueArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Checklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChecklistFindUniqueOrThrowArgs} args - Arguments to find a Checklist
     * @example
     * // Get one Checklist
     * const checklist = await prisma.checklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, ChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Checklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistFindFirstArgs} args - Arguments to find a Checklist
     * @example
     * // Get one Checklist
     * const checklist = await prisma.checklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChecklistFindFirstArgs>(args?: SelectSubset<T, ChecklistFindFirstArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Checklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistFindFirstOrThrowArgs} args - Arguments to find a Checklist
     * @example
     * // Get one Checklist
     * const checklist = await prisma.checklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, ChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Checklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checklists
     * const checklists = await prisma.checklist.findMany()
     * 
     * // Get first 10 Checklists
     * const checklists = await prisma.checklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklistWithIdOnly = await prisma.checklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChecklistFindManyArgs>(args?: SelectSubset<T, ChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Checklist.
     * @param {ChecklistCreateArgs} args - Arguments to create a Checklist.
     * @example
     * // Create one Checklist
     * const Checklist = await prisma.checklist.create({
     *   data: {
     *     // ... data to create a Checklist
     *   }
     * })
     * 
     */
    create<T extends ChecklistCreateArgs>(args: SelectSubset<T, ChecklistCreateArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Checklists.
     * @param {ChecklistCreateManyArgs} args - Arguments to create many Checklists.
     * @example
     * // Create many Checklists
     * const checklist = await prisma.checklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChecklistCreateManyArgs>(args?: SelectSubset<T, ChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checklists and returns the data saved in the database.
     * @param {ChecklistCreateManyAndReturnArgs} args - Arguments to create many Checklists.
     * @example
     * // Create many Checklists
     * const checklist = await prisma.checklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checklists and only return the `id`
     * const checklistWithIdOnly = await prisma.checklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, ChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Checklist.
     * @param {ChecklistDeleteArgs} args - Arguments to delete one Checklist.
     * @example
     * // Delete one Checklist
     * const Checklist = await prisma.checklist.delete({
     *   where: {
     *     // ... filter to delete one Checklist
     *   }
     * })
     * 
     */
    delete<T extends ChecklistDeleteArgs>(args: SelectSubset<T, ChecklistDeleteArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Checklist.
     * @param {ChecklistUpdateArgs} args - Arguments to update one Checklist.
     * @example
     * // Update one Checklist
     * const checklist = await prisma.checklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChecklistUpdateArgs>(args: SelectSubset<T, ChecklistUpdateArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Checklists.
     * @param {ChecklistDeleteManyArgs} args - Arguments to filter Checklists to delete.
     * @example
     * // Delete a few Checklists
     * const { count } = await prisma.checklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChecklistDeleteManyArgs>(args?: SelectSubset<T, ChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checklists
     * const checklist = await prisma.checklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChecklistUpdateManyArgs>(args: SelectSubset<T, ChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checklists and returns the data updated in the database.
     * @param {ChecklistUpdateManyAndReturnArgs} args - Arguments to update many Checklists.
     * @example
     * // Update many Checklists
     * const checklist = await prisma.checklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Checklists and only return the `id`
     * const checklistWithIdOnly = await prisma.checklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, ChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Checklist.
     * @param {ChecklistUpsertArgs} args - Arguments to update or create a Checklist.
     * @example
     * // Update or create a Checklist
     * const checklist = await prisma.checklist.upsert({
     *   create: {
     *     // ... data to create a Checklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checklist we want to update
     *   }
     * })
     */
    upsert<T extends ChecklistUpsertArgs>(args: SelectSubset<T, ChecklistUpsertArgs<ExtArgs>>): Prisma__ChecklistClient<$Result.GetResult<Prisma.$ChecklistPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Checklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistCountArgs} args - Arguments to filter Checklists to count.
     * @example
     * // Count the number of Checklists
     * const count = await prisma.checklist.count({
     *   where: {
     *     // ... the filter for the Checklists we want to count
     *   }
     * })
    **/
    count<T extends ChecklistCountArgs>(
      args?: Subset<T, ChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecklistAggregateArgs>(args: Subset<T, ChecklistAggregateArgs>): Prisma.PrismaPromise<GetChecklistAggregateType<T>>

    /**
     * Group by Checklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecklistGroupByArgs['orderBy'] }
        : { orderBy?: ChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Checklist model
   */
  readonly fields: ChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Checklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Checklist model
   */ 
  interface ChecklistFieldRefs {
    readonly id: FieldRef<"Checklist", 'String'>
    readonly userId: FieldRef<"Checklist", 'String'>
    readonly items: FieldRef<"Checklist", 'Json'>
    readonly createdAt: FieldRef<"Checklist", 'DateTime'>
    readonly updatedAt: FieldRef<"Checklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Checklist findUnique
   */
  export type ChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter, which Checklist to fetch.
     */
    where: ChecklistWhereUniqueInput
  }

  /**
   * Checklist findUniqueOrThrow
   */
  export type ChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter, which Checklist to fetch.
     */
    where: ChecklistWhereUniqueInput
  }

  /**
   * Checklist findFirst
   */
  export type ChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter, which Checklist to fetch.
     */
    where?: ChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checklists to fetch.
     */
    orderBy?: ChecklistOrderByWithRelationInput | ChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checklists.
     */
    cursor?: ChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checklists.
     */
    distinct?: ChecklistScalarFieldEnum | ChecklistScalarFieldEnum[]
  }

  /**
   * Checklist findFirstOrThrow
   */
  export type ChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter, which Checklist to fetch.
     */
    where?: ChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checklists to fetch.
     */
    orderBy?: ChecklistOrderByWithRelationInput | ChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checklists.
     */
    cursor?: ChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checklists.
     */
    distinct?: ChecklistScalarFieldEnum | ChecklistScalarFieldEnum[]
  }

  /**
   * Checklist findMany
   */
  export type ChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter, which Checklists to fetch.
     */
    where?: ChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checklists to fetch.
     */
    orderBy?: ChecklistOrderByWithRelationInput | ChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Checklists.
     */
    cursor?: ChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checklists.
     */
    skip?: number
    distinct?: ChecklistScalarFieldEnum | ChecklistScalarFieldEnum[]
  }

  /**
   * Checklist create
   */
  export type ChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a Checklist.
     */
    data: XOR<ChecklistCreateInput, ChecklistUncheckedCreateInput>
  }

  /**
   * Checklist createMany
   */
  export type ChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Checklists.
     */
    data: ChecklistCreateManyInput | ChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Checklist createManyAndReturn
   */
  export type ChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many Checklists.
     */
    data: ChecklistCreateManyInput | ChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checklist update
   */
  export type ChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a Checklist.
     */
    data: XOR<ChecklistUpdateInput, ChecklistUncheckedUpdateInput>
    /**
     * Choose, which Checklist to update.
     */
    where: ChecklistWhereUniqueInput
  }

  /**
   * Checklist updateMany
   */
  export type ChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Checklists.
     */
    data: XOR<ChecklistUpdateManyMutationInput, ChecklistUncheckedUpdateManyInput>
    /**
     * Filter which Checklists to update
     */
    where?: ChecklistWhereInput
  }

  /**
   * Checklist updateManyAndReturn
   */
  export type ChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * The data used to update Checklists.
     */
    data: XOR<ChecklistUpdateManyMutationInput, ChecklistUncheckedUpdateManyInput>
    /**
     * Filter which Checklists to update
     */
    where?: ChecklistWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checklist upsert
   */
  export type ChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the Checklist to update in case it exists.
     */
    where: ChecklistWhereUniqueInput
    /**
     * In case the Checklist found by the `where` argument doesn't exist, create a new Checklist with this data.
     */
    create: XOR<ChecklistCreateInput, ChecklistUncheckedCreateInput>
    /**
     * In case the Checklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChecklistUpdateInput, ChecklistUncheckedUpdateInput>
  }

  /**
   * Checklist delete
   */
  export type ChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
    /**
     * Filter which Checklist to delete.
     */
    where: ChecklistWhereUniqueInput
  }

  /**
   * Checklist deleteMany
   */
  export type ChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checklists to delete
     */
    where?: ChecklistWhereInput
  }

  /**
   * Checklist without action
   */
  export type ChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist
     */
    select?: ChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Checklist
     */
    omit?: ChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    eventBudget: Decimal | null
  }

  export type EventSumAggregateOutputType = {
    eventBudget: Decimal | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventName: string | null
    eventDescription: string | null
    eventDate: Date | null
    eventStartTime: Date | null
    eventEndTime: Date | null
    eventBudget: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventName: string | null
    eventDescription: string | null
    eventDate: Date | null
    eventStartTime: Date | null
    eventEndTime: Date | null
    eventBudget: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    userId: number
    eventName: number
    eventDescription: number
    eventDate: number
    eventStartTime: number
    eventEndTime: number
    eventBudget: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    eventBudget?: true
  }

  export type EventSumAggregateInputType = {
    eventBudget?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    eventDescription?: true
    eventDate?: true
    eventStartTime?: true
    eventEndTime?: true
    eventBudget?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    eventDescription?: true
    eventDate?: true
    eventStartTime?: true
    eventEndTime?: true
    eventBudget?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    userId?: true
    eventName?: true
    eventDescription?: true
    eventDate?: true
    eventStartTime?: true
    eventEndTime?: true
    eventBudget?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    userId: string
    eventName: string
    eventDescription: string | null
    eventDate: Date
    eventStartTime: Date | null
    eventEndTime: Date | null
    eventBudget: Decimal
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventDate?: boolean
    eventStartTime?: boolean
    eventEndTime?: boolean
    eventBudget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    eventTask?: boolean | Event$eventTaskArgs<ExtArgs>
    eventVendors?: boolean | Event$eventVendorsArgs<ExtArgs>
    subEvent?: boolean | Event$subEventArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventDate?: boolean
    eventStartTime?: boolean
    eventEndTime?: boolean
    eventBudget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventDate?: boolean
    eventStartTime?: boolean
    eventEndTime?: boolean
    eventBudget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventDate?: boolean
    eventStartTime?: boolean
    eventEndTime?: boolean
    eventBudget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventName" | "eventDescription" | "eventDate" | "eventStartTime" | "eventEndTime" | "eventBudget" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    eventTask?: boolean | Event$eventTaskArgs<ExtArgs>
    eventVendors?: boolean | Event$eventVendorsArgs<ExtArgs>
    subEvent?: boolean | Event$subEventArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      eventTask: Prisma.$EventTaskPayload<ExtArgs>[]
      eventVendors: Prisma.$EventVendorsPayload<ExtArgs>[]
      subEvent: Prisma.$SubEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventName: string
      eventDescription: string | null
      eventDate: Date
      eventStartTime: Date | null
      eventEndTime: Date | null
      eventBudget: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    eventTask<T extends Event$eventTaskArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    eventVendors<T extends Event$eventVendorsArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventVendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    subEvent<T extends Event$subEventArgs<ExtArgs> = {}>(args?: Subset<T, Event$subEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
    readonly eventName: FieldRef<"Event", 'String'>
    readonly eventDescription: FieldRef<"Event", 'String'>
    readonly eventDate: FieldRef<"Event", 'DateTime'>
    readonly eventStartTime: FieldRef<"Event", 'DateTime'>
    readonly eventEndTime: FieldRef<"Event", 'DateTime'>
    readonly eventBudget: FieldRef<"Event", 'Decimal'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.eventTask
   */
  export type Event$eventTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    where?: EventTaskWhereInput
    orderBy?: EventTaskOrderByWithRelationInput | EventTaskOrderByWithRelationInput[]
    cursor?: EventTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventTaskScalarFieldEnum | EventTaskScalarFieldEnum[]
  }

  /**
   * Event.eventVendors
   */
  export type Event$eventVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    where?: EventVendorsWhereInput
    orderBy?: EventVendorsOrderByWithRelationInput | EventVendorsOrderByWithRelationInput[]
    cursor?: EventVendorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventVendorsScalarFieldEnum | EventVendorsScalarFieldEnum[]
  }

  /**
   * Event.subEvent
   */
  export type Event$subEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    where?: SubEventWhereInput
    orderBy?: SubEventOrderByWithRelationInput | SubEventOrderByWithRelationInput[]
    cursor?: SubEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubEventScalarFieldEnum | SubEventScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventVendors
   */

  export type AggregateEventVendors = {
    _count: EventVendorsCountAggregateOutputType | null
    _min: EventVendorsMinAggregateOutputType | null
    _max: EventVendorsMaxAggregateOutputType | null
  }

  export type EventVendorsMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type EventVendorsMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type EventVendorsCountAggregateOutputType = {
    id: number
    eventId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type EventVendorsMinAggregateInputType = {
    id?: true
    eventId?: true
    serviceId?: true
    createdAt?: true
  }

  export type EventVendorsMaxAggregateInputType = {
    id?: true
    eventId?: true
    serviceId?: true
    createdAt?: true
  }

  export type EventVendorsCountAggregateInputType = {
    id?: true
    eventId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type EventVendorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventVendors to aggregate.
     */
    where?: EventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventVendors to fetch.
     */
    orderBy?: EventVendorsOrderByWithRelationInput | EventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventVendors
    **/
    _count?: true | EventVendorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventVendorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventVendorsMaxAggregateInputType
  }

  export type GetEventVendorsAggregateType<T extends EventVendorsAggregateArgs> = {
        [P in keyof T & keyof AggregateEventVendors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventVendors[P]>
      : GetScalarType<T[P], AggregateEventVendors[P]>
  }




  export type EventVendorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventVendorsWhereInput
    orderBy?: EventVendorsOrderByWithAggregationInput | EventVendorsOrderByWithAggregationInput[]
    by: EventVendorsScalarFieldEnum[] | EventVendorsScalarFieldEnum
    having?: EventVendorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventVendorsCountAggregateInputType | true
    _min?: EventVendorsMinAggregateInputType
    _max?: EventVendorsMaxAggregateInputType
  }

  export type EventVendorsGroupByOutputType = {
    id: string
    eventId: string
    serviceId: string
    createdAt: Date
    _count: EventVendorsCountAggregateOutputType | null
    _min: EventVendorsMinAggregateOutputType | null
    _max: EventVendorsMaxAggregateOutputType | null
  }

  type GetEventVendorsGroupByPayload<T extends EventVendorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventVendorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventVendorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventVendorsGroupByOutputType[P]>
            : GetScalarType<T[P], EventVendorsGroupByOutputType[P]>
        }
      >
    >


  export type EventVendorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventVendors"]>

  export type EventVendorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventVendors"]>

  export type EventVendorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventVendors"]>

  export type EventVendorsSelectScalar = {
    id?: boolean
    eventId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type EventVendorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "serviceId" | "createdAt", ExtArgs["result"]["eventVendors"]>
  export type EventVendorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventVendorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventVendorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventVendorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventVendors"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      serviceId: string
      createdAt: Date
    }, ExtArgs["result"]["eventVendors"]>
    composites: {}
  }

  type EventVendorsGetPayload<S extends boolean | null | undefined | EventVendorsDefaultArgs> = $Result.GetResult<Prisma.$EventVendorsPayload, S>

  type EventVendorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventVendorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventVendorsCountAggregateInputType | true
    }

  export interface EventVendorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventVendors'], meta: { name: 'EventVendors' } }
    /**
     * Find zero or one EventVendors that matches the filter.
     * @param {EventVendorsFindUniqueArgs} args - Arguments to find a EventVendors
     * @example
     * // Get one EventVendors
     * const eventVendors = await prisma.eventVendors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventVendorsFindUniqueArgs>(args: SelectSubset<T, EventVendorsFindUniqueArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EventVendors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventVendorsFindUniqueOrThrowArgs} args - Arguments to find a EventVendors
     * @example
     * // Get one EventVendors
     * const eventVendors = await prisma.eventVendors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventVendorsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventVendorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EventVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsFindFirstArgs} args - Arguments to find a EventVendors
     * @example
     * // Get one EventVendors
     * const eventVendors = await prisma.eventVendors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventVendorsFindFirstArgs>(args?: SelectSubset<T, EventVendorsFindFirstArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EventVendors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsFindFirstOrThrowArgs} args - Arguments to find a EventVendors
     * @example
     * // Get one EventVendors
     * const eventVendors = await prisma.eventVendors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventVendorsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventVendorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EventVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventVendors
     * const eventVendors = await prisma.eventVendors.findMany()
     * 
     * // Get first 10 EventVendors
     * const eventVendors = await prisma.eventVendors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventVendorsWithIdOnly = await prisma.eventVendors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventVendorsFindManyArgs>(args?: SelectSubset<T, EventVendorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EventVendors.
     * @param {EventVendorsCreateArgs} args - Arguments to create a EventVendors.
     * @example
     * // Create one EventVendors
     * const EventVendors = await prisma.eventVendors.create({
     *   data: {
     *     // ... data to create a EventVendors
     *   }
     * })
     * 
     */
    create<T extends EventVendorsCreateArgs>(args: SelectSubset<T, EventVendorsCreateArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EventVendors.
     * @param {EventVendorsCreateManyArgs} args - Arguments to create many EventVendors.
     * @example
     * // Create many EventVendors
     * const eventVendors = await prisma.eventVendors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventVendorsCreateManyArgs>(args?: SelectSubset<T, EventVendorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventVendors and returns the data saved in the database.
     * @param {EventVendorsCreateManyAndReturnArgs} args - Arguments to create many EventVendors.
     * @example
     * // Create many EventVendors
     * const eventVendors = await prisma.eventVendors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventVendors and only return the `id`
     * const eventVendorsWithIdOnly = await prisma.eventVendors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventVendorsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventVendorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EventVendors.
     * @param {EventVendorsDeleteArgs} args - Arguments to delete one EventVendors.
     * @example
     * // Delete one EventVendors
     * const EventVendors = await prisma.eventVendors.delete({
     *   where: {
     *     // ... filter to delete one EventVendors
     *   }
     * })
     * 
     */
    delete<T extends EventVendorsDeleteArgs>(args: SelectSubset<T, EventVendorsDeleteArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EventVendors.
     * @param {EventVendorsUpdateArgs} args - Arguments to update one EventVendors.
     * @example
     * // Update one EventVendors
     * const eventVendors = await prisma.eventVendors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventVendorsUpdateArgs>(args: SelectSubset<T, EventVendorsUpdateArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EventVendors.
     * @param {EventVendorsDeleteManyArgs} args - Arguments to filter EventVendors to delete.
     * @example
     * // Delete a few EventVendors
     * const { count } = await prisma.eventVendors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventVendorsDeleteManyArgs>(args?: SelectSubset<T, EventVendorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventVendors
     * const eventVendors = await prisma.eventVendors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventVendorsUpdateManyArgs>(args: SelectSubset<T, EventVendorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventVendors and returns the data updated in the database.
     * @param {EventVendorsUpdateManyAndReturnArgs} args - Arguments to update many EventVendors.
     * @example
     * // Update many EventVendors
     * const eventVendors = await prisma.eventVendors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventVendors and only return the `id`
     * const eventVendorsWithIdOnly = await prisma.eventVendors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventVendorsUpdateManyAndReturnArgs>(args: SelectSubset<T, EventVendorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EventVendors.
     * @param {EventVendorsUpsertArgs} args - Arguments to update or create a EventVendors.
     * @example
     * // Update or create a EventVendors
     * const eventVendors = await prisma.eventVendors.upsert({
     *   create: {
     *     // ... data to create a EventVendors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventVendors we want to update
     *   }
     * })
     */
    upsert<T extends EventVendorsUpsertArgs>(args: SelectSubset<T, EventVendorsUpsertArgs<ExtArgs>>): Prisma__EventVendorsClient<$Result.GetResult<Prisma.$EventVendorsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsCountArgs} args - Arguments to filter EventVendors to count.
     * @example
     * // Count the number of EventVendors
     * const count = await prisma.eventVendors.count({
     *   where: {
     *     // ... the filter for the EventVendors we want to count
     *   }
     * })
    **/
    count<T extends EventVendorsCountArgs>(
      args?: Subset<T, EventVendorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventVendorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventVendorsAggregateArgs>(args: Subset<T, EventVendorsAggregateArgs>): Prisma.PrismaPromise<GetEventVendorsAggregateType<T>>

    /**
     * Group by EventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventVendorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventVendorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventVendorsGroupByArgs['orderBy'] }
        : { orderBy?: EventVendorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventVendorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventVendorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventVendors model
   */
  readonly fields: EventVendorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventVendors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventVendorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventVendors model
   */ 
  interface EventVendorsFieldRefs {
    readonly id: FieldRef<"EventVendors", 'String'>
    readonly eventId: FieldRef<"EventVendors", 'String'>
    readonly serviceId: FieldRef<"EventVendors", 'String'>
    readonly createdAt: FieldRef<"EventVendors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventVendors findUnique
   */
  export type EventVendorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which EventVendors to fetch.
     */
    where: EventVendorsWhereUniqueInput
  }

  /**
   * EventVendors findUniqueOrThrow
   */
  export type EventVendorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which EventVendors to fetch.
     */
    where: EventVendorsWhereUniqueInput
  }

  /**
   * EventVendors findFirst
   */
  export type EventVendorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which EventVendors to fetch.
     */
    where?: EventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventVendors to fetch.
     */
    orderBy?: EventVendorsOrderByWithRelationInput | EventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventVendors.
     */
    cursor?: EventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventVendors.
     */
    distinct?: EventVendorsScalarFieldEnum | EventVendorsScalarFieldEnum[]
  }

  /**
   * EventVendors findFirstOrThrow
   */
  export type EventVendorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which EventVendors to fetch.
     */
    where?: EventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventVendors to fetch.
     */
    orderBy?: EventVendorsOrderByWithRelationInput | EventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventVendors.
     */
    cursor?: EventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventVendors.
     */
    distinct?: EventVendorsScalarFieldEnum | EventVendorsScalarFieldEnum[]
  }

  /**
   * EventVendors findMany
   */
  export type EventVendorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which EventVendors to fetch.
     */
    where?: EventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventVendors to fetch.
     */
    orderBy?: EventVendorsOrderByWithRelationInput | EventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventVendors.
     */
    cursor?: EventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventVendors.
     */
    skip?: number
    distinct?: EventVendorsScalarFieldEnum | EventVendorsScalarFieldEnum[]
  }

  /**
   * EventVendors create
   */
  export type EventVendorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * The data needed to create a EventVendors.
     */
    data: XOR<EventVendorsCreateInput, EventVendorsUncheckedCreateInput>
  }

  /**
   * EventVendors createMany
   */
  export type EventVendorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventVendors.
     */
    data: EventVendorsCreateManyInput | EventVendorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventVendors createManyAndReturn
   */
  export type EventVendorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * The data used to create many EventVendors.
     */
    data: EventVendorsCreateManyInput | EventVendorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventVendors update
   */
  export type EventVendorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * The data needed to update a EventVendors.
     */
    data: XOR<EventVendorsUpdateInput, EventVendorsUncheckedUpdateInput>
    /**
     * Choose, which EventVendors to update.
     */
    where: EventVendorsWhereUniqueInput
  }

  /**
   * EventVendors updateMany
   */
  export type EventVendorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventVendors.
     */
    data: XOR<EventVendorsUpdateManyMutationInput, EventVendorsUncheckedUpdateManyInput>
    /**
     * Filter which EventVendors to update
     */
    where?: EventVendorsWhereInput
  }

  /**
   * EventVendors updateManyAndReturn
   */
  export type EventVendorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * The data used to update EventVendors.
     */
    data: XOR<EventVendorsUpdateManyMutationInput, EventVendorsUncheckedUpdateManyInput>
    /**
     * Filter which EventVendors to update
     */
    where?: EventVendorsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventVendors upsert
   */
  export type EventVendorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * The filter to search for the EventVendors to update in case it exists.
     */
    where: EventVendorsWhereUniqueInput
    /**
     * In case the EventVendors found by the `where` argument doesn't exist, create a new EventVendors with this data.
     */
    create: XOR<EventVendorsCreateInput, EventVendorsUncheckedCreateInput>
    /**
     * In case the EventVendors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventVendorsUpdateInput, EventVendorsUncheckedUpdateInput>
  }

  /**
   * EventVendors delete
   */
  export type EventVendorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
    /**
     * Filter which EventVendors to delete.
     */
    where: EventVendorsWhereUniqueInput
  }

  /**
   * EventVendors deleteMany
   */
  export type EventVendorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventVendors to delete
     */
    where?: EventVendorsWhereInput
  }

  /**
   * EventVendors without action
   */
  export type EventVendorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventVendors
     */
    select?: EventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventVendors
     */
    omit?: EventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventVendorsInclude<ExtArgs> | null
  }


  /**
   * Model EventTask
   */

  export type AggregateEventTask = {
    _count: EventTaskCountAggregateOutputType | null
    _min: EventTaskMinAggregateOutputType | null
    _max: EventTaskMaxAggregateOutputType | null
  }

  export type EventTaskMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    priority: string | null
    done: boolean | null
    scheduleDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventTaskMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    priority: string | null
    done: boolean | null
    scheduleDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventTaskCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    priority: number
    done: number
    scheduleDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventTaskMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    priority?: true
    done?: true
    scheduleDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventTaskMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    priority?: true
    done?: true
    scheduleDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventTaskCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    priority?: true
    done?: true
    scheduleDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTask to aggregate.
     */
    where?: EventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTasks to fetch.
     */
    orderBy?: EventTaskOrderByWithRelationInput | EventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTasks
    **/
    _count?: true | EventTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTaskMaxAggregateInputType
  }

  export type GetEventTaskAggregateType<T extends EventTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateEventTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventTask[P]>
      : GetScalarType<T[P], AggregateEventTask[P]>
  }




  export type EventTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTaskWhereInput
    orderBy?: EventTaskOrderByWithAggregationInput | EventTaskOrderByWithAggregationInput[]
    by: EventTaskScalarFieldEnum[] | EventTaskScalarFieldEnum
    having?: EventTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTaskCountAggregateInputType | true
    _min?: EventTaskMinAggregateInputType
    _max?: EventTaskMaxAggregateInputType
  }

  export type EventTaskGroupByOutputType = {
    id: string
    eventId: string
    name: string
    priority: string
    done: boolean
    scheduleDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EventTaskCountAggregateOutputType | null
    _min: EventTaskMinAggregateOutputType | null
    _max: EventTaskMaxAggregateOutputType | null
  }

  type GetEventTaskGroupByPayload<T extends EventTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTaskGroupByOutputType[P]>
            : GetScalarType<T[P], EventTaskGroupByOutputType[P]>
        }
      >
    >


  export type EventTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    priority?: boolean
    done?: boolean
    scheduleDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventTask"]>

  export type EventTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    priority?: boolean
    done?: boolean
    scheduleDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventTask"]>

  export type EventTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    priority?: boolean
    done?: boolean
    scheduleDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventTask"]>

  export type EventTaskSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    priority?: boolean
    done?: boolean
    scheduleDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "priority" | "done" | "scheduleDate" | "createdAt" | "updatedAt", ExtArgs["result"]["eventTask"]>
  export type EventTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventTask"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      priority: string
      done: boolean
      scheduleDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventTask"]>
    composites: {}
  }

  type EventTaskGetPayload<S extends boolean | null | undefined | EventTaskDefaultArgs> = $Result.GetResult<Prisma.$EventTaskPayload, S>

  type EventTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventTaskCountAggregateInputType | true
    }

  export interface EventTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventTask'], meta: { name: 'EventTask' } }
    /**
     * Find zero or one EventTask that matches the filter.
     * @param {EventTaskFindUniqueArgs} args - Arguments to find a EventTask
     * @example
     * // Get one EventTask
     * const eventTask = await prisma.eventTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTaskFindUniqueArgs>(args: SelectSubset<T, EventTaskFindUniqueArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EventTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventTaskFindUniqueOrThrowArgs} args - Arguments to find a EventTask
     * @example
     * // Get one EventTask
     * const eventTask = await prisma.eventTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EventTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskFindFirstArgs} args - Arguments to find a EventTask
     * @example
     * // Get one EventTask
     * const eventTask = await prisma.eventTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTaskFindFirstArgs>(args?: SelectSubset<T, EventTaskFindFirstArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EventTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskFindFirstOrThrowArgs} args - Arguments to find a EventTask
     * @example
     * // Get one EventTask
     * const eventTask = await prisma.eventTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EventTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTasks
     * const eventTasks = await prisma.eventTask.findMany()
     * 
     * // Get first 10 EventTasks
     * const eventTasks = await prisma.eventTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTaskWithIdOnly = await prisma.eventTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTaskFindManyArgs>(args?: SelectSubset<T, EventTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EventTask.
     * @param {EventTaskCreateArgs} args - Arguments to create a EventTask.
     * @example
     * // Create one EventTask
     * const EventTask = await prisma.eventTask.create({
     *   data: {
     *     // ... data to create a EventTask
     *   }
     * })
     * 
     */
    create<T extends EventTaskCreateArgs>(args: SelectSubset<T, EventTaskCreateArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EventTasks.
     * @param {EventTaskCreateManyArgs} args - Arguments to create many EventTasks.
     * @example
     * // Create many EventTasks
     * const eventTask = await prisma.eventTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTaskCreateManyArgs>(args?: SelectSubset<T, EventTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventTasks and returns the data saved in the database.
     * @param {EventTaskCreateManyAndReturnArgs} args - Arguments to create many EventTasks.
     * @example
     * // Create many EventTasks
     * const eventTask = await prisma.eventTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventTasks and only return the `id`
     * const eventTaskWithIdOnly = await prisma.eventTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, EventTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EventTask.
     * @param {EventTaskDeleteArgs} args - Arguments to delete one EventTask.
     * @example
     * // Delete one EventTask
     * const EventTask = await prisma.eventTask.delete({
     *   where: {
     *     // ... filter to delete one EventTask
     *   }
     * })
     * 
     */
    delete<T extends EventTaskDeleteArgs>(args: SelectSubset<T, EventTaskDeleteArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EventTask.
     * @param {EventTaskUpdateArgs} args - Arguments to update one EventTask.
     * @example
     * // Update one EventTask
     * const eventTask = await prisma.eventTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTaskUpdateArgs>(args: SelectSubset<T, EventTaskUpdateArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EventTasks.
     * @param {EventTaskDeleteManyArgs} args - Arguments to filter EventTasks to delete.
     * @example
     * // Delete a few EventTasks
     * const { count } = await prisma.eventTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTaskDeleteManyArgs>(args?: SelectSubset<T, EventTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTasks
     * const eventTask = await prisma.eventTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTaskUpdateManyArgs>(args: SelectSubset<T, EventTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTasks and returns the data updated in the database.
     * @param {EventTaskUpdateManyAndReturnArgs} args - Arguments to update many EventTasks.
     * @example
     * // Update many EventTasks
     * const eventTask = await prisma.eventTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventTasks and only return the `id`
     * const eventTaskWithIdOnly = await prisma.eventTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, EventTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EventTask.
     * @param {EventTaskUpsertArgs} args - Arguments to update or create a EventTask.
     * @example
     * // Update or create a EventTask
     * const eventTask = await prisma.eventTask.upsert({
     *   create: {
     *     // ... data to create a EventTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventTask we want to update
     *   }
     * })
     */
    upsert<T extends EventTaskUpsertArgs>(args: SelectSubset<T, EventTaskUpsertArgs<ExtArgs>>): Prisma__EventTaskClient<$Result.GetResult<Prisma.$EventTaskPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EventTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskCountArgs} args - Arguments to filter EventTasks to count.
     * @example
     * // Count the number of EventTasks
     * const count = await prisma.eventTask.count({
     *   where: {
     *     // ... the filter for the EventTasks we want to count
     *   }
     * })
    **/
    count<T extends EventTaskCountArgs>(
      args?: Subset<T, EventTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTaskAggregateArgs>(args: Subset<T, EventTaskAggregateArgs>): Prisma.PrismaPromise<GetEventTaskAggregateType<T>>

    /**
     * Group by EventTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTaskGroupByArgs['orderBy'] }
        : { orderBy?: EventTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventTask model
   */
  readonly fields: EventTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventTask model
   */ 
  interface EventTaskFieldRefs {
    readonly id: FieldRef<"EventTask", 'String'>
    readonly eventId: FieldRef<"EventTask", 'String'>
    readonly name: FieldRef<"EventTask", 'String'>
    readonly priority: FieldRef<"EventTask", 'String'>
    readonly done: FieldRef<"EventTask", 'Boolean'>
    readonly scheduleDate: FieldRef<"EventTask", 'DateTime'>
    readonly createdAt: FieldRef<"EventTask", 'DateTime'>
    readonly updatedAt: FieldRef<"EventTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventTask findUnique
   */
  export type EventTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter, which EventTask to fetch.
     */
    where: EventTaskWhereUniqueInput
  }

  /**
   * EventTask findUniqueOrThrow
   */
  export type EventTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter, which EventTask to fetch.
     */
    where: EventTaskWhereUniqueInput
  }

  /**
   * EventTask findFirst
   */
  export type EventTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter, which EventTask to fetch.
     */
    where?: EventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTasks to fetch.
     */
    orderBy?: EventTaskOrderByWithRelationInput | EventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTasks.
     */
    cursor?: EventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTasks.
     */
    distinct?: EventTaskScalarFieldEnum | EventTaskScalarFieldEnum[]
  }

  /**
   * EventTask findFirstOrThrow
   */
  export type EventTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter, which EventTask to fetch.
     */
    where?: EventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTasks to fetch.
     */
    orderBy?: EventTaskOrderByWithRelationInput | EventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTasks.
     */
    cursor?: EventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTasks.
     */
    distinct?: EventTaskScalarFieldEnum | EventTaskScalarFieldEnum[]
  }

  /**
   * EventTask findMany
   */
  export type EventTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter, which EventTasks to fetch.
     */
    where?: EventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTasks to fetch.
     */
    orderBy?: EventTaskOrderByWithRelationInput | EventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTasks.
     */
    cursor?: EventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTasks.
     */
    skip?: number
    distinct?: EventTaskScalarFieldEnum | EventTaskScalarFieldEnum[]
  }

  /**
   * EventTask create
   */
  export type EventTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a EventTask.
     */
    data: XOR<EventTaskCreateInput, EventTaskUncheckedCreateInput>
  }

  /**
   * EventTask createMany
   */
  export type EventTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTasks.
     */
    data: EventTaskCreateManyInput | EventTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventTask createManyAndReturn
   */
  export type EventTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * The data used to create many EventTasks.
     */
    data: EventTaskCreateManyInput | EventTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventTask update
   */
  export type EventTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a EventTask.
     */
    data: XOR<EventTaskUpdateInput, EventTaskUncheckedUpdateInput>
    /**
     * Choose, which EventTask to update.
     */
    where: EventTaskWhereUniqueInput
  }

  /**
   * EventTask updateMany
   */
  export type EventTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTasks.
     */
    data: XOR<EventTaskUpdateManyMutationInput, EventTaskUncheckedUpdateManyInput>
    /**
     * Filter which EventTasks to update
     */
    where?: EventTaskWhereInput
  }

  /**
   * EventTask updateManyAndReturn
   */
  export type EventTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * The data used to update EventTasks.
     */
    data: XOR<EventTaskUpdateManyMutationInput, EventTaskUncheckedUpdateManyInput>
    /**
     * Filter which EventTasks to update
     */
    where?: EventTaskWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventTask upsert
   */
  export type EventTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the EventTask to update in case it exists.
     */
    where: EventTaskWhereUniqueInput
    /**
     * In case the EventTask found by the `where` argument doesn't exist, create a new EventTask with this data.
     */
    create: XOR<EventTaskCreateInput, EventTaskUncheckedCreateInput>
    /**
     * In case the EventTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTaskUpdateInput, EventTaskUncheckedUpdateInput>
  }

  /**
   * EventTask delete
   */
  export type EventTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
    /**
     * Filter which EventTask to delete.
     */
    where: EventTaskWhereUniqueInput
  }

  /**
   * EventTask deleteMany
   */
  export type EventTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTasks to delete
     */
    where?: EventTaskWhereInput
  }

  /**
   * EventTask without action
   */
  export type EventTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTask
     */
    select?: EventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventTask
     */
    omit?: EventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTaskInclude<ExtArgs> | null
  }


  /**
   * Model SubEvent
   */

  export type AggregateSubEvent = {
    _count: SubEventCountAggregateOutputType | null
    _avg: SubEventAvgAggregateOutputType | null
    _sum: SubEventSumAggregateOutputType | null
    _min: SubEventMinAggregateOutputType | null
    _max: SubEventMaxAggregateOutputType | null
  }

  export type SubEventAvgAggregateOutputType = {
    subEventBudget: Decimal | null
  }

  export type SubEventSumAggregateOutputType = {
    subEventBudget: Decimal | null
  }

  export type SubEventMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    subEventName: string | null
    subEventDescription: string | null
    subEventBudget: Decimal | null
    subEventDate: Date | null
    subEventStartTime: Date | null
    subEventEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubEventMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    subEventName: string | null
    subEventDescription: string | null
    subEventBudget: Decimal | null
    subEventDate: Date | null
    subEventStartTime: Date | null
    subEventEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubEventCountAggregateOutputType = {
    id: number
    eventId: number
    subEventName: number
    subEventDescription: number
    subEventBudget: number
    subEventDate: number
    subEventStartTime: number
    subEventEndTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubEventAvgAggregateInputType = {
    subEventBudget?: true
  }

  export type SubEventSumAggregateInputType = {
    subEventBudget?: true
  }

  export type SubEventMinAggregateInputType = {
    id?: true
    eventId?: true
    subEventName?: true
    subEventDescription?: true
    subEventBudget?: true
    subEventDate?: true
    subEventStartTime?: true
    subEventEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubEventMaxAggregateInputType = {
    id?: true
    eventId?: true
    subEventName?: true
    subEventDescription?: true
    subEventBudget?: true
    subEventDate?: true
    subEventStartTime?: true
    subEventEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubEventCountAggregateInputType = {
    id?: true
    eventId?: true
    subEventName?: true
    subEventDescription?: true
    subEventBudget?: true
    subEventDate?: true
    subEventStartTime?: true
    subEventEndTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEvent to aggregate.
     */
    where?: SubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEvents to fetch.
     */
    orderBy?: SubEventOrderByWithRelationInput | SubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubEvents
    **/
    _count?: true | SubEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubEventMaxAggregateInputType
  }

  export type GetSubEventAggregateType<T extends SubEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSubEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubEvent[P]>
      : GetScalarType<T[P], AggregateSubEvent[P]>
  }




  export type SubEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventWhereInput
    orderBy?: SubEventOrderByWithAggregationInput | SubEventOrderByWithAggregationInput[]
    by: SubEventScalarFieldEnum[] | SubEventScalarFieldEnum
    having?: SubEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubEventCountAggregateInputType | true
    _avg?: SubEventAvgAggregateInputType
    _sum?: SubEventSumAggregateInputType
    _min?: SubEventMinAggregateInputType
    _max?: SubEventMaxAggregateInputType
  }

  export type SubEventGroupByOutputType = {
    id: string
    eventId: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal
    subEventDate: Date
    subEventStartTime: Date
    subEventEndTime: Date
    createdAt: Date
    updatedAt: Date
    _count: SubEventCountAggregateOutputType | null
    _avg: SubEventAvgAggregateOutputType | null
    _sum: SubEventSumAggregateOutputType | null
    _min: SubEventMinAggregateOutputType | null
    _max: SubEventMaxAggregateOutputType | null
  }

  type GetSubEventGroupByPayload<T extends SubEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubEventGroupByOutputType[P]>
            : GetScalarType<T[P], SubEventGroupByOutputType[P]>
        }
      >
    >


  export type SubEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    subEventName?: boolean
    subEventDescription?: boolean
    subEventBudget?: boolean
    subEventDate?: boolean
    subEventStartTime?: boolean
    subEventEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    subEventTask?: boolean | SubEvent$subEventTaskArgs<ExtArgs>
    subEventVendors?: boolean | SubEvent$subEventVendorsArgs<ExtArgs>
    _count?: boolean | SubEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEvent"]>

  export type SubEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    subEventName?: boolean
    subEventDescription?: boolean
    subEventBudget?: boolean
    subEventDate?: boolean
    subEventStartTime?: boolean
    subEventEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEvent"]>

  export type SubEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    subEventName?: boolean
    subEventDescription?: boolean
    subEventBudget?: boolean
    subEventDate?: boolean
    subEventStartTime?: boolean
    subEventEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEvent"]>

  export type SubEventSelectScalar = {
    id?: boolean
    eventId?: boolean
    subEventName?: boolean
    subEventDescription?: boolean
    subEventBudget?: boolean
    subEventDate?: boolean
    subEventStartTime?: boolean
    subEventEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "subEventName" | "subEventDescription" | "subEventBudget" | "subEventDate" | "subEventStartTime" | "subEventEndTime" | "createdAt" | "updatedAt", ExtArgs["result"]["subEvent"]>
  export type SubEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    subEventTask?: boolean | SubEvent$subEventTaskArgs<ExtArgs>
    subEventVendors?: boolean | SubEvent$subEventVendorsArgs<ExtArgs>
    _count?: boolean | SubEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type SubEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $SubEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubEvent"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      subEventTask: Prisma.$SubEventTaskPayload<ExtArgs>[]
      subEventVendors: Prisma.$SubEventVendorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      subEventName: string
      subEventDescription: string
      subEventBudget: Prisma.Decimal
      subEventDate: Date
      subEventStartTime: Date
      subEventEndTime: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subEvent"]>
    composites: {}
  }

  type SubEventGetPayload<S extends boolean | null | undefined | SubEventDefaultArgs> = $Result.GetResult<Prisma.$SubEventPayload, S>

  type SubEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubEventCountAggregateInputType | true
    }

  export interface SubEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubEvent'], meta: { name: 'SubEvent' } }
    /**
     * Find zero or one SubEvent that matches the filter.
     * @param {SubEventFindUniqueArgs} args - Arguments to find a SubEvent
     * @example
     * // Get one SubEvent
     * const subEvent = await prisma.subEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubEventFindUniqueArgs>(args: SelectSubset<T, SubEventFindUniqueArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SubEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubEventFindUniqueOrThrowArgs} args - Arguments to find a SubEvent
     * @example
     * // Get one SubEvent
     * const subEvent = await prisma.subEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SubEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SubEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventFindFirstArgs} args - Arguments to find a SubEvent
     * @example
     * // Get one SubEvent
     * const subEvent = await prisma.subEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubEventFindFirstArgs>(args?: SelectSubset<T, SubEventFindFirstArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SubEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventFindFirstOrThrowArgs} args - Arguments to find a SubEvent
     * @example
     * // Get one SubEvent
     * const subEvent = await prisma.subEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SubEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SubEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubEvents
     * const subEvents = await prisma.subEvent.findMany()
     * 
     * // Get first 10 SubEvents
     * const subEvents = await prisma.subEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subEventWithIdOnly = await prisma.subEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubEventFindManyArgs>(args?: SelectSubset<T, SubEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SubEvent.
     * @param {SubEventCreateArgs} args - Arguments to create a SubEvent.
     * @example
     * // Create one SubEvent
     * const SubEvent = await prisma.subEvent.create({
     *   data: {
     *     // ... data to create a SubEvent
     *   }
     * })
     * 
     */
    create<T extends SubEventCreateArgs>(args: SelectSubset<T, SubEventCreateArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SubEvents.
     * @param {SubEventCreateManyArgs} args - Arguments to create many SubEvents.
     * @example
     * // Create many SubEvents
     * const subEvent = await prisma.subEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubEventCreateManyArgs>(args?: SelectSubset<T, SubEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubEvents and returns the data saved in the database.
     * @param {SubEventCreateManyAndReturnArgs} args - Arguments to create many SubEvents.
     * @example
     * // Create many SubEvents
     * const subEvent = await prisma.subEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubEvents and only return the `id`
     * const subEventWithIdOnly = await prisma.subEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SubEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SubEvent.
     * @param {SubEventDeleteArgs} args - Arguments to delete one SubEvent.
     * @example
     * // Delete one SubEvent
     * const SubEvent = await prisma.subEvent.delete({
     *   where: {
     *     // ... filter to delete one SubEvent
     *   }
     * })
     * 
     */
    delete<T extends SubEventDeleteArgs>(args: SelectSubset<T, SubEventDeleteArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SubEvent.
     * @param {SubEventUpdateArgs} args - Arguments to update one SubEvent.
     * @example
     * // Update one SubEvent
     * const subEvent = await prisma.subEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubEventUpdateArgs>(args: SelectSubset<T, SubEventUpdateArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SubEvents.
     * @param {SubEventDeleteManyArgs} args - Arguments to filter SubEvents to delete.
     * @example
     * // Delete a few SubEvents
     * const { count } = await prisma.subEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubEventDeleteManyArgs>(args?: SelectSubset<T, SubEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubEvents
     * const subEvent = await prisma.subEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubEventUpdateManyArgs>(args: SelectSubset<T, SubEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEvents and returns the data updated in the database.
     * @param {SubEventUpdateManyAndReturnArgs} args - Arguments to update many SubEvents.
     * @example
     * // Update many SubEvents
     * const subEvent = await prisma.subEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubEvents and only return the `id`
     * const subEventWithIdOnly = await prisma.subEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SubEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SubEvent.
     * @param {SubEventUpsertArgs} args - Arguments to update or create a SubEvent.
     * @example
     * // Update or create a SubEvent
     * const subEvent = await prisma.subEvent.upsert({
     *   create: {
     *     // ... data to create a SubEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubEvent we want to update
     *   }
     * })
     */
    upsert<T extends SubEventUpsertArgs>(args: SelectSubset<T, SubEventUpsertArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SubEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventCountArgs} args - Arguments to filter SubEvents to count.
     * @example
     * // Count the number of SubEvents
     * const count = await prisma.subEvent.count({
     *   where: {
     *     // ... the filter for the SubEvents we want to count
     *   }
     * })
    **/
    count<T extends SubEventCountArgs>(
      args?: Subset<T, SubEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubEventAggregateArgs>(args: Subset<T, SubEventAggregateArgs>): Prisma.PrismaPromise<GetSubEventAggregateType<T>>

    /**
     * Group by SubEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubEventGroupByArgs['orderBy'] }
        : { orderBy?: SubEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubEvent model
   */
  readonly fields: SubEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    subEventTask<T extends SubEvent$subEventTaskArgs<ExtArgs> = {}>(args?: Subset<T, SubEvent$subEventTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    subEventVendors<T extends SubEvent$subEventVendorsArgs<ExtArgs> = {}>(args?: Subset<T, SubEvent$subEventVendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubEvent model
   */ 
  interface SubEventFieldRefs {
    readonly id: FieldRef<"SubEvent", 'String'>
    readonly eventId: FieldRef<"SubEvent", 'String'>
    readonly subEventName: FieldRef<"SubEvent", 'String'>
    readonly subEventDescription: FieldRef<"SubEvent", 'String'>
    readonly subEventBudget: FieldRef<"SubEvent", 'Decimal'>
    readonly subEventDate: FieldRef<"SubEvent", 'DateTime'>
    readonly subEventStartTime: FieldRef<"SubEvent", 'DateTime'>
    readonly subEventEndTime: FieldRef<"SubEvent", 'DateTime'>
    readonly createdAt: FieldRef<"SubEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"SubEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubEvent findUnique
   */
  export type SubEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter, which SubEvent to fetch.
     */
    where: SubEventWhereUniqueInput
  }

  /**
   * SubEvent findUniqueOrThrow
   */
  export type SubEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter, which SubEvent to fetch.
     */
    where: SubEventWhereUniqueInput
  }

  /**
   * SubEvent findFirst
   */
  export type SubEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter, which SubEvent to fetch.
     */
    where?: SubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEvents to fetch.
     */
    orderBy?: SubEventOrderByWithRelationInput | SubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEvents.
     */
    cursor?: SubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEvents.
     */
    distinct?: SubEventScalarFieldEnum | SubEventScalarFieldEnum[]
  }

  /**
   * SubEvent findFirstOrThrow
   */
  export type SubEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter, which SubEvent to fetch.
     */
    where?: SubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEvents to fetch.
     */
    orderBy?: SubEventOrderByWithRelationInput | SubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEvents.
     */
    cursor?: SubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEvents.
     */
    distinct?: SubEventScalarFieldEnum | SubEventScalarFieldEnum[]
  }

  /**
   * SubEvent findMany
   */
  export type SubEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter, which SubEvents to fetch.
     */
    where?: SubEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEvents to fetch.
     */
    orderBy?: SubEventOrderByWithRelationInput | SubEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubEvents.
     */
    cursor?: SubEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEvents.
     */
    skip?: number
    distinct?: SubEventScalarFieldEnum | SubEventScalarFieldEnum[]
  }

  /**
   * SubEvent create
   */
  export type SubEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SubEvent.
     */
    data: XOR<SubEventCreateInput, SubEventUncheckedCreateInput>
  }

  /**
   * SubEvent createMany
   */
  export type SubEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubEvents.
     */
    data: SubEventCreateManyInput | SubEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubEvent createManyAndReturn
   */
  export type SubEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * The data used to create many SubEvents.
     */
    data: SubEventCreateManyInput | SubEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEvent update
   */
  export type SubEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SubEvent.
     */
    data: XOR<SubEventUpdateInput, SubEventUncheckedUpdateInput>
    /**
     * Choose, which SubEvent to update.
     */
    where: SubEventWhereUniqueInput
  }

  /**
   * SubEvent updateMany
   */
  export type SubEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubEvents.
     */
    data: XOR<SubEventUpdateManyMutationInput, SubEventUncheckedUpdateManyInput>
    /**
     * Filter which SubEvents to update
     */
    where?: SubEventWhereInput
  }

  /**
   * SubEvent updateManyAndReturn
   */
  export type SubEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * The data used to update SubEvents.
     */
    data: XOR<SubEventUpdateManyMutationInput, SubEventUncheckedUpdateManyInput>
    /**
     * Filter which SubEvents to update
     */
    where?: SubEventWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEvent upsert
   */
  export type SubEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SubEvent to update in case it exists.
     */
    where: SubEventWhereUniqueInput
    /**
     * In case the SubEvent found by the `where` argument doesn't exist, create a new SubEvent with this data.
     */
    create: XOR<SubEventCreateInput, SubEventUncheckedCreateInput>
    /**
     * In case the SubEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubEventUpdateInput, SubEventUncheckedUpdateInput>
  }

  /**
   * SubEvent delete
   */
  export type SubEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
    /**
     * Filter which SubEvent to delete.
     */
    where: SubEventWhereUniqueInput
  }

  /**
   * SubEvent deleteMany
   */
  export type SubEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEvents to delete
     */
    where?: SubEventWhereInput
  }

  /**
   * SubEvent.subEventTask
   */
  export type SubEvent$subEventTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    where?: SubEventTaskWhereInput
    orderBy?: SubEventTaskOrderByWithRelationInput | SubEventTaskOrderByWithRelationInput[]
    cursor?: SubEventTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubEventTaskScalarFieldEnum | SubEventTaskScalarFieldEnum[]
  }

  /**
   * SubEvent.subEventVendors
   */
  export type SubEvent$subEventVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    where?: SubEventVendorsWhereInput
    orderBy?: SubEventVendorsOrderByWithRelationInput | SubEventVendorsOrderByWithRelationInput[]
    cursor?: SubEventVendorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubEventVendorsScalarFieldEnum | SubEventVendorsScalarFieldEnum[]
  }

  /**
   * SubEvent without action
   */
  export type SubEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEvent
     */
    select?: SubEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEvent
     */
    omit?: SubEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventInclude<ExtArgs> | null
  }


  /**
   * Model SubEventVendors
   */

  export type AggregateSubEventVendors = {
    _count: SubEventVendorsCountAggregateOutputType | null
    _min: SubEventVendorsMinAggregateOutputType | null
    _max: SubEventVendorsMaxAggregateOutputType | null
  }

  export type SubEventVendorsMinAggregateOutputType = {
    id: string | null
    subEventId: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type SubEventVendorsMaxAggregateOutputType = {
    id: string | null
    subEventId: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type SubEventVendorsCountAggregateOutputType = {
    id: number
    subEventId: number
    userId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type SubEventVendorsMinAggregateInputType = {
    id?: true
    subEventId?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type SubEventVendorsMaxAggregateInputType = {
    id?: true
    subEventId?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type SubEventVendorsCountAggregateInputType = {
    id?: true
    subEventId?: true
    userId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type SubEventVendorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEventVendors to aggregate.
     */
    where?: SubEventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventVendors to fetch.
     */
    orderBy?: SubEventVendorsOrderByWithRelationInput | SubEventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubEventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubEventVendors
    **/
    _count?: true | SubEventVendorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubEventVendorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubEventVendorsMaxAggregateInputType
  }

  export type GetSubEventVendorsAggregateType<T extends SubEventVendorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubEventVendors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubEventVendors[P]>
      : GetScalarType<T[P], AggregateSubEventVendors[P]>
  }




  export type SubEventVendorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventVendorsWhereInput
    orderBy?: SubEventVendorsOrderByWithAggregationInput | SubEventVendorsOrderByWithAggregationInput[]
    by: SubEventVendorsScalarFieldEnum[] | SubEventVendorsScalarFieldEnum
    having?: SubEventVendorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubEventVendorsCountAggregateInputType | true
    _min?: SubEventVendorsMinAggregateInputType
    _max?: SubEventVendorsMaxAggregateInputType
  }

  export type SubEventVendorsGroupByOutputType = {
    id: string
    subEventId: string
    userId: string
    serviceId: string
    createdAt: Date
    _count: SubEventVendorsCountAggregateOutputType | null
    _min: SubEventVendorsMinAggregateOutputType | null
    _max: SubEventVendorsMaxAggregateOutputType | null
  }

  type GetSubEventVendorsGroupByPayload<T extends SubEventVendorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubEventVendorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubEventVendorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubEventVendorsGroupByOutputType[P]>
            : GetScalarType<T[P], SubEventVendorsGroupByOutputType[P]>
        }
      >
    >


  export type SubEventVendorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subEventId?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventVendors"]>

  export type SubEventVendorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subEventId?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventVendors"]>

  export type SubEventVendorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subEventId?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventVendors"]>

  export type SubEventVendorsSelectScalar = {
    id?: boolean
    subEventId?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type SubEventVendorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subEventId" | "userId" | "serviceId" | "createdAt", ExtArgs["result"]["subEventVendors"]>
  export type SubEventVendorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }
  export type SubEventVendorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }
  export type SubEventVendorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }

  export type $SubEventVendorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubEventVendors"
    objects: {
      subEvent: Prisma.$SubEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subEventId: string
      userId: string
      serviceId: string
      createdAt: Date
    }, ExtArgs["result"]["subEventVendors"]>
    composites: {}
  }

  type SubEventVendorsGetPayload<S extends boolean | null | undefined | SubEventVendorsDefaultArgs> = $Result.GetResult<Prisma.$SubEventVendorsPayload, S>

  type SubEventVendorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubEventVendorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubEventVendorsCountAggregateInputType | true
    }

  export interface SubEventVendorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubEventVendors'], meta: { name: 'SubEventVendors' } }
    /**
     * Find zero or one SubEventVendors that matches the filter.
     * @param {SubEventVendorsFindUniqueArgs} args - Arguments to find a SubEventVendors
     * @example
     * // Get one SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubEventVendorsFindUniqueArgs>(args: SelectSubset<T, SubEventVendorsFindUniqueArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SubEventVendors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubEventVendorsFindUniqueOrThrowArgs} args - Arguments to find a SubEventVendors
     * @example
     * // Get one SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubEventVendorsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubEventVendorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SubEventVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsFindFirstArgs} args - Arguments to find a SubEventVendors
     * @example
     * // Get one SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubEventVendorsFindFirstArgs>(args?: SelectSubset<T, SubEventVendorsFindFirstArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SubEventVendors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsFindFirstOrThrowArgs} args - Arguments to find a SubEventVendors
     * @example
     * // Get one SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubEventVendorsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubEventVendorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SubEventVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findMany()
     * 
     * // Get first 10 SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subEventVendorsWithIdOnly = await prisma.subEventVendors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubEventVendorsFindManyArgs>(args?: SelectSubset<T, SubEventVendorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SubEventVendors.
     * @param {SubEventVendorsCreateArgs} args - Arguments to create a SubEventVendors.
     * @example
     * // Create one SubEventVendors
     * const SubEventVendors = await prisma.subEventVendors.create({
     *   data: {
     *     // ... data to create a SubEventVendors
     *   }
     * })
     * 
     */
    create<T extends SubEventVendorsCreateArgs>(args: SelectSubset<T, SubEventVendorsCreateArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SubEventVendors.
     * @param {SubEventVendorsCreateManyArgs} args - Arguments to create many SubEventVendors.
     * @example
     * // Create many SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubEventVendorsCreateManyArgs>(args?: SelectSubset<T, SubEventVendorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubEventVendors and returns the data saved in the database.
     * @param {SubEventVendorsCreateManyAndReturnArgs} args - Arguments to create many SubEventVendors.
     * @example
     * // Create many SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubEventVendors and only return the `id`
     * const subEventVendorsWithIdOnly = await prisma.subEventVendors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubEventVendorsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubEventVendorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SubEventVendors.
     * @param {SubEventVendorsDeleteArgs} args - Arguments to delete one SubEventVendors.
     * @example
     * // Delete one SubEventVendors
     * const SubEventVendors = await prisma.subEventVendors.delete({
     *   where: {
     *     // ... filter to delete one SubEventVendors
     *   }
     * })
     * 
     */
    delete<T extends SubEventVendorsDeleteArgs>(args: SelectSubset<T, SubEventVendorsDeleteArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SubEventVendors.
     * @param {SubEventVendorsUpdateArgs} args - Arguments to update one SubEventVendors.
     * @example
     * // Update one SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubEventVendorsUpdateArgs>(args: SelectSubset<T, SubEventVendorsUpdateArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SubEventVendors.
     * @param {SubEventVendorsDeleteManyArgs} args - Arguments to filter SubEventVendors to delete.
     * @example
     * // Delete a few SubEventVendors
     * const { count } = await prisma.subEventVendors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubEventVendorsDeleteManyArgs>(args?: SelectSubset<T, SubEventVendorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubEventVendorsUpdateManyArgs>(args: SelectSubset<T, SubEventVendorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEventVendors and returns the data updated in the database.
     * @param {SubEventVendorsUpdateManyAndReturnArgs} args - Arguments to update many SubEventVendors.
     * @example
     * // Update many SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubEventVendors and only return the `id`
     * const subEventVendorsWithIdOnly = await prisma.subEventVendors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubEventVendorsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubEventVendorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SubEventVendors.
     * @param {SubEventVendorsUpsertArgs} args - Arguments to update or create a SubEventVendors.
     * @example
     * // Update or create a SubEventVendors
     * const subEventVendors = await prisma.subEventVendors.upsert({
     *   create: {
     *     // ... data to create a SubEventVendors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubEventVendors we want to update
     *   }
     * })
     */
    upsert<T extends SubEventVendorsUpsertArgs>(args: SelectSubset<T, SubEventVendorsUpsertArgs<ExtArgs>>): Prisma__SubEventVendorsClient<$Result.GetResult<Prisma.$SubEventVendorsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SubEventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsCountArgs} args - Arguments to filter SubEventVendors to count.
     * @example
     * // Count the number of SubEventVendors
     * const count = await prisma.subEventVendors.count({
     *   where: {
     *     // ... the filter for the SubEventVendors we want to count
     *   }
     * })
    **/
    count<T extends SubEventVendorsCountArgs>(
      args?: Subset<T, SubEventVendorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubEventVendorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubEventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubEventVendorsAggregateArgs>(args: Subset<T, SubEventVendorsAggregateArgs>): Prisma.PrismaPromise<GetSubEventVendorsAggregateType<T>>

    /**
     * Group by SubEventVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventVendorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubEventVendorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubEventVendorsGroupByArgs['orderBy'] }
        : { orderBy?: SubEventVendorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubEventVendorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubEventVendorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubEventVendors model
   */
  readonly fields: SubEventVendorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubEventVendors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubEventVendorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subEvent<T extends SubEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubEventDefaultArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubEventVendors model
   */ 
  interface SubEventVendorsFieldRefs {
    readonly id: FieldRef<"SubEventVendors", 'String'>
    readonly subEventId: FieldRef<"SubEventVendors", 'String'>
    readonly userId: FieldRef<"SubEventVendors", 'String'>
    readonly serviceId: FieldRef<"SubEventVendors", 'String'>
    readonly createdAt: FieldRef<"SubEventVendors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubEventVendors findUnique
   */
  export type SubEventVendorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which SubEventVendors to fetch.
     */
    where: SubEventVendorsWhereUniqueInput
  }

  /**
   * SubEventVendors findUniqueOrThrow
   */
  export type SubEventVendorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which SubEventVendors to fetch.
     */
    where: SubEventVendorsWhereUniqueInput
  }

  /**
   * SubEventVendors findFirst
   */
  export type SubEventVendorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which SubEventVendors to fetch.
     */
    where?: SubEventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventVendors to fetch.
     */
    orderBy?: SubEventVendorsOrderByWithRelationInput | SubEventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEventVendors.
     */
    cursor?: SubEventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEventVendors.
     */
    distinct?: SubEventVendorsScalarFieldEnum | SubEventVendorsScalarFieldEnum[]
  }

  /**
   * SubEventVendors findFirstOrThrow
   */
  export type SubEventVendorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which SubEventVendors to fetch.
     */
    where?: SubEventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventVendors to fetch.
     */
    orderBy?: SubEventVendorsOrderByWithRelationInput | SubEventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEventVendors.
     */
    cursor?: SubEventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEventVendors.
     */
    distinct?: SubEventVendorsScalarFieldEnum | SubEventVendorsScalarFieldEnum[]
  }

  /**
   * SubEventVendors findMany
   */
  export type SubEventVendorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter, which SubEventVendors to fetch.
     */
    where?: SubEventVendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventVendors to fetch.
     */
    orderBy?: SubEventVendorsOrderByWithRelationInput | SubEventVendorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubEventVendors.
     */
    cursor?: SubEventVendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventVendors.
     */
    skip?: number
    distinct?: SubEventVendorsScalarFieldEnum | SubEventVendorsScalarFieldEnum[]
  }

  /**
   * SubEventVendors create
   */
  export type SubEventVendorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * The data needed to create a SubEventVendors.
     */
    data: XOR<SubEventVendorsCreateInput, SubEventVendorsUncheckedCreateInput>
  }

  /**
   * SubEventVendors createMany
   */
  export type SubEventVendorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubEventVendors.
     */
    data: SubEventVendorsCreateManyInput | SubEventVendorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubEventVendors createManyAndReturn
   */
  export type SubEventVendorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * The data used to create many SubEventVendors.
     */
    data: SubEventVendorsCreateManyInput | SubEventVendorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEventVendors update
   */
  export type SubEventVendorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * The data needed to update a SubEventVendors.
     */
    data: XOR<SubEventVendorsUpdateInput, SubEventVendorsUncheckedUpdateInput>
    /**
     * Choose, which SubEventVendors to update.
     */
    where: SubEventVendorsWhereUniqueInput
  }

  /**
   * SubEventVendors updateMany
   */
  export type SubEventVendorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubEventVendors.
     */
    data: XOR<SubEventVendorsUpdateManyMutationInput, SubEventVendorsUncheckedUpdateManyInput>
    /**
     * Filter which SubEventVendors to update
     */
    where?: SubEventVendorsWhereInput
  }

  /**
   * SubEventVendors updateManyAndReturn
   */
  export type SubEventVendorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * The data used to update SubEventVendors.
     */
    data: XOR<SubEventVendorsUpdateManyMutationInput, SubEventVendorsUncheckedUpdateManyInput>
    /**
     * Filter which SubEventVendors to update
     */
    where?: SubEventVendorsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEventVendors upsert
   */
  export type SubEventVendorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * The filter to search for the SubEventVendors to update in case it exists.
     */
    where: SubEventVendorsWhereUniqueInput
    /**
     * In case the SubEventVendors found by the `where` argument doesn't exist, create a new SubEventVendors with this data.
     */
    create: XOR<SubEventVendorsCreateInput, SubEventVendorsUncheckedCreateInput>
    /**
     * In case the SubEventVendors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubEventVendorsUpdateInput, SubEventVendorsUncheckedUpdateInput>
  }

  /**
   * SubEventVendors delete
   */
  export type SubEventVendorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
    /**
     * Filter which SubEventVendors to delete.
     */
    where: SubEventVendorsWhereUniqueInput
  }

  /**
   * SubEventVendors deleteMany
   */
  export type SubEventVendorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEventVendors to delete
     */
    where?: SubEventVendorsWhereInput
  }

  /**
   * SubEventVendors without action
   */
  export type SubEventVendorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventVendors
     */
    select?: SubEventVendorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventVendors
     */
    omit?: SubEventVendorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventVendorsInclude<ExtArgs> | null
  }


  /**
   * Model SubEventTask
   */

  export type AggregateSubEventTask = {
    _count: SubEventTaskCountAggregateOutputType | null
    _min: SubEventTaskMinAggregateOutputType | null
    _max: SubEventTaskMaxAggregateOutputType | null
  }

  export type SubEventTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subEventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubEventTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subEventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubEventTaskCountAggregateOutputType = {
    id: number
    userId: number
    subEventId: number
    items: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubEventTaskMinAggregateInputType = {
    id?: true
    userId?: true
    subEventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubEventTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    subEventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubEventTaskCountAggregateInputType = {
    id?: true
    userId?: true
    subEventId?: true
    items?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubEventTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEventTask to aggregate.
     */
    where?: SubEventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventTasks to fetch.
     */
    orderBy?: SubEventTaskOrderByWithRelationInput | SubEventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubEventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubEventTasks
    **/
    _count?: true | SubEventTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubEventTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubEventTaskMaxAggregateInputType
  }

  export type GetSubEventTaskAggregateType<T extends SubEventTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSubEventTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubEventTask[P]>
      : GetScalarType<T[P], AggregateSubEventTask[P]>
  }




  export type SubEventTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubEventTaskWhereInput
    orderBy?: SubEventTaskOrderByWithAggregationInput | SubEventTaskOrderByWithAggregationInput[]
    by: SubEventTaskScalarFieldEnum[] | SubEventTaskScalarFieldEnum
    having?: SubEventTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubEventTaskCountAggregateInputType | true
    _min?: SubEventTaskMinAggregateInputType
    _max?: SubEventTaskMaxAggregateInputType
  }

  export type SubEventTaskGroupByOutputType = {
    id: string
    userId: string
    subEventId: string
    items: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SubEventTaskCountAggregateOutputType | null
    _min: SubEventTaskMinAggregateOutputType | null
    _max: SubEventTaskMaxAggregateOutputType | null
  }

  type GetSubEventTaskGroupByPayload<T extends SubEventTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubEventTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubEventTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubEventTaskGroupByOutputType[P]>
            : GetScalarType<T[P], SubEventTaskGroupByOutputType[P]>
        }
      >
    >


  export type SubEventTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subEventId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventTask"]>

  export type SubEventTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subEventId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventTask"]>

  export type SubEventTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subEventId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subEventTask"]>

  export type SubEventTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    subEventId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubEventTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subEventId" | "items" | "createdAt" | "updatedAt", ExtArgs["result"]["subEventTask"]>
  export type SubEventTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }
  export type SubEventTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }
  export type SubEventTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subEvent?: boolean | SubEventDefaultArgs<ExtArgs>
  }

  export type $SubEventTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubEventTask"
    objects: {
      subEvent: Prisma.$SubEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subEventId: string
      items: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subEventTask"]>
    composites: {}
  }

  type SubEventTaskGetPayload<S extends boolean | null | undefined | SubEventTaskDefaultArgs> = $Result.GetResult<Prisma.$SubEventTaskPayload, S>

  type SubEventTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubEventTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubEventTaskCountAggregateInputType | true
    }

  export interface SubEventTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubEventTask'], meta: { name: 'SubEventTask' } }
    /**
     * Find zero or one SubEventTask that matches the filter.
     * @param {SubEventTaskFindUniqueArgs} args - Arguments to find a SubEventTask
     * @example
     * // Get one SubEventTask
     * const subEventTask = await prisma.subEventTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubEventTaskFindUniqueArgs>(args: SelectSubset<T, SubEventTaskFindUniqueArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SubEventTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubEventTaskFindUniqueOrThrowArgs} args - Arguments to find a SubEventTask
     * @example
     * // Get one SubEventTask
     * const subEventTask = await prisma.subEventTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubEventTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SubEventTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SubEventTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskFindFirstArgs} args - Arguments to find a SubEventTask
     * @example
     * // Get one SubEventTask
     * const subEventTask = await prisma.subEventTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubEventTaskFindFirstArgs>(args?: SelectSubset<T, SubEventTaskFindFirstArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SubEventTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskFindFirstOrThrowArgs} args - Arguments to find a SubEventTask
     * @example
     * // Get one SubEventTask
     * const subEventTask = await prisma.subEventTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubEventTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SubEventTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SubEventTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubEventTasks
     * const subEventTasks = await prisma.subEventTask.findMany()
     * 
     * // Get first 10 SubEventTasks
     * const subEventTasks = await prisma.subEventTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subEventTaskWithIdOnly = await prisma.subEventTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubEventTaskFindManyArgs>(args?: SelectSubset<T, SubEventTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SubEventTask.
     * @param {SubEventTaskCreateArgs} args - Arguments to create a SubEventTask.
     * @example
     * // Create one SubEventTask
     * const SubEventTask = await prisma.subEventTask.create({
     *   data: {
     *     // ... data to create a SubEventTask
     *   }
     * })
     * 
     */
    create<T extends SubEventTaskCreateArgs>(args: SelectSubset<T, SubEventTaskCreateArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SubEventTasks.
     * @param {SubEventTaskCreateManyArgs} args - Arguments to create many SubEventTasks.
     * @example
     * // Create many SubEventTasks
     * const subEventTask = await prisma.subEventTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubEventTaskCreateManyArgs>(args?: SelectSubset<T, SubEventTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubEventTasks and returns the data saved in the database.
     * @param {SubEventTaskCreateManyAndReturnArgs} args - Arguments to create many SubEventTasks.
     * @example
     * // Create many SubEventTasks
     * const subEventTask = await prisma.subEventTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubEventTasks and only return the `id`
     * const subEventTaskWithIdOnly = await prisma.subEventTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubEventTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, SubEventTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SubEventTask.
     * @param {SubEventTaskDeleteArgs} args - Arguments to delete one SubEventTask.
     * @example
     * // Delete one SubEventTask
     * const SubEventTask = await prisma.subEventTask.delete({
     *   where: {
     *     // ... filter to delete one SubEventTask
     *   }
     * })
     * 
     */
    delete<T extends SubEventTaskDeleteArgs>(args: SelectSubset<T, SubEventTaskDeleteArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SubEventTask.
     * @param {SubEventTaskUpdateArgs} args - Arguments to update one SubEventTask.
     * @example
     * // Update one SubEventTask
     * const subEventTask = await prisma.subEventTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubEventTaskUpdateArgs>(args: SelectSubset<T, SubEventTaskUpdateArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SubEventTasks.
     * @param {SubEventTaskDeleteManyArgs} args - Arguments to filter SubEventTasks to delete.
     * @example
     * // Delete a few SubEventTasks
     * const { count } = await prisma.subEventTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubEventTaskDeleteManyArgs>(args?: SelectSubset<T, SubEventTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEventTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubEventTasks
     * const subEventTask = await prisma.subEventTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubEventTaskUpdateManyArgs>(args: SelectSubset<T, SubEventTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubEventTasks and returns the data updated in the database.
     * @param {SubEventTaskUpdateManyAndReturnArgs} args - Arguments to update many SubEventTasks.
     * @example
     * // Update many SubEventTasks
     * const subEventTask = await prisma.subEventTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubEventTasks and only return the `id`
     * const subEventTaskWithIdOnly = await prisma.subEventTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubEventTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, SubEventTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SubEventTask.
     * @param {SubEventTaskUpsertArgs} args - Arguments to update or create a SubEventTask.
     * @example
     * // Update or create a SubEventTask
     * const subEventTask = await prisma.subEventTask.upsert({
     *   create: {
     *     // ... data to create a SubEventTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubEventTask we want to update
     *   }
     * })
     */
    upsert<T extends SubEventTaskUpsertArgs>(args: SelectSubset<T, SubEventTaskUpsertArgs<ExtArgs>>): Prisma__SubEventTaskClient<$Result.GetResult<Prisma.$SubEventTaskPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SubEventTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskCountArgs} args - Arguments to filter SubEventTasks to count.
     * @example
     * // Count the number of SubEventTasks
     * const count = await prisma.subEventTask.count({
     *   where: {
     *     // ... the filter for the SubEventTasks we want to count
     *   }
     * })
    **/
    count<T extends SubEventTaskCountArgs>(
      args?: Subset<T, SubEventTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubEventTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubEventTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubEventTaskAggregateArgs>(args: Subset<T, SubEventTaskAggregateArgs>): Prisma.PrismaPromise<GetSubEventTaskAggregateType<T>>

    /**
     * Group by SubEventTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubEventTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubEventTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubEventTaskGroupByArgs['orderBy'] }
        : { orderBy?: SubEventTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubEventTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubEventTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubEventTask model
   */
  readonly fields: SubEventTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubEventTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubEventTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subEvent<T extends SubEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubEventDefaultArgs<ExtArgs>>): Prisma__SubEventClient<$Result.GetResult<Prisma.$SubEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubEventTask model
   */ 
  interface SubEventTaskFieldRefs {
    readonly id: FieldRef<"SubEventTask", 'String'>
    readonly userId: FieldRef<"SubEventTask", 'String'>
    readonly subEventId: FieldRef<"SubEventTask", 'String'>
    readonly items: FieldRef<"SubEventTask", 'Json'>
    readonly createdAt: FieldRef<"SubEventTask", 'DateTime'>
    readonly updatedAt: FieldRef<"SubEventTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubEventTask findUnique
   */
  export type SubEventTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter, which SubEventTask to fetch.
     */
    where: SubEventTaskWhereUniqueInput
  }

  /**
   * SubEventTask findUniqueOrThrow
   */
  export type SubEventTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter, which SubEventTask to fetch.
     */
    where: SubEventTaskWhereUniqueInput
  }

  /**
   * SubEventTask findFirst
   */
  export type SubEventTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter, which SubEventTask to fetch.
     */
    where?: SubEventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventTasks to fetch.
     */
    orderBy?: SubEventTaskOrderByWithRelationInput | SubEventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEventTasks.
     */
    cursor?: SubEventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEventTasks.
     */
    distinct?: SubEventTaskScalarFieldEnum | SubEventTaskScalarFieldEnum[]
  }

  /**
   * SubEventTask findFirstOrThrow
   */
  export type SubEventTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter, which SubEventTask to fetch.
     */
    where?: SubEventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventTasks to fetch.
     */
    orderBy?: SubEventTaskOrderByWithRelationInput | SubEventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubEventTasks.
     */
    cursor?: SubEventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubEventTasks.
     */
    distinct?: SubEventTaskScalarFieldEnum | SubEventTaskScalarFieldEnum[]
  }

  /**
   * SubEventTask findMany
   */
  export type SubEventTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter, which SubEventTasks to fetch.
     */
    where?: SubEventTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubEventTasks to fetch.
     */
    orderBy?: SubEventTaskOrderByWithRelationInput | SubEventTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubEventTasks.
     */
    cursor?: SubEventTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubEventTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubEventTasks.
     */
    skip?: number
    distinct?: SubEventTaskScalarFieldEnum | SubEventTaskScalarFieldEnum[]
  }

  /**
   * SubEventTask create
   */
  export type SubEventTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a SubEventTask.
     */
    data: XOR<SubEventTaskCreateInput, SubEventTaskUncheckedCreateInput>
  }

  /**
   * SubEventTask createMany
   */
  export type SubEventTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubEventTasks.
     */
    data: SubEventTaskCreateManyInput | SubEventTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubEventTask createManyAndReturn
   */
  export type SubEventTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * The data used to create many SubEventTasks.
     */
    data: SubEventTaskCreateManyInput | SubEventTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEventTask update
   */
  export type SubEventTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a SubEventTask.
     */
    data: XOR<SubEventTaskUpdateInput, SubEventTaskUncheckedUpdateInput>
    /**
     * Choose, which SubEventTask to update.
     */
    where: SubEventTaskWhereUniqueInput
  }

  /**
   * SubEventTask updateMany
   */
  export type SubEventTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubEventTasks.
     */
    data: XOR<SubEventTaskUpdateManyMutationInput, SubEventTaskUncheckedUpdateManyInput>
    /**
     * Filter which SubEventTasks to update
     */
    where?: SubEventTaskWhereInput
  }

  /**
   * SubEventTask updateManyAndReturn
   */
  export type SubEventTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * The data used to update SubEventTasks.
     */
    data: XOR<SubEventTaskUpdateManyMutationInput, SubEventTaskUncheckedUpdateManyInput>
    /**
     * Filter which SubEventTasks to update
     */
    where?: SubEventTaskWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubEventTask upsert
   */
  export type SubEventTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the SubEventTask to update in case it exists.
     */
    where: SubEventTaskWhereUniqueInput
    /**
     * In case the SubEventTask found by the `where` argument doesn't exist, create a new SubEventTask with this data.
     */
    create: XOR<SubEventTaskCreateInput, SubEventTaskUncheckedCreateInput>
    /**
     * In case the SubEventTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubEventTaskUpdateInput, SubEventTaskUncheckedUpdateInput>
  }

  /**
   * SubEventTask delete
   */
  export type SubEventTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
    /**
     * Filter which SubEventTask to delete.
     */
    where: SubEventTaskWhereUniqueInput
  }

  /**
   * SubEventTask deleteMany
   */
  export type SubEventTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubEventTasks to delete
     */
    where?: SubEventTaskWhereInput
  }

  /**
   * SubEventTask without action
   */
  export type SubEventTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubEventTask
     */
    select?: SubEventTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubEventTask
     */
    omit?: SubEventTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubEventTaskInclude<ExtArgs> | null
  }


  /**
   * Model OrderDetails
   */

  export type AggregateOrderDetails = {
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  export type OrderDetailsAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderDetailsSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderDetailsMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    userId: string | null
    templateId: string | null
  }

  export type OrderDetailsMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    userId: string | null
    templateId: string | null
  }

  export type OrderDetailsCountAggregateOutputType = {
    id: number
    orderId: number
    amount: number
    currency: number
    status: number
    razorpayResponse: number
    createdAt: number
    userId: number
    templateId: number
    _all: number
  }


  export type OrderDetailsAvgAggregateInputType = {
    amount?: true
  }

  export type OrderDetailsSumAggregateInputType = {
    amount?: true
  }

  export type OrderDetailsMinAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    userId?: true
    templateId?: true
  }

  export type OrderDetailsMaxAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    userId?: true
    templateId?: true
  }

  export type OrderDetailsCountAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    status?: true
    razorpayResponse?: true
    createdAt?: true
    userId?: true
    templateId?: true
    _all?: true
  }

  export type OrderDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetails to aggregate.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderDetails
    **/
    _count?: true | OrderDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type GetOrderDetailsAggregateType<T extends OrderDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDetails[P]>
      : GetScalarType<T[P], AggregateOrderDetails[P]>
  }




  export type OrderDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithAggregationInput | OrderDetailsOrderByWithAggregationInput[]
    by: OrderDetailsScalarFieldEnum[] | OrderDetailsScalarFieldEnum
    having?: OrderDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDetailsCountAggregateInputType | true
    _avg?: OrderDetailsAvgAggregateInputType
    _sum?: OrderDetailsSumAggregateInputType
    _min?: OrderDetailsMinAggregateInputType
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type OrderDetailsGroupByOutputType = {
    id: string
    orderId: string
    amount: number
    currency: string
    status: string
    razorpayResponse: JsonValue
    createdAt: Date
    userId: string
    templateId: string | null
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  type GetOrderDetailsGroupByPayload<T extends OrderDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OrderDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    razorpayResponse?: boolean
    createdAt?: boolean
    userId?: boolean
    templateId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetails"]>

  export type OrderDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    razorpayResponse?: boolean
    createdAt?: boolean
    userId?: boolean
    templateId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetails"]>

  export type OrderDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    razorpayResponse?: boolean
    createdAt?: boolean
    userId?: boolean
    templateId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetails"]>

  export type OrderDetailsSelectScalar = {
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    razorpayResponse?: boolean
    createdAt?: boolean
    userId?: boolean
    templateId?: boolean
  }

  export type OrderDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "amount" | "currency" | "status" | "razorpayResponse" | "createdAt" | "userId" | "templateId", ExtArgs["result"]["orderDetails"]>
  export type OrderDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }
  export type OrderDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }
  export type OrderDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | OrderDetails$InvitationTemplateArgs<ExtArgs>
  }

  export type $OrderDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderDetails"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      InvitationTemplate: Prisma.$InvitationTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      amount: number
      currency: string
      status: string
      razorpayResponse: Prisma.JsonValue
      createdAt: Date
      userId: string
      templateId: string | null
    }, ExtArgs["result"]["orderDetails"]>
    composites: {}
  }

  type OrderDetailsGetPayload<S extends boolean | null | undefined | OrderDetailsDefaultArgs> = $Result.GetResult<Prisma.$OrderDetailsPayload, S>

  type OrderDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderDetailsCountAggregateInputType | true
    }

  export interface OrderDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderDetails'], meta: { name: 'OrderDetails' } }
    /**
     * Find zero or one OrderDetails that matches the filter.
     * @param {OrderDetailsFindUniqueArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderDetailsFindUniqueArgs>(args: SelectSubset<T, OrderDetailsFindUniqueArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrderDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderDetailsFindUniqueOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindFirstArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderDetailsFindFirstArgs>(args?: SelectSubset<T, OrderDetailsFindFirstArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrderDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindFirstOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany()
     * 
     * // Get first 10 OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderDetailsWithIdOnly = await prisma.orderDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderDetailsFindManyArgs>(args?: SelectSubset<T, OrderDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrderDetails.
     * @param {OrderDetailsCreateArgs} args - Arguments to create a OrderDetails.
     * @example
     * // Create one OrderDetails
     * const OrderDetails = await prisma.orderDetails.create({
     *   data: {
     *     // ... data to create a OrderDetails
     *   }
     * })
     * 
     */
    create<T extends OrderDetailsCreateArgs>(args: SelectSubset<T, OrderDetailsCreateArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrderDetails.
     * @param {OrderDetailsCreateManyArgs} args - Arguments to create many OrderDetails.
     * @example
     * // Create many OrderDetails
     * const orderDetails = await prisma.orderDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderDetailsCreateManyArgs>(args?: SelectSubset<T, OrderDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderDetails and returns the data saved in the database.
     * @param {OrderDetailsCreateManyAndReturnArgs} args - Arguments to create many OrderDetails.
     * @example
     * // Create many OrderDetails
     * const orderDetails = await prisma.orderDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderDetails and only return the `id`
     * const orderDetailsWithIdOnly = await prisma.orderDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a OrderDetails.
     * @param {OrderDetailsDeleteArgs} args - Arguments to delete one OrderDetails.
     * @example
     * // Delete one OrderDetails
     * const OrderDetails = await prisma.orderDetails.delete({
     *   where: {
     *     // ... filter to delete one OrderDetails
     *   }
     * })
     * 
     */
    delete<T extends OrderDetailsDeleteArgs>(args: SelectSubset<T, OrderDetailsDeleteArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrderDetails.
     * @param {OrderDetailsUpdateArgs} args - Arguments to update one OrderDetails.
     * @example
     * // Update one OrderDetails
     * const orderDetails = await prisma.orderDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderDetailsUpdateArgs>(args: SelectSubset<T, OrderDetailsUpdateArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrderDetails.
     * @param {OrderDetailsDeleteManyArgs} args - Arguments to filter OrderDetails to delete.
     * @example
     * // Delete a few OrderDetails
     * const { count } = await prisma.orderDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDetailsDeleteManyArgs>(args?: SelectSubset<T, OrderDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDetails
     * const orderDetails = await prisma.orderDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderDetailsUpdateManyArgs>(args: SelectSubset<T, OrderDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetails and returns the data updated in the database.
     * @param {OrderDetailsUpdateManyAndReturnArgs} args - Arguments to update many OrderDetails.
     * @example
     * // Update many OrderDetails
     * const orderDetails = await prisma.orderDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderDetails and only return the `id`
     * const orderDetailsWithIdOnly = await prisma.orderDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one OrderDetails.
     * @param {OrderDetailsUpsertArgs} args - Arguments to update or create a OrderDetails.
     * @example
     * // Update or create a OrderDetails
     * const orderDetails = await prisma.orderDetails.upsert({
     *   create: {
     *     // ... data to create a OrderDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDetails we want to update
     *   }
     * })
     */
    upsert<T extends OrderDetailsUpsertArgs>(args: SelectSubset<T, OrderDetailsUpsertArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsCountArgs} args - Arguments to filter OrderDetails to count.
     * @example
     * // Count the number of OrderDetails
     * const count = await prisma.orderDetails.count({
     *   where: {
     *     // ... the filter for the OrderDetails we want to count
     *   }
     * })
    **/
    count<T extends OrderDetailsCountArgs>(
      args?: Subset<T, OrderDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDetailsAggregateArgs>(args: Subset<T, OrderDetailsAggregateArgs>): Prisma.PrismaPromise<GetOrderDetailsAggregateType<T>>

    /**
     * Group by OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OrderDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderDetails model
   */
  readonly fields: OrderDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    InvitationTemplate<T extends OrderDetails$InvitationTemplateArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetails$InvitationTemplateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderDetails model
   */ 
  interface OrderDetailsFieldRefs {
    readonly id: FieldRef<"OrderDetails", 'String'>
    readonly orderId: FieldRef<"OrderDetails", 'String'>
    readonly amount: FieldRef<"OrderDetails", 'Float'>
    readonly currency: FieldRef<"OrderDetails", 'String'>
    readonly status: FieldRef<"OrderDetails", 'String'>
    readonly razorpayResponse: FieldRef<"OrderDetails", 'Json'>
    readonly createdAt: FieldRef<"OrderDetails", 'DateTime'>
    readonly userId: FieldRef<"OrderDetails", 'String'>
    readonly templateId: FieldRef<"OrderDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderDetails findUnique
   */
  export type OrderDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails findUniqueOrThrow
   */
  export type OrderDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails findFirst
   */
  export type OrderDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails findFirstOrThrow
   */
  export type OrderDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails findMany
   */
  export type OrderDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails create
   */
  export type OrderDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderDetails.
     */
    data: XOR<OrderDetailsCreateInput, OrderDetailsUncheckedCreateInput>
  }

  /**
   * OrderDetails createMany
   */
  export type OrderDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderDetails.
     */
    data: OrderDetailsCreateManyInput | OrderDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderDetails createManyAndReturn
   */
  export type OrderDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many OrderDetails.
     */
    data: OrderDetailsCreateManyInput | OrderDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderDetails update
   */
  export type OrderDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderDetails.
     */
    data: XOR<OrderDetailsUpdateInput, OrderDetailsUncheckedUpdateInput>
    /**
     * Choose, which OrderDetails to update.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails updateMany
   */
  export type OrderDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderDetails.
     */
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OrderDetails to update
     */
    where?: OrderDetailsWhereInput
  }

  /**
   * OrderDetails updateManyAndReturn
   */
  export type OrderDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * The data used to update OrderDetails.
     */
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OrderDetails to update
     */
    where?: OrderDetailsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderDetails upsert
   */
  export type OrderDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderDetails to update in case it exists.
     */
    where: OrderDetailsWhereUniqueInput
    /**
     * In case the OrderDetails found by the `where` argument doesn't exist, create a new OrderDetails with this data.
     */
    create: XOR<OrderDetailsCreateInput, OrderDetailsUncheckedCreateInput>
    /**
     * In case the OrderDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDetailsUpdateInput, OrderDetailsUncheckedUpdateInput>
  }

  /**
   * OrderDetails delete
   */
  export type OrderDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter which OrderDetails to delete.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails deleteMany
   */
  export type OrderDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetails to delete
     */
    where?: OrderDetailsWhereInput
  }

  /**
   * OrderDetails.InvitationTemplate
   */
  export type OrderDetails$InvitationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    where?: InvitationTemplateWhereInput
  }

  /**
   * OrderDetails without action
   */
  export type OrderDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
  }


  /**
   * Model PaymentDetails
   */

  export type AggregatePaymentDetails = {
    _count: PaymentDetailsCountAggregateOutputType | null
    _min: PaymentDetailsMinAggregateOutputType | null
    _max: PaymentDetailsMaxAggregateOutputType | null
  }

  export type PaymentDetailsMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    status: string | null
    purchasedAt: Date | null
    userId: string | null
    templateId: string | null
  }

  export type PaymentDetailsMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    status: string | null
    purchasedAt: Date | null
    userId: string | null
    templateId: string | null
  }

  export type PaymentDetailsCountAggregateOutputType = {
    id: number
    orderId: number
    paymentId: number
    razorpayResponse: number
    status: number
    purchasedAt: number
    userId: number
    templateId: number
    _all: number
  }


  export type PaymentDetailsMinAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    status?: true
    purchasedAt?: true
    userId?: true
    templateId?: true
  }

  export type PaymentDetailsMaxAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    status?: true
    purchasedAt?: true
    userId?: true
    templateId?: true
  }

  export type PaymentDetailsCountAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    razorpayResponse?: true
    status?: true
    purchasedAt?: true
    userId?: true
    templateId?: true
    _all?: true
  }

  export type PaymentDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetails to aggregate.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentDetails
    **/
    _count?: true | PaymentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentDetailsMaxAggregateInputType
  }

  export type GetPaymentDetailsAggregateType<T extends PaymentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentDetails[P]>
      : GetScalarType<T[P], AggregatePaymentDetails[P]>
  }




  export type PaymentDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailsWhereInput
    orderBy?: PaymentDetailsOrderByWithAggregationInput | PaymentDetailsOrderByWithAggregationInput[]
    by: PaymentDetailsScalarFieldEnum[] | PaymentDetailsScalarFieldEnum
    having?: PaymentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentDetailsCountAggregateInputType | true
    _min?: PaymentDetailsMinAggregateInputType
    _max?: PaymentDetailsMaxAggregateInputType
  }

  export type PaymentDetailsGroupByOutputType = {
    id: string
    orderId: string
    paymentId: string | null
    razorpayResponse: JsonValue
    status: string
    purchasedAt: Date | null
    userId: string
    templateId: string | null
    _count: PaymentDetailsCountAggregateOutputType | null
    _min: PaymentDetailsMinAggregateOutputType | null
    _max: PaymentDetailsMaxAggregateOutputType | null
  }

  type GetPaymentDetailsGroupByPayload<T extends PaymentDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    razorpayResponse?: boolean
    status?: boolean
    purchasedAt?: boolean
    userId?: boolean
    templateId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetails"]>

  export type PaymentDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    razorpayResponse?: boolean
    status?: boolean
    purchasedAt?: boolean
    userId?: boolean
    templateId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetails"]>

  export type PaymentDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    razorpayResponse?: boolean
    status?: boolean
    purchasedAt?: boolean
    userId?: boolean
    templateId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetails"]>

  export type PaymentDetailsSelectScalar = {
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    razorpayResponse?: boolean
    status?: boolean
    purchasedAt?: boolean
    userId?: boolean
    templateId?: boolean
  }

  export type PaymentDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "paymentId" | "razorpayResponse" | "status" | "purchasedAt" | "userId" | "templateId", ExtArgs["result"]["paymentDetails"]>
  export type PaymentDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }
  export type PaymentDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }
  export type PaymentDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    InvitationTemplate?: boolean | PaymentDetails$InvitationTemplateArgs<ExtArgs>
  }

  export type $PaymentDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentDetails"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      InvitationTemplate: Prisma.$InvitationTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      paymentId: string | null
      razorpayResponse: Prisma.JsonValue
      status: string
      purchasedAt: Date | null
      userId: string
      templateId: string | null
    }, ExtArgs["result"]["paymentDetails"]>
    composites: {}
  }

  type PaymentDetailsGetPayload<S extends boolean | null | undefined | PaymentDetailsDefaultArgs> = $Result.GetResult<Prisma.$PaymentDetailsPayload, S>

  type PaymentDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentDetailsCountAggregateInputType | true
    }

  export interface PaymentDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentDetails'], meta: { name: 'PaymentDetails' } }
    /**
     * Find zero or one PaymentDetails that matches the filter.
     * @param {PaymentDetailsFindUniqueArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentDetailsFindUniqueArgs>(args: SelectSubset<T, PaymentDetailsFindUniqueArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PaymentDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentDetailsFindUniqueOrThrowArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindFirstArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentDetailsFindFirstArgs>(args?: SelectSubset<T, PaymentDetailsFindFirstArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PaymentDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindFirstOrThrowArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findMany()
     * 
     * // Get first 10 PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentDetailsWithIdOnly = await prisma.paymentDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentDetailsFindManyArgs>(args?: SelectSubset<T, PaymentDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PaymentDetails.
     * @param {PaymentDetailsCreateArgs} args - Arguments to create a PaymentDetails.
     * @example
     * // Create one PaymentDetails
     * const PaymentDetails = await prisma.paymentDetails.create({
     *   data: {
     *     // ... data to create a PaymentDetails
     *   }
     * })
     * 
     */
    create<T extends PaymentDetailsCreateArgs>(args: SelectSubset<T, PaymentDetailsCreateArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PaymentDetails.
     * @param {PaymentDetailsCreateManyArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentDetailsCreateManyArgs>(args?: SelectSubset<T, PaymentDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentDetails and returns the data saved in the database.
     * @param {PaymentDetailsCreateManyAndReturnArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentDetails and only return the `id`
     * const paymentDetailsWithIdOnly = await prisma.paymentDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PaymentDetails.
     * @param {PaymentDetailsDeleteArgs} args - Arguments to delete one PaymentDetails.
     * @example
     * // Delete one PaymentDetails
     * const PaymentDetails = await prisma.paymentDetails.delete({
     *   where: {
     *     // ... filter to delete one PaymentDetails
     *   }
     * })
     * 
     */
    delete<T extends PaymentDetailsDeleteArgs>(args: SelectSubset<T, PaymentDetailsDeleteArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PaymentDetails.
     * @param {PaymentDetailsUpdateArgs} args - Arguments to update one PaymentDetails.
     * @example
     * // Update one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentDetailsUpdateArgs>(args: SelectSubset<T, PaymentDetailsUpdateArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PaymentDetails.
     * @param {PaymentDetailsDeleteManyArgs} args - Arguments to filter PaymentDetails to delete.
     * @example
     * // Delete a few PaymentDetails
     * const { count } = await prisma.paymentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDetailsDeleteManyArgs>(args?: SelectSubset<T, PaymentDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentDetailsUpdateManyArgs>(args: SelectSubset<T, PaymentDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentDetails and returns the data updated in the database.
     * @param {PaymentDetailsUpdateManyAndReturnArgs} args - Arguments to update many PaymentDetails.
     * @example
     * // Update many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentDetails and only return the `id`
     * const paymentDetailsWithIdOnly = await prisma.paymentDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PaymentDetails.
     * @param {PaymentDetailsUpsertArgs} args - Arguments to update or create a PaymentDetails.
     * @example
     * // Update or create a PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.upsert({
     *   create: {
     *     // ... data to create a PaymentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentDetails we want to update
     *   }
     * })
     */
    upsert<T extends PaymentDetailsUpsertArgs>(args: SelectSubset<T, PaymentDetailsUpsertArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsCountArgs} args - Arguments to filter PaymentDetails to count.
     * @example
     * // Count the number of PaymentDetails
     * const count = await prisma.paymentDetails.count({
     *   where: {
     *     // ... the filter for the PaymentDetails we want to count
     *   }
     * })
    **/
    count<T extends PaymentDetailsCountArgs>(
      args?: Subset<T, PaymentDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentDetailsAggregateArgs>(args: Subset<T, PaymentDetailsAggregateArgs>): Prisma.PrismaPromise<GetPaymentDetailsAggregateType<T>>

    /**
     * Group by PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentDetails model
   */
  readonly fields: PaymentDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    InvitationTemplate<T extends PaymentDetails$InvitationTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDetails$InvitationTemplateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentDetails model
   */ 
  interface PaymentDetailsFieldRefs {
    readonly id: FieldRef<"PaymentDetails", 'String'>
    readonly orderId: FieldRef<"PaymentDetails", 'String'>
    readonly paymentId: FieldRef<"PaymentDetails", 'String'>
    readonly razorpayResponse: FieldRef<"PaymentDetails", 'Json'>
    readonly status: FieldRef<"PaymentDetails", 'String'>
    readonly purchasedAt: FieldRef<"PaymentDetails", 'DateTime'>
    readonly userId: FieldRef<"PaymentDetails", 'String'>
    readonly templateId: FieldRef<"PaymentDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentDetails findUnique
   */
  export type PaymentDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails findUniqueOrThrow
   */
  export type PaymentDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails findFirst
   */
  export type PaymentDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails findFirstOrThrow
   */
  export type PaymentDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails findMany
   */
  export type PaymentDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails create
   */
  export type PaymentDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentDetails.
     */
    data: XOR<PaymentDetailsCreateInput, PaymentDetailsUncheckedCreateInput>
  }

  /**
   * PaymentDetails createMany
   */
  export type PaymentDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailsCreateManyInput | PaymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentDetails createManyAndReturn
   */
  export type PaymentDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailsCreateManyInput | PaymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentDetails update
   */
  export type PaymentDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentDetails.
     */
    data: XOR<PaymentDetailsUpdateInput, PaymentDetailsUncheckedUpdateInput>
    /**
     * Choose, which PaymentDetails to update.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails updateMany
   */
  export type PaymentDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailsWhereInput
  }

  /**
   * PaymentDetails updateManyAndReturn
   */
  export type PaymentDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentDetails upsert
   */
  export type PaymentDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentDetails to update in case it exists.
     */
    where: PaymentDetailsWhereUniqueInput
    /**
     * In case the PaymentDetails found by the `where` argument doesn't exist, create a new PaymentDetails with this data.
     */
    create: XOR<PaymentDetailsCreateInput, PaymentDetailsUncheckedCreateInput>
    /**
     * In case the PaymentDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentDetailsUpdateInput, PaymentDetailsUncheckedUpdateInput>
  }

  /**
   * PaymentDetails delete
   */
  export type PaymentDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter which PaymentDetails to delete.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails deleteMany
   */
  export type PaymentDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetails to delete
     */
    where?: PaymentDetailsWhereInput
  }

  /**
   * PaymentDetails.InvitationTemplate
   */
  export type PaymentDetails$InvitationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    where?: InvitationTemplateWhereInput
  }

  /**
   * PaymentDetails without action
   */
  export type PaymentDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    review_id: string | null
    vendor_id: string | null
    id: string | null
    rating: number | null
    review_text: string | null
    created_at: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    review_id: string | null
    vendor_id: string | null
    id: string | null
    rating: number | null
    review_text: string | null
    created_at: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    review_id: number
    vendor_id: number
    id: number
    rating: number
    review_text: number
    created_at: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    review_id?: true
    vendor_id?: true
    id?: true
    rating?: true
    review_text?: true
    created_at?: true
  }

  export type ReviewMaxAggregateInputType = {
    review_id?: true
    vendor_id?: true
    id?: true
    rating?: true
    review_text?: true
    created_at?: true
  }

  export type ReviewCountAggregateInputType = {
    review_id?: true
    vendor_id?: true
    id?: true
    rating?: true
    review_text?: true
    created_at?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    review_id: string
    vendor_id: string
    id: string
    rating: number
    review_text: string
    created_at: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    vendor_id?: boolean
    id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    vendor_id?: boolean
    id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    vendor_id?: boolean
    id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    review_id?: boolean
    vendor_id?: boolean
    id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"review_id" | "vendor_id" | "id" | "rating" | "review_text" | "created_at", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      review_id: string
      vendor_id: string
      id: string
      rating: number
      review_text: string
      created_at: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.findMany({ select: { review_id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.createManyAndReturn({
     *   select: { review_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.updateManyAndReturn({
     *   select: { review_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly review_id: FieldRef<"Review", 'String'>
    readonly vendor_id: FieldRef<"Review", 'String'>
    readonly id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly review_text: FieldRef<"Review", 'String'>
    readonly created_at: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model EventSchedule
   */

  export type AggregateEventSchedule = {
    _count: EventScheduleCountAggregateOutputType | null
    _min: EventScheduleMinAggregateOutputType | null
    _max: EventScheduleMaxAggregateOutputType | null
  }

  export type EventScheduleMinAggregateOutputType = {
    event_id: string | null
    vendor_id: string | null
    media_id: string | null
    event_name: string | null
    event_start_date: Date | null
    event_end_date: Date | null
    event_location: string | null
    description: string | null
    created_at: Date | null
  }

  export type EventScheduleMaxAggregateOutputType = {
    event_id: string | null
    vendor_id: string | null
    media_id: string | null
    event_name: string | null
    event_start_date: Date | null
    event_end_date: Date | null
    event_location: string | null
    description: string | null
    created_at: Date | null
  }

  export type EventScheduleCountAggregateOutputType = {
    event_id: number
    vendor_id: number
    media_id: number
    event_name: number
    event_start_date: number
    event_end_date: number
    event_location: number
    description: number
    created_at: number
    _all: number
  }


  export type EventScheduleMinAggregateInputType = {
    event_id?: true
    vendor_id?: true
    media_id?: true
    event_name?: true
    event_start_date?: true
    event_end_date?: true
    event_location?: true
    description?: true
    created_at?: true
  }

  export type EventScheduleMaxAggregateInputType = {
    event_id?: true
    vendor_id?: true
    media_id?: true
    event_name?: true
    event_start_date?: true
    event_end_date?: true
    event_location?: true
    description?: true
    created_at?: true
  }

  export type EventScheduleCountAggregateInputType = {
    event_id?: true
    vendor_id?: true
    media_id?: true
    event_name?: true
    event_start_date?: true
    event_end_date?: true
    event_location?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type EventScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSchedule to aggregate.
     */
    where?: EventScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSchedules to fetch.
     */
    orderBy?: EventScheduleOrderByWithRelationInput | EventScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventSchedules
    **/
    _count?: true | EventScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventScheduleMaxAggregateInputType
  }

  export type GetEventScheduleAggregateType<T extends EventScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateEventSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventSchedule[P]>
      : GetScalarType<T[P], AggregateEventSchedule[P]>
  }




  export type EventScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventScheduleWhereInput
    orderBy?: EventScheduleOrderByWithAggregationInput | EventScheduleOrderByWithAggregationInput[]
    by: EventScheduleScalarFieldEnum[] | EventScheduleScalarFieldEnum
    having?: EventScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventScheduleCountAggregateInputType | true
    _min?: EventScheduleMinAggregateInputType
    _max?: EventScheduleMaxAggregateInputType
  }

  export type EventScheduleGroupByOutputType = {
    event_id: string
    vendor_id: string
    media_id: string
    event_name: string
    event_start_date: Date
    event_end_date: Date
    event_location: string
    description: string
    created_at: Date
    _count: EventScheduleCountAggregateOutputType | null
    _min: EventScheduleMinAggregateOutputType | null
    _max: EventScheduleMaxAggregateOutputType | null
  }

  type GetEventScheduleGroupByPayload<T extends EventScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], EventScheduleGroupByOutputType[P]>
        }
      >
    >


  export type EventScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    vendor_id?: boolean
    media_id?: boolean
    event_name?: boolean
    event_start_date?: boolean
    event_end_date?: boolean
    event_location?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["eventSchedule"]>

  export type EventScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    vendor_id?: boolean
    media_id?: boolean
    event_name?: boolean
    event_start_date?: boolean
    event_end_date?: boolean
    event_location?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["eventSchedule"]>

  export type EventScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    vendor_id?: boolean
    media_id?: boolean
    event_name?: boolean
    event_start_date?: boolean
    event_end_date?: boolean
    event_location?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["eventSchedule"]>

  export type EventScheduleSelectScalar = {
    event_id?: boolean
    vendor_id?: boolean
    media_id?: boolean
    event_name?: boolean
    event_start_date?: boolean
    event_end_date?: boolean
    event_location?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type EventScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_id" | "vendor_id" | "media_id" | "event_name" | "event_start_date" | "event_end_date" | "event_location" | "description" | "created_at", ExtArgs["result"]["eventSchedule"]>

  export type $EventSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventSchedule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      event_id: string
      vendor_id: string
      media_id: string
      event_name: string
      event_start_date: Date
      event_end_date: Date
      event_location: string
      description: string
      created_at: Date
    }, ExtArgs["result"]["eventSchedule"]>
    composites: {}
  }

  type EventScheduleGetPayload<S extends boolean | null | undefined | EventScheduleDefaultArgs> = $Result.GetResult<Prisma.$EventSchedulePayload, S>

  type EventScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventScheduleCountAggregateInputType | true
    }

  export interface EventScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventSchedule'], meta: { name: 'EventSchedule' } }
    /**
     * Find zero or one EventSchedule that matches the filter.
     * @param {EventScheduleFindUniqueArgs} args - Arguments to find a EventSchedule
     * @example
     * // Get one EventSchedule
     * const eventSchedule = await prisma.eventSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventScheduleFindUniqueArgs>(args: SelectSubset<T, EventScheduleFindUniqueArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EventSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventScheduleFindUniqueOrThrowArgs} args - Arguments to find a EventSchedule
     * @example
     * // Get one EventSchedule
     * const eventSchedule = await prisma.eventSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, EventScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EventSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleFindFirstArgs} args - Arguments to find a EventSchedule
     * @example
     * // Get one EventSchedule
     * const eventSchedule = await prisma.eventSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventScheduleFindFirstArgs>(args?: SelectSubset<T, EventScheduleFindFirstArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EventSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleFindFirstOrThrowArgs} args - Arguments to find a EventSchedule
     * @example
     * // Get one EventSchedule
     * const eventSchedule = await prisma.eventSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, EventScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EventSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventSchedules
     * const eventSchedules = await prisma.eventSchedule.findMany()
     * 
     * // Get first 10 EventSchedules
     * const eventSchedules = await prisma.eventSchedule.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const eventScheduleWithEvent_idOnly = await prisma.eventSchedule.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends EventScheduleFindManyArgs>(args?: SelectSubset<T, EventScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EventSchedule.
     * @param {EventScheduleCreateArgs} args - Arguments to create a EventSchedule.
     * @example
     * // Create one EventSchedule
     * const EventSchedule = await prisma.eventSchedule.create({
     *   data: {
     *     // ... data to create a EventSchedule
     *   }
     * })
     * 
     */
    create<T extends EventScheduleCreateArgs>(args: SelectSubset<T, EventScheduleCreateArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EventSchedules.
     * @param {EventScheduleCreateManyArgs} args - Arguments to create many EventSchedules.
     * @example
     * // Create many EventSchedules
     * const eventSchedule = await prisma.eventSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventScheduleCreateManyArgs>(args?: SelectSubset<T, EventScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventSchedules and returns the data saved in the database.
     * @param {EventScheduleCreateManyAndReturnArgs} args - Arguments to create many EventSchedules.
     * @example
     * // Create many EventSchedules
     * const eventSchedule = await prisma.eventSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventSchedules and only return the `event_id`
     * const eventScheduleWithEvent_idOnly = await prisma.eventSchedule.createManyAndReturn({
     *   select: { event_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, EventScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EventSchedule.
     * @param {EventScheduleDeleteArgs} args - Arguments to delete one EventSchedule.
     * @example
     * // Delete one EventSchedule
     * const EventSchedule = await prisma.eventSchedule.delete({
     *   where: {
     *     // ... filter to delete one EventSchedule
     *   }
     * })
     * 
     */
    delete<T extends EventScheduleDeleteArgs>(args: SelectSubset<T, EventScheduleDeleteArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EventSchedule.
     * @param {EventScheduleUpdateArgs} args - Arguments to update one EventSchedule.
     * @example
     * // Update one EventSchedule
     * const eventSchedule = await prisma.eventSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventScheduleUpdateArgs>(args: SelectSubset<T, EventScheduleUpdateArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EventSchedules.
     * @param {EventScheduleDeleteManyArgs} args - Arguments to filter EventSchedules to delete.
     * @example
     * // Delete a few EventSchedules
     * const { count } = await prisma.eventSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventScheduleDeleteManyArgs>(args?: SelectSubset<T, EventScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventSchedules
     * const eventSchedule = await prisma.eventSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventScheduleUpdateManyArgs>(args: SelectSubset<T, EventScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventSchedules and returns the data updated in the database.
     * @param {EventScheduleUpdateManyAndReturnArgs} args - Arguments to update many EventSchedules.
     * @example
     * // Update many EventSchedules
     * const eventSchedule = await prisma.eventSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventSchedules and only return the `event_id`
     * const eventScheduleWithEvent_idOnly = await prisma.eventSchedule.updateManyAndReturn({
     *   select: { event_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, EventScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EventSchedule.
     * @param {EventScheduleUpsertArgs} args - Arguments to update or create a EventSchedule.
     * @example
     * // Update or create a EventSchedule
     * const eventSchedule = await prisma.eventSchedule.upsert({
     *   create: {
     *     // ... data to create a EventSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventSchedule we want to update
     *   }
     * })
     */
    upsert<T extends EventScheduleUpsertArgs>(args: SelectSubset<T, EventScheduleUpsertArgs<ExtArgs>>): Prisma__EventScheduleClient<$Result.GetResult<Prisma.$EventSchedulePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EventSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleCountArgs} args - Arguments to filter EventSchedules to count.
     * @example
     * // Count the number of EventSchedules
     * const count = await prisma.eventSchedule.count({
     *   where: {
     *     // ... the filter for the EventSchedules we want to count
     *   }
     * })
    **/
    count<T extends EventScheduleCountArgs>(
      args?: Subset<T, EventScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventScheduleAggregateArgs>(args: Subset<T, EventScheduleAggregateArgs>): Prisma.PrismaPromise<GetEventScheduleAggregateType<T>>

    /**
     * Group by EventSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventScheduleGroupByArgs['orderBy'] }
        : { orderBy?: EventScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventSchedule model
   */
  readonly fields: EventScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventSchedule model
   */ 
  interface EventScheduleFieldRefs {
    readonly event_id: FieldRef<"EventSchedule", 'String'>
    readonly vendor_id: FieldRef<"EventSchedule", 'String'>
    readonly media_id: FieldRef<"EventSchedule", 'String'>
    readonly event_name: FieldRef<"EventSchedule", 'String'>
    readonly event_start_date: FieldRef<"EventSchedule", 'DateTime'>
    readonly event_end_date: FieldRef<"EventSchedule", 'DateTime'>
    readonly event_location: FieldRef<"EventSchedule", 'String'>
    readonly description: FieldRef<"EventSchedule", 'String'>
    readonly created_at: FieldRef<"EventSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventSchedule findUnique
   */
  export type EventScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter, which EventSchedule to fetch.
     */
    where: EventScheduleWhereUniqueInput
  }

  /**
   * EventSchedule findUniqueOrThrow
   */
  export type EventScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter, which EventSchedule to fetch.
     */
    where: EventScheduleWhereUniqueInput
  }

  /**
   * EventSchedule findFirst
   */
  export type EventScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter, which EventSchedule to fetch.
     */
    where?: EventScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSchedules to fetch.
     */
    orderBy?: EventScheduleOrderByWithRelationInput | EventScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSchedules.
     */
    cursor?: EventScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSchedules.
     */
    distinct?: EventScheduleScalarFieldEnum | EventScheduleScalarFieldEnum[]
  }

  /**
   * EventSchedule findFirstOrThrow
   */
  export type EventScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter, which EventSchedule to fetch.
     */
    where?: EventScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSchedules to fetch.
     */
    orderBy?: EventScheduleOrderByWithRelationInput | EventScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSchedules.
     */
    cursor?: EventScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSchedules.
     */
    distinct?: EventScheduleScalarFieldEnum | EventScheduleScalarFieldEnum[]
  }

  /**
   * EventSchedule findMany
   */
  export type EventScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter, which EventSchedules to fetch.
     */
    where?: EventScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSchedules to fetch.
     */
    orderBy?: EventScheduleOrderByWithRelationInput | EventScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventSchedules.
     */
    cursor?: EventScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSchedules.
     */
    skip?: number
    distinct?: EventScheduleScalarFieldEnum | EventScheduleScalarFieldEnum[]
  }

  /**
   * EventSchedule create
   */
  export type EventScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * The data needed to create a EventSchedule.
     */
    data: XOR<EventScheduleCreateInput, EventScheduleUncheckedCreateInput>
  }

  /**
   * EventSchedule createMany
   */
  export type EventScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventSchedules.
     */
    data: EventScheduleCreateManyInput | EventScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventSchedule createManyAndReturn
   */
  export type EventScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many EventSchedules.
     */
    data: EventScheduleCreateManyInput | EventScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventSchedule update
   */
  export type EventScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * The data needed to update a EventSchedule.
     */
    data: XOR<EventScheduleUpdateInput, EventScheduleUncheckedUpdateInput>
    /**
     * Choose, which EventSchedule to update.
     */
    where: EventScheduleWhereUniqueInput
  }

  /**
   * EventSchedule updateMany
   */
  export type EventScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventSchedules.
     */
    data: XOR<EventScheduleUpdateManyMutationInput, EventScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EventSchedules to update
     */
    where?: EventScheduleWhereInput
  }

  /**
   * EventSchedule updateManyAndReturn
   */
  export type EventScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * The data used to update EventSchedules.
     */
    data: XOR<EventScheduleUpdateManyMutationInput, EventScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EventSchedules to update
     */
    where?: EventScheduleWhereInput
  }

  /**
   * EventSchedule upsert
   */
  export type EventScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * The filter to search for the EventSchedule to update in case it exists.
     */
    where: EventScheduleWhereUniqueInput
    /**
     * In case the EventSchedule found by the `where` argument doesn't exist, create a new EventSchedule with this data.
     */
    create: XOR<EventScheduleCreateInput, EventScheduleUncheckedCreateInput>
    /**
     * In case the EventSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventScheduleUpdateInput, EventScheduleUncheckedUpdateInput>
  }

  /**
   * EventSchedule delete
   */
  export type EventScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
    /**
     * Filter which EventSchedule to delete.
     */
    where: EventScheduleWhereUniqueInput
  }

  /**
   * EventSchedule deleteMany
   */
  export type EventScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSchedules to delete
     */
    where?: EventScheduleWhereInput
  }

  /**
   * EventSchedule without action
   */
  export type EventScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSchedule
     */
    select?: EventScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventSchedule
     */
    omit?: EventScheduleOmit<ExtArgs> | null
  }


  /**
   * Model Guest
   */

  export type AggregateGuest = {
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  export type GuestMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    status: $Enums.GuestStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    status: $Enums.GuestStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuestMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guest to aggregate.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guests
    **/
    _count?: true | GuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestMaxAggregateInputType
  }

  export type GetGuestAggregateType<T extends GuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuest[P]>
      : GetScalarType<T[P], AggregateGuest[P]>
  }




  export type GuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestWhereInput
    orderBy?: GuestOrderByWithAggregationInput | GuestOrderByWithAggregationInput[]
    by: GuestScalarFieldEnum[] | GuestScalarFieldEnum
    having?: GuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestCountAggregateInputType | true
    _min?: GuestMinAggregateInputType
    _max?: GuestMaxAggregateInputType
  }

  export type GuestGroupByOutputType = {
    id: string
    name: string
    phone: string
    status: $Enums.GuestStatus
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  type GetGuestGroupByPayload<T extends GuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuestGroupByOutputType[P]>
        }
      >
    >


  export type GuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "status" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["guest"]>
  export type GuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string
      status: $Enums.GuestStatus
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guest"]>
    composites: {}
  }

  type GuestGetPayload<S extends boolean | null | undefined | GuestDefaultArgs> = $Result.GetResult<Prisma.$GuestPayload, S>

  type GuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestCountAggregateInputType | true
    }

  export interface GuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guest'], meta: { name: 'Guest' } }
    /**
     * Find zero or one Guest that matches the filter.
     * @param {GuestFindUniqueArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestFindUniqueArgs>(args: SelectSubset<T, GuestFindUniqueArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Guest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuestFindUniqueOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Guest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestFindFirstArgs>(args?: SelectSubset<T, GuestFindFirstArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Guest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Guests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guests
     * const guests = await prisma.guest.findMany()
     * 
     * // Get first 10 Guests
     * const guests = await prisma.guest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestFindManyArgs>(args?: SelectSubset<T, GuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Guest.
     * @param {GuestCreateArgs} args - Arguments to create a Guest.
     * @example
     * // Create one Guest
     * const Guest = await prisma.guest.create({
     *   data: {
     *     // ... data to create a Guest
     *   }
     * })
     * 
     */
    create<T extends GuestCreateArgs>(args: SelectSubset<T, GuestCreateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Guests.
     * @param {GuestCreateManyArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestCreateManyArgs>(args?: SelectSubset<T, GuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guests and returns the data saved in the database.
     * @param {GuestCreateManyAndReturnArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuestCreateManyAndReturnArgs>(args?: SelectSubset<T, GuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Guest.
     * @param {GuestDeleteArgs} args - Arguments to delete one Guest.
     * @example
     * // Delete one Guest
     * const Guest = await prisma.guest.delete({
     *   where: {
     *     // ... filter to delete one Guest
     *   }
     * })
     * 
     */
    delete<T extends GuestDeleteArgs>(args: SelectSubset<T, GuestDeleteArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Guest.
     * @param {GuestUpdateArgs} args - Arguments to update one Guest.
     * @example
     * // Update one Guest
     * const guest = await prisma.guest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestUpdateArgs>(args: SelectSubset<T, GuestUpdateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Guests.
     * @param {GuestDeleteManyArgs} args - Arguments to filter Guests to delete.
     * @example
     * // Delete a few Guests
     * const { count } = await prisma.guest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestDeleteManyArgs>(args?: SelectSubset<T, GuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestUpdateManyArgs>(args: SelectSubset<T, GuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests and returns the data updated in the database.
     * @param {GuestUpdateManyAndReturnArgs} args - Arguments to update many Guests.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuestUpdateManyAndReturnArgs>(args: SelectSubset<T, GuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Guest.
     * @param {GuestUpsertArgs} args - Arguments to update or create a Guest.
     * @example
     * // Update or create a Guest
     * const guest = await prisma.guest.upsert({
     *   create: {
     *     // ... data to create a Guest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guest we want to update
     *   }
     * })
     */
    upsert<T extends GuestUpsertArgs>(args: SelectSubset<T, GuestUpsertArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestCountArgs} args - Arguments to filter Guests to count.
     * @example
     * // Count the number of Guests
     * const count = await prisma.guest.count({
     *   where: {
     *     // ... the filter for the Guests we want to count
     *   }
     * })
    **/
    count<T extends GuestCountArgs>(
      args?: Subset<T, GuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestAggregateArgs>(args: Subset<T, GuestAggregateArgs>): Prisma.PrismaPromise<GetGuestAggregateType<T>>

    /**
     * Group by Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestGroupByArgs['orderBy'] }
        : { orderBy?: GuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guest model
   */
  readonly fields: GuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guest model
   */ 
  interface GuestFieldRefs {
    readonly id: FieldRef<"Guest", 'String'>
    readonly name: FieldRef<"Guest", 'String'>
    readonly phone: FieldRef<"Guest", 'String'>
    readonly status: FieldRef<"Guest", 'GuestStatus'>
    readonly userId: FieldRef<"Guest", 'String'>
    readonly createdAt: FieldRef<"Guest", 'DateTime'>
    readonly updatedAt: FieldRef<"Guest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guest findUnique
   */
  export type GuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findUniqueOrThrow
   */
  export type GuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findFirst
   */
  export type GuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findFirstOrThrow
   */
  export type GuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findMany
   */
  export type GuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guests to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest create
   */
  export type GuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Guest.
     */
    data: XOR<GuestCreateInput, GuestUncheckedCreateInput>
  }

  /**
   * Guest createMany
   */
  export type GuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guest createManyAndReturn
   */
  export type GuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guest update
   */
  export type GuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Guest.
     */
    data: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
    /**
     * Choose, which Guest to update.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest updateMany
   */
  export type GuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
  }

  /**
   * Guest updateManyAndReturn
   */
  export type GuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guest upsert
   */
  export type GuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Guest to update in case it exists.
     */
    where: GuestWhereUniqueInput
    /**
     * In case the Guest found by the `where` argument doesn't exist, create a new Guest with this data.
     */
    create: XOR<GuestCreateInput, GuestUncheckedCreateInput>
    /**
     * In case the Guest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
  }

  /**
   * Guest delete
   */
  export type GuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter which Guest to delete.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest deleteMany
   */
  export type GuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guests to delete
     */
    where?: GuestWhereInput
  }

  /**
   * Guest without action
   */
  export type GuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
  }


  /**
   * Model InvitationTemplate
   */

  export type AggregateInvitationTemplate = {
    _count: InvitationTemplateCountAggregateOutputType | null
    _avg: InvitationTemplateAvgAggregateOutputType | null
    _sum: InvitationTemplateSumAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  export type InvitationTemplateAvgAggregateOutputType = {
    price: number | null
  }

  export type InvitationTemplateSumAggregateOutputType = {
    price: number | null
  }

  export type InvitationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    template_type: $Enums.template_category | null
    template_category: string | null
    filter: string | null
    createdAt: Date | null
  }

  export type InvitationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    template_type: $Enums.template_category | null
    template_category: string | null
    filter: string | null
    createdAt: Date | null
  }

  export type InvitationTemplateCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    price: number
    template_type: number
    template_category: number
    filter: number
    createdAt: number
    _all: number
  }


  export type InvitationTemplateAvgAggregateInputType = {
    price?: true
  }

  export type InvitationTemplateSumAggregateInputType = {
    price?: true
  }

  export type InvitationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    template_type?: true
    template_category?: true
    filter?: true
    createdAt?: true
  }

  export type InvitationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    template_type?: true
    template_category?: true
    filter?: true
    createdAt?: true
  }

  export type InvitationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    price?: true
    template_type?: true
    template_category?: true
    filter?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplate to aggregate.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationTemplates
    **/
    _count?: true | InvitationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type GetInvitationTemplateAggregateType<T extends InvitationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationTemplate[P]>
      : GetScalarType<T[P], AggregateInvitationTemplate[P]>
  }




  export type InvitationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationTemplateWhereInput
    orderBy?: InvitationTemplateOrderByWithAggregationInput | InvitationTemplateOrderByWithAggregationInput[]
    by: InvitationTemplateScalarFieldEnum[] | InvitationTemplateScalarFieldEnum
    having?: InvitationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationTemplateCountAggregateInputType | true
    _avg?: InvitationTemplateAvgAggregateInputType
    _sum?: InvitationTemplateSumAggregateInputType
    _min?: InvitationTemplateMinAggregateInputType
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type InvitationTemplateGroupByOutputType = {
    id: string
    name: string
    imageUrl: JsonValue
    price: number | null
    template_type: $Enums.template_category
    template_category: string
    filter: string | null
    createdAt: Date
    _count: InvitationTemplateCountAggregateOutputType | null
    _avg: InvitationTemplateAvgAggregateOutputType | null
    _sum: InvitationTemplateSumAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  type GetInvitationTemplateGroupByPayload<T extends InvitationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type InvitationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    template_type?: boolean
    template_category?: boolean
    filter?: boolean
    createdAt?: boolean
    paymentDetails?: boolean | InvitationTemplate$paymentDetailsArgs<ExtArgs>
    orderDetails?: boolean | InvitationTemplate$orderDetailsArgs<ExtArgs>
    _count?: boolean | InvitationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    template_type?: boolean
    template_category?: boolean
    filter?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    template_type?: boolean
    template_category?: boolean
    filter?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    price?: boolean
    template_type?: boolean
    template_category?: boolean
    filter?: boolean
    createdAt?: boolean
  }

  export type InvitationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "imageUrl" | "price" | "template_type" | "template_category" | "filter" | "createdAt", ExtArgs["result"]["invitationTemplate"]>
  export type InvitationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentDetails?: boolean | InvitationTemplate$paymentDetailsArgs<ExtArgs>
    orderDetails?: boolean | InvitationTemplate$orderDetailsArgs<ExtArgs>
    _count?: boolean | InvitationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvitationTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InvitationTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvitationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationTemplate"
    objects: {
      paymentDetails: Prisma.$PaymentDetailsPayload<ExtArgs>[]
      orderDetails: Prisma.$OrderDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      imageUrl: Prisma.JsonValue
      price: number | null
      template_type: $Enums.template_category
      template_category: string
      filter: string | null
      createdAt: Date
    }, ExtArgs["result"]["invitationTemplate"]>
    composites: {}
  }

  type InvitationTemplateGetPayload<S extends boolean | null | undefined | InvitationTemplateDefaultArgs> = $Result.GetResult<Prisma.$InvitationTemplatePayload, S>

  type InvitationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationTemplateCountAggregateInputType | true
    }

  export interface InvitationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationTemplate'], meta: { name: 'InvitationTemplate' } }
    /**
     * Find zero or one InvitationTemplate that matches the filter.
     * @param {InvitationTemplateFindUniqueArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationTemplateFindUniqueArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one InvitationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationTemplateFindUniqueOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first InvitationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationTemplateFindFirstArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first InvitationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more InvitationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany()
     * 
     * // Get first 10 InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationTemplateFindManyArgs>(args?: SelectSubset<T, InvitationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a InvitationTemplate.
     * @param {InvitationTemplateCreateArgs} args - Arguments to create a InvitationTemplate.
     * @example
     * // Create one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.create({
     *   data: {
     *     // ... data to create a InvitationTemplate
     *   }
     * })
     * 
     */
    create<T extends InvitationTemplateCreateArgs>(args: SelectSubset<T, InvitationTemplateCreateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many InvitationTemplates.
     * @param {InvitationTemplateCreateManyArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationTemplateCreateManyArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvitationTemplates and returns the data saved in the database.
     * @param {InvitationTemplateCreateManyAndReturnArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvitationTemplates and only return the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a InvitationTemplate.
     * @param {InvitationTemplateDeleteArgs} args - Arguments to delete one InvitationTemplate.
     * @example
     * // Delete one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.delete({
     *   where: {
     *     // ... filter to delete one InvitationTemplate
     *   }
     * })
     * 
     */
    delete<T extends InvitationTemplateDeleteArgs>(args: SelectSubset<T, InvitationTemplateDeleteArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one InvitationTemplate.
     * @param {InvitationTemplateUpdateArgs} args - Arguments to update one InvitationTemplate.
     * @example
     * // Update one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationTemplateUpdateArgs>(args: SelectSubset<T, InvitationTemplateUpdateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more InvitationTemplates.
     * @param {InvitationTemplateDeleteManyArgs} args - Arguments to filter InvitationTemplates to delete.
     * @example
     * // Delete a few InvitationTemplates
     * const { count } = await prisma.invitationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationTemplateDeleteManyArgs>(args?: SelectSubset<T, InvitationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationTemplateUpdateManyArgs>(args: SelectSubset<T, InvitationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationTemplates and returns the data updated in the database.
     * @param {InvitationTemplateUpdateManyAndReturnArgs} args - Arguments to update many InvitationTemplates.
     * @example
     * // Update many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvitationTemplates and only return the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one InvitationTemplate.
     * @param {InvitationTemplateUpsertArgs} args - Arguments to update or create a InvitationTemplate.
     * @example
     * // Update or create a InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.upsert({
     *   create: {
     *     // ... data to create a InvitationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends InvitationTemplateUpsertArgs>(args: SelectSubset<T, InvitationTemplateUpsertArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateCountArgs} args - Arguments to filter InvitationTemplates to count.
     * @example
     * // Count the number of InvitationTemplates
     * const count = await prisma.invitationTemplate.count({
     *   where: {
     *     // ... the filter for the InvitationTemplates we want to count
     *   }
     * })
    **/
    count<T extends InvitationTemplateCountArgs>(
      args?: Subset<T, InvitationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationTemplateAggregateArgs>(args: Subset<T, InvitationTemplateAggregateArgs>): Prisma.PrismaPromise<GetInvitationTemplateAggregateType<T>>

    /**
     * Group by InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: InvitationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationTemplate model
   */
  readonly fields: InvitationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentDetails<T extends InvitationTemplate$paymentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, InvitationTemplate$paymentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    orderDetails<T extends InvitationTemplate$orderDetailsArgs<ExtArgs> = {}>(args?: Subset<T, InvitationTemplate$orderDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationTemplate model
   */ 
  interface InvitationTemplateFieldRefs {
    readonly id: FieldRef<"InvitationTemplate", 'String'>
    readonly name: FieldRef<"InvitationTemplate", 'String'>
    readonly imageUrl: FieldRef<"InvitationTemplate", 'Json'>
    readonly price: FieldRef<"InvitationTemplate", 'Float'>
    readonly template_type: FieldRef<"InvitationTemplate", 'template_category'>
    readonly template_category: FieldRef<"InvitationTemplate", 'String'>
    readonly filter: FieldRef<"InvitationTemplate", 'String'>
    readonly createdAt: FieldRef<"InvitationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationTemplate findUnique
   */
  export type InvitationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findUniqueOrThrow
   */
  export type InvitationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findFirst
   */
  export type InvitationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findFirstOrThrow
   */
  export type InvitationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findMany
   */
  export type InvitationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplates to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate create
   */
  export type InvitationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a InvitationTemplate.
     */
    data: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
  }

  /**
   * InvitationTemplate createMany
   */
  export type InvitationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationTemplate createManyAndReturn
   */
  export type InvitationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationTemplate update
   */
  export type InvitationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a InvitationTemplate.
     */
    data: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
    /**
     * Choose, which InvitationTemplate to update.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate updateMany
   */
  export type InvitationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationTemplates.
     */
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which InvitationTemplates to update
     */
    where?: InvitationTemplateWhereInput
  }

  /**
   * InvitationTemplate updateManyAndReturn
   */
  export type InvitationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update InvitationTemplates.
     */
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which InvitationTemplates to update
     */
    where?: InvitationTemplateWhereInput
  }

  /**
   * InvitationTemplate upsert
   */
  export type InvitationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the InvitationTemplate to update in case it exists.
     */
    where: InvitationTemplateWhereUniqueInput
    /**
     * In case the InvitationTemplate found by the `where` argument doesn't exist, create a new InvitationTemplate with this data.
     */
    create: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
    /**
     * In case the InvitationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
  }

  /**
   * InvitationTemplate delete
   */
  export type InvitationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter which InvitationTemplate to delete.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate deleteMany
   */
  export type InvitationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplates to delete
     */
    where?: InvitationTemplateWhereInput
  }

  /**
   * InvitationTemplate.paymentDetails
   */
  export type InvitationTemplate$paymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    where?: PaymentDetailsWhereInput
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    cursor?: PaymentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * InvitationTemplate.orderDetails
   */
  export type InvitationTemplate$orderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    cursor?: OrderDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * InvitationTemplate without action
   */
  export type InvitationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationTemplate
     */
    omit?: InvitationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model UserDataTemplate
   */

  export type AggregateUserDataTemplate = {
    _count: UserDataTemplateCountAggregateOutputType | null
    _min: UserDataTemplateMinAggregateOutputType | null
    _max: UserDataTemplateMaxAggregateOutputType | null
  }

  export type UserDataTemplateMinAggregateOutputType = {
    userId: string | null
    template_id: string | null
    eventHeading: string | null
    eventSubheading: string | null
    brideName: string | null
    groomName: string | null
    eventDate: Date | null
    weddingTime: string | null
    weddingLocation: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDataTemplateMaxAggregateOutputType = {
    userId: string | null
    template_id: string | null
    eventHeading: string | null
    eventSubheading: string | null
    brideName: string | null
    groomName: string | null
    eventDate: Date | null
    weddingTime: string | null
    weddingLocation: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDataTemplateCountAggregateOutputType = {
    userId: number
    template_id: number
    eventHeading: number
    eventSubheading: number
    brideName: number
    groomName: number
    eventDate: number
    weddingTime: number
    weddingLocation: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserDataTemplateMinAggregateInputType = {
    userId?: true
    template_id?: true
    eventHeading?: true
    eventSubheading?: true
    brideName?: true
    groomName?: true
    eventDate?: true
    weddingTime?: true
    weddingLocation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDataTemplateMaxAggregateInputType = {
    userId?: true
    template_id?: true
    eventHeading?: true
    eventSubheading?: true
    brideName?: true
    groomName?: true
    eventDate?: true
    weddingTime?: true
    weddingLocation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDataTemplateCountAggregateInputType = {
    userId?: true
    template_id?: true
    eventHeading?: true
    eventSubheading?: true
    brideName?: true
    groomName?: true
    eventDate?: true
    weddingTime?: true
    weddingLocation?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserDataTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDataTemplate to aggregate.
     */
    where?: UserDataTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDataTemplates to fetch.
     */
    orderBy?: UserDataTemplateOrderByWithRelationInput | UserDataTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDataTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDataTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDataTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDataTemplates
    **/
    _count?: true | UserDataTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDataTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDataTemplateMaxAggregateInputType
  }

  export type GetUserDataTemplateAggregateType<T extends UserDataTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDataTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDataTemplate[P]>
      : GetScalarType<T[P], AggregateUserDataTemplate[P]>
  }




  export type UserDataTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDataTemplateWhereInput
    orderBy?: UserDataTemplateOrderByWithAggregationInput | UserDataTemplateOrderByWithAggregationInput[]
    by: UserDataTemplateScalarFieldEnum[] | UserDataTemplateScalarFieldEnum
    having?: UserDataTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDataTemplateCountAggregateInputType | true
    _min?: UserDataTemplateMinAggregateInputType
    _max?: UserDataTemplateMaxAggregateInputType
  }

  export type UserDataTemplateGroupByOutputType = {
    userId: string
    template_id: string
    eventHeading: string | null
    eventSubheading: string | null
    brideName: string | null
    groomName: string | null
    eventDate: Date
    weddingTime: string | null
    weddingLocation: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserDataTemplateCountAggregateOutputType | null
    _min: UserDataTemplateMinAggregateOutputType | null
    _max: UserDataTemplateMaxAggregateOutputType | null
  }

  type GetUserDataTemplateGroupByPayload<T extends UserDataTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDataTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDataTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDataTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], UserDataTemplateGroupByOutputType[P]>
        }
      >
    >


  export type UserDataTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    template_id?: boolean
    eventHeading?: boolean
    eventSubheading?: boolean
    brideName?: boolean
    groomName?: boolean
    eventDate?: boolean
    weddingTime?: boolean
    weddingLocation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDataTemplate"]>

  export type UserDataTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    template_id?: boolean
    eventHeading?: boolean
    eventSubheading?: boolean
    brideName?: boolean
    groomName?: boolean
    eventDate?: boolean
    weddingTime?: boolean
    weddingLocation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDataTemplate"]>

  export type UserDataTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    template_id?: boolean
    eventHeading?: boolean
    eventSubheading?: boolean
    brideName?: boolean
    groomName?: boolean
    eventDate?: boolean
    weddingTime?: boolean
    weddingLocation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDataTemplate"]>

  export type UserDataTemplateSelectScalar = {
    userId?: boolean
    template_id?: boolean
    eventHeading?: boolean
    eventSubheading?: boolean
    brideName?: boolean
    groomName?: boolean
    eventDate?: boolean
    weddingTime?: boolean
    weddingLocation?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserDataTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "template_id" | "eventHeading" | "eventSubheading" | "brideName" | "groomName" | "eventDate" | "weddingTime" | "weddingLocation" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["userDataTemplate"]>
  export type UserDataTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDataTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDataTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDataTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDataTemplate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      template_id: string
      eventHeading: string | null
      eventSubheading: string | null
      brideName: string | null
      groomName: string | null
      eventDate: Date
      weddingTime: string | null
      weddingLocation: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userDataTemplate"]>
    composites: {}
  }

  type UserDataTemplateGetPayload<S extends boolean | null | undefined | UserDataTemplateDefaultArgs> = $Result.GetResult<Prisma.$UserDataTemplatePayload, S>

  type UserDataTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDataTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDataTemplateCountAggregateInputType | true
    }

  export interface UserDataTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDataTemplate'], meta: { name: 'UserDataTemplate' } }
    /**
     * Find zero or one UserDataTemplate that matches the filter.
     * @param {UserDataTemplateFindUniqueArgs} args - Arguments to find a UserDataTemplate
     * @example
     * // Get one UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDataTemplateFindUniqueArgs>(args: SelectSubset<T, UserDataTemplateFindUniqueArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserDataTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDataTemplateFindUniqueOrThrowArgs} args - Arguments to find a UserDataTemplate
     * @example
     * // Get one UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDataTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDataTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserDataTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateFindFirstArgs} args - Arguments to find a UserDataTemplate
     * @example
     * // Get one UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDataTemplateFindFirstArgs>(args?: SelectSubset<T, UserDataTemplateFindFirstArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserDataTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateFindFirstOrThrowArgs} args - Arguments to find a UserDataTemplate
     * @example
     * // Get one UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDataTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDataTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserDataTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDataTemplates
     * const userDataTemplates = await prisma.userDataTemplate.findMany()
     * 
     * // Get first 10 UserDataTemplates
     * const userDataTemplates = await prisma.userDataTemplate.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userDataTemplateWithUserIdOnly = await prisma.userDataTemplate.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserDataTemplateFindManyArgs>(args?: SelectSubset<T, UserDataTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserDataTemplate.
     * @param {UserDataTemplateCreateArgs} args - Arguments to create a UserDataTemplate.
     * @example
     * // Create one UserDataTemplate
     * const UserDataTemplate = await prisma.userDataTemplate.create({
     *   data: {
     *     // ... data to create a UserDataTemplate
     *   }
     * })
     * 
     */
    create<T extends UserDataTemplateCreateArgs>(args: SelectSubset<T, UserDataTemplateCreateArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserDataTemplates.
     * @param {UserDataTemplateCreateManyArgs} args - Arguments to create many UserDataTemplates.
     * @example
     * // Create many UserDataTemplates
     * const userDataTemplate = await prisma.userDataTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDataTemplateCreateManyArgs>(args?: SelectSubset<T, UserDataTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDataTemplates and returns the data saved in the database.
     * @param {UserDataTemplateCreateManyAndReturnArgs} args - Arguments to create many UserDataTemplates.
     * @example
     * // Create many UserDataTemplates
     * const userDataTemplate = await prisma.userDataTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDataTemplates and only return the `userId`
     * const userDataTemplateWithUserIdOnly = await prisma.userDataTemplate.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDataTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDataTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserDataTemplate.
     * @param {UserDataTemplateDeleteArgs} args - Arguments to delete one UserDataTemplate.
     * @example
     * // Delete one UserDataTemplate
     * const UserDataTemplate = await prisma.userDataTemplate.delete({
     *   where: {
     *     // ... filter to delete one UserDataTemplate
     *   }
     * })
     * 
     */
    delete<T extends UserDataTemplateDeleteArgs>(args: SelectSubset<T, UserDataTemplateDeleteArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserDataTemplate.
     * @param {UserDataTemplateUpdateArgs} args - Arguments to update one UserDataTemplate.
     * @example
     * // Update one UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDataTemplateUpdateArgs>(args: SelectSubset<T, UserDataTemplateUpdateArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserDataTemplates.
     * @param {UserDataTemplateDeleteManyArgs} args - Arguments to filter UserDataTemplates to delete.
     * @example
     * // Delete a few UserDataTemplates
     * const { count } = await prisma.userDataTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDataTemplateDeleteManyArgs>(args?: SelectSubset<T, UserDataTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDataTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDataTemplates
     * const userDataTemplate = await prisma.userDataTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDataTemplateUpdateManyArgs>(args: SelectSubset<T, UserDataTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDataTemplates and returns the data updated in the database.
     * @param {UserDataTemplateUpdateManyAndReturnArgs} args - Arguments to update many UserDataTemplates.
     * @example
     * // Update many UserDataTemplates
     * const userDataTemplate = await prisma.userDataTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDataTemplates and only return the `userId`
     * const userDataTemplateWithUserIdOnly = await prisma.userDataTemplate.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDataTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDataTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserDataTemplate.
     * @param {UserDataTemplateUpsertArgs} args - Arguments to update or create a UserDataTemplate.
     * @example
     * // Update or create a UserDataTemplate
     * const userDataTemplate = await prisma.userDataTemplate.upsert({
     *   create: {
     *     // ... data to create a UserDataTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDataTemplate we want to update
     *   }
     * })
     */
    upsert<T extends UserDataTemplateUpsertArgs>(args: SelectSubset<T, UserDataTemplateUpsertArgs<ExtArgs>>): Prisma__UserDataTemplateClient<$Result.GetResult<Prisma.$UserDataTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserDataTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateCountArgs} args - Arguments to filter UserDataTemplates to count.
     * @example
     * // Count the number of UserDataTemplates
     * const count = await prisma.userDataTemplate.count({
     *   where: {
     *     // ... the filter for the UserDataTemplates we want to count
     *   }
     * })
    **/
    count<T extends UserDataTemplateCountArgs>(
      args?: Subset<T, UserDataTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDataTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDataTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDataTemplateAggregateArgs>(args: Subset<T, UserDataTemplateAggregateArgs>): Prisma.PrismaPromise<GetUserDataTemplateAggregateType<T>>

    /**
     * Group by UserDataTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDataTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDataTemplateGroupByArgs['orderBy'] }
        : { orderBy?: UserDataTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDataTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDataTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDataTemplate model
   */
  readonly fields: UserDataTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDataTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDataTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDataTemplate model
   */ 
  interface UserDataTemplateFieldRefs {
    readonly userId: FieldRef<"UserDataTemplate", 'String'>
    readonly template_id: FieldRef<"UserDataTemplate", 'String'>
    readonly eventHeading: FieldRef<"UserDataTemplate", 'String'>
    readonly eventSubheading: FieldRef<"UserDataTemplate", 'String'>
    readonly brideName: FieldRef<"UserDataTemplate", 'String'>
    readonly groomName: FieldRef<"UserDataTemplate", 'String'>
    readonly eventDate: FieldRef<"UserDataTemplate", 'DateTime'>
    readonly weddingTime: FieldRef<"UserDataTemplate", 'String'>
    readonly weddingLocation: FieldRef<"UserDataTemplate", 'String'>
    readonly description: FieldRef<"UserDataTemplate", 'String'>
    readonly createdAt: FieldRef<"UserDataTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"UserDataTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserDataTemplate findUnique
   */
  export type UserDataTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserDataTemplate to fetch.
     */
    where: UserDataTemplateWhereUniqueInput
  }

  /**
   * UserDataTemplate findUniqueOrThrow
   */
  export type UserDataTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserDataTemplate to fetch.
     */
    where: UserDataTemplateWhereUniqueInput
  }

  /**
   * UserDataTemplate findFirst
   */
  export type UserDataTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserDataTemplate to fetch.
     */
    where?: UserDataTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDataTemplates to fetch.
     */
    orderBy?: UserDataTemplateOrderByWithRelationInput | UserDataTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDataTemplates.
     */
    cursor?: UserDataTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDataTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDataTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDataTemplates.
     */
    distinct?: UserDataTemplateScalarFieldEnum | UserDataTemplateScalarFieldEnum[]
  }

  /**
   * UserDataTemplate findFirstOrThrow
   */
  export type UserDataTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserDataTemplate to fetch.
     */
    where?: UserDataTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDataTemplates to fetch.
     */
    orderBy?: UserDataTemplateOrderByWithRelationInput | UserDataTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDataTemplates.
     */
    cursor?: UserDataTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDataTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDataTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDataTemplates.
     */
    distinct?: UserDataTemplateScalarFieldEnum | UserDataTemplateScalarFieldEnum[]
  }

  /**
   * UserDataTemplate findMany
   */
  export type UserDataTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UserDataTemplates to fetch.
     */
    where?: UserDataTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDataTemplates to fetch.
     */
    orderBy?: UserDataTemplateOrderByWithRelationInput | UserDataTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDataTemplates.
     */
    cursor?: UserDataTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDataTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDataTemplates.
     */
    skip?: number
    distinct?: UserDataTemplateScalarFieldEnum | UserDataTemplateScalarFieldEnum[]
  }

  /**
   * UserDataTemplate create
   */
  export type UserDataTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDataTemplate.
     */
    data: XOR<UserDataTemplateCreateInput, UserDataTemplateUncheckedCreateInput>
  }

  /**
   * UserDataTemplate createMany
   */
  export type UserDataTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDataTemplates.
     */
    data: UserDataTemplateCreateManyInput | UserDataTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDataTemplate createManyAndReturn
   */
  export type UserDataTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many UserDataTemplates.
     */
    data: UserDataTemplateCreateManyInput | UserDataTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDataTemplate update
   */
  export type UserDataTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDataTemplate.
     */
    data: XOR<UserDataTemplateUpdateInput, UserDataTemplateUncheckedUpdateInput>
    /**
     * Choose, which UserDataTemplate to update.
     */
    where: UserDataTemplateWhereUniqueInput
  }

  /**
   * UserDataTemplate updateMany
   */
  export type UserDataTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDataTemplates.
     */
    data: XOR<UserDataTemplateUpdateManyMutationInput, UserDataTemplateUncheckedUpdateManyInput>
    /**
     * Filter which UserDataTemplates to update
     */
    where?: UserDataTemplateWhereInput
  }

  /**
   * UserDataTemplate updateManyAndReturn
   */
  export type UserDataTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * The data used to update UserDataTemplates.
     */
    data: XOR<UserDataTemplateUpdateManyMutationInput, UserDataTemplateUncheckedUpdateManyInput>
    /**
     * Filter which UserDataTemplates to update
     */
    where?: UserDataTemplateWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDataTemplate upsert
   */
  export type UserDataTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDataTemplate to update in case it exists.
     */
    where: UserDataTemplateWhereUniqueInput
    /**
     * In case the UserDataTemplate found by the `where` argument doesn't exist, create a new UserDataTemplate with this data.
     */
    create: XOR<UserDataTemplateCreateInput, UserDataTemplateUncheckedCreateInput>
    /**
     * In case the UserDataTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDataTemplateUpdateInput, UserDataTemplateUncheckedUpdateInput>
  }

  /**
   * UserDataTemplate delete
   */
  export type UserDataTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
    /**
     * Filter which UserDataTemplate to delete.
     */
    where: UserDataTemplateWhereUniqueInput
  }

  /**
   * UserDataTemplate deleteMany
   */
  export type UserDataTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDataTemplates to delete
     */
    where?: UserDataTemplateWhereInput
  }

  /**
   * UserDataTemplate without action
   */
  export type UserDataTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDataTemplate
     */
    select?: UserDataTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDataTemplate
     */
    omit?: UserDataTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDataTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    viewCount: number | null
    likes: number | null
  }

  export type BlogSumAggregateOutputType = {
    viewCount: number | null
    likes: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    viewCount: number | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    viewCount: number | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    tags: number
    content: number
    viewCount: number
    likes: number
    createdAt: number
    updatedAt: number
    authorId: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    viewCount?: true
    likes?: true
  }

  export type BlogSumAggregateInputType = {
    viewCount?: true
    likes?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    viewCount?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    viewCount?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    tags?: true
    content?: true
    viewCount?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    title: string
    tags: string[]
    content: string
    viewCount: number
    likes: number
    createdAt: Date
    updatedAt: Date
    authorId: string
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    tags?: boolean
    content?: boolean
    viewCount?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    comments?: boolean | Blog$commentsArgs<ExtArgs>
    likedBy?: boolean | Blog$likedByArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    tags?: boolean
    content?: boolean
    viewCount?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    tags?: boolean
    content?: boolean
    viewCount?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    tags?: boolean
    content?: boolean
    viewCount?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "tags" | "content" | "viewCount" | "likes" | "createdAt" | "updatedAt" | "authorId", ExtArgs["result"]["blog"]>
  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Blog$commentsArgs<ExtArgs>
    likedBy?: boolean | Blog$likedByArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likedBy: Prisma.$LikedBlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      tags: string[]
      content: string
      viewCount: number
      likes: number
      createdAt: Date
      updatedAt: Date
      authorId: string
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {BlogCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {BlogUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Blog$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Blog$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    likedBy<T extends Blog$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Blog$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */ 
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly tags: FieldRef<"Blog", 'String[]'>
    readonly content: FieldRef<"Blog", 'String'>
    readonly viewCount: FieldRef<"Blog", 'Int'>
    readonly likes: FieldRef<"Blog", 'Int'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
    readonly authorId: FieldRef<"Blog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog createManyAndReturn
   */
  export type BlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
  }

  /**
   * Blog updateManyAndReturn
   */
  export type BlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
  }

  /**
   * Blog.comments
   */
  export type Blog$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Blog.likedBy
   */
  export type Blog$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    where?: LikedBlogWhereInput
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    cursor?: LikedBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedBlogScalarFieldEnum | LikedBlogScalarFieldEnum[]
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    blogId: string | null
    authorId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    blogId: string | null
    authorId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    blogId: number
    authorId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    blogId?: true
    authorId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    blogId?: true
    authorId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    blogId?: true
    authorId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    blogId: string
    authorId: string
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    blogId?: boolean
    authorId?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    blogId?: boolean
    authorId?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    blogId?: boolean
    authorId?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    blogId?: boolean
    authorId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "blogId" | "authorId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      blogId: string
      authorId: string
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly blogId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model LikedBlog
   */

  export type AggregateLikedBlog = {
    _count: LikedBlogCountAggregateOutputType | null
    _min: LikedBlogMinAggregateOutputType | null
    _max: LikedBlogMaxAggregateOutputType | null
  }

  export type LikedBlogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    blogId: string | null
  }

  export type LikedBlogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    blogId: string | null
  }

  export type LikedBlogCountAggregateOutputType = {
    id: number
    userId: number
    blogId: number
    _all: number
  }


  export type LikedBlogMinAggregateInputType = {
    id?: true
    userId?: true
    blogId?: true
  }

  export type LikedBlogMaxAggregateInputType = {
    id?: true
    userId?: true
    blogId?: true
  }

  export type LikedBlogCountAggregateInputType = {
    id?: true
    userId?: true
    blogId?: true
    _all?: true
  }

  export type LikedBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedBlog to aggregate.
     */
    where?: LikedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedBlogs to fetch.
     */
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikedBlogs
    **/
    _count?: true | LikedBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikedBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikedBlogMaxAggregateInputType
  }

  export type GetLikedBlogAggregateType<T extends LikedBlogAggregateArgs> = {
        [P in keyof T & keyof AggregateLikedBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikedBlog[P]>
      : GetScalarType<T[P], AggregateLikedBlog[P]>
  }




  export type LikedBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedBlogWhereInput
    orderBy?: LikedBlogOrderByWithAggregationInput | LikedBlogOrderByWithAggregationInput[]
    by: LikedBlogScalarFieldEnum[] | LikedBlogScalarFieldEnum
    having?: LikedBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikedBlogCountAggregateInputType | true
    _min?: LikedBlogMinAggregateInputType
    _max?: LikedBlogMaxAggregateInputType
  }

  export type LikedBlogGroupByOutputType = {
    id: string
    userId: string
    blogId: string
    _count: LikedBlogCountAggregateOutputType | null
    _min: LikedBlogMinAggregateOutputType | null
    _max: LikedBlogMaxAggregateOutputType | null
  }

  type GetLikedBlogGroupByPayload<T extends LikedBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikedBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikedBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikedBlogGroupByOutputType[P]>
            : GetScalarType<T[P], LikedBlogGroupByOutputType[P]>
        }
      >
    >


  export type LikedBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blogId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedBlog"]>

  export type LikedBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blogId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedBlog"]>

  export type LikedBlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blogId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedBlog"]>

  export type LikedBlogSelectScalar = {
    id?: boolean
    userId?: boolean
    blogId?: boolean
  }

  export type LikedBlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "blogId", ExtArgs["result"]["likedBlog"]>
  export type LikedBlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type LikedBlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type LikedBlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }

  export type $LikedBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikedBlog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      blog: Prisma.$BlogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      blogId: string
    }, ExtArgs["result"]["likedBlog"]>
    composites: {}
  }

  type LikedBlogGetPayload<S extends boolean | null | undefined | LikedBlogDefaultArgs> = $Result.GetResult<Prisma.$LikedBlogPayload, S>

  type LikedBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikedBlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikedBlogCountAggregateInputType | true
    }

  export interface LikedBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikedBlog'], meta: { name: 'LikedBlog' } }
    /**
     * Find zero or one LikedBlog that matches the filter.
     * @param {LikedBlogFindUniqueArgs} args - Arguments to find a LikedBlog
     * @example
     * // Get one LikedBlog
     * const likedBlog = await prisma.likedBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikedBlogFindUniqueArgs>(args: SelectSubset<T, LikedBlogFindUniqueArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LikedBlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikedBlogFindUniqueOrThrowArgs} args - Arguments to find a LikedBlog
     * @example
     * // Get one LikedBlog
     * const likedBlog = await prisma.likedBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikedBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, LikedBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LikedBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogFindFirstArgs} args - Arguments to find a LikedBlog
     * @example
     * // Get one LikedBlog
     * const likedBlog = await prisma.likedBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikedBlogFindFirstArgs>(args?: SelectSubset<T, LikedBlogFindFirstArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LikedBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogFindFirstOrThrowArgs} args - Arguments to find a LikedBlog
     * @example
     * // Get one LikedBlog
     * const likedBlog = await prisma.likedBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikedBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, LikedBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LikedBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikedBlogs
     * const likedBlogs = await prisma.likedBlog.findMany()
     * 
     * // Get first 10 LikedBlogs
     * const likedBlogs = await prisma.likedBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likedBlogWithIdOnly = await prisma.likedBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikedBlogFindManyArgs>(args?: SelectSubset<T, LikedBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LikedBlog.
     * @param {LikedBlogCreateArgs} args - Arguments to create a LikedBlog.
     * @example
     * // Create one LikedBlog
     * const LikedBlog = await prisma.likedBlog.create({
     *   data: {
     *     // ... data to create a LikedBlog
     *   }
     * })
     * 
     */
    create<T extends LikedBlogCreateArgs>(args: SelectSubset<T, LikedBlogCreateArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LikedBlogs.
     * @param {LikedBlogCreateManyArgs} args - Arguments to create many LikedBlogs.
     * @example
     * // Create many LikedBlogs
     * const likedBlog = await prisma.likedBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikedBlogCreateManyArgs>(args?: SelectSubset<T, LikedBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikedBlogs and returns the data saved in the database.
     * @param {LikedBlogCreateManyAndReturnArgs} args - Arguments to create many LikedBlogs.
     * @example
     * // Create many LikedBlogs
     * const likedBlog = await prisma.likedBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikedBlogs and only return the `id`
     * const likedBlogWithIdOnly = await prisma.likedBlog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikedBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, LikedBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LikedBlog.
     * @param {LikedBlogDeleteArgs} args - Arguments to delete one LikedBlog.
     * @example
     * // Delete one LikedBlog
     * const LikedBlog = await prisma.likedBlog.delete({
     *   where: {
     *     // ... filter to delete one LikedBlog
     *   }
     * })
     * 
     */
    delete<T extends LikedBlogDeleteArgs>(args: SelectSubset<T, LikedBlogDeleteArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LikedBlog.
     * @param {LikedBlogUpdateArgs} args - Arguments to update one LikedBlog.
     * @example
     * // Update one LikedBlog
     * const likedBlog = await prisma.likedBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikedBlogUpdateArgs>(args: SelectSubset<T, LikedBlogUpdateArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LikedBlogs.
     * @param {LikedBlogDeleteManyArgs} args - Arguments to filter LikedBlogs to delete.
     * @example
     * // Delete a few LikedBlogs
     * const { count } = await prisma.likedBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikedBlogDeleteManyArgs>(args?: SelectSubset<T, LikedBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikedBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikedBlogs
     * const likedBlog = await prisma.likedBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikedBlogUpdateManyArgs>(args: SelectSubset<T, LikedBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikedBlogs and returns the data updated in the database.
     * @param {LikedBlogUpdateManyAndReturnArgs} args - Arguments to update many LikedBlogs.
     * @example
     * // Update many LikedBlogs
     * const likedBlog = await prisma.likedBlog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikedBlogs and only return the `id`
     * const likedBlogWithIdOnly = await prisma.likedBlog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikedBlogUpdateManyAndReturnArgs>(args: SelectSubset<T, LikedBlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LikedBlog.
     * @param {LikedBlogUpsertArgs} args - Arguments to update or create a LikedBlog.
     * @example
     * // Update or create a LikedBlog
     * const likedBlog = await prisma.likedBlog.upsert({
     *   create: {
     *     // ... data to create a LikedBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikedBlog we want to update
     *   }
     * })
     */
    upsert<T extends LikedBlogUpsertArgs>(args: SelectSubset<T, LikedBlogUpsertArgs<ExtArgs>>): Prisma__LikedBlogClient<$Result.GetResult<Prisma.$LikedBlogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LikedBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogCountArgs} args - Arguments to filter LikedBlogs to count.
     * @example
     * // Count the number of LikedBlogs
     * const count = await prisma.likedBlog.count({
     *   where: {
     *     // ... the filter for the LikedBlogs we want to count
     *   }
     * })
    **/
    count<T extends LikedBlogCountArgs>(
      args?: Subset<T, LikedBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikedBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikedBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikedBlogAggregateArgs>(args: Subset<T, LikedBlogAggregateArgs>): Prisma.PrismaPromise<GetLikedBlogAggregateType<T>>

    /**
     * Group by LikedBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikedBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikedBlogGroupByArgs['orderBy'] }
        : { orderBy?: LikedBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikedBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikedBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikedBlog model
   */
  readonly fields: LikedBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikedBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikedBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikedBlog model
   */ 
  interface LikedBlogFieldRefs {
    readonly id: FieldRef<"LikedBlog", 'String'>
    readonly userId: FieldRef<"LikedBlog", 'String'>
    readonly blogId: FieldRef<"LikedBlog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LikedBlog findUnique
   */
  export type LikedBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter, which LikedBlog to fetch.
     */
    where: LikedBlogWhereUniqueInput
  }

  /**
   * LikedBlog findUniqueOrThrow
   */
  export type LikedBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter, which LikedBlog to fetch.
     */
    where: LikedBlogWhereUniqueInput
  }

  /**
   * LikedBlog findFirst
   */
  export type LikedBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter, which LikedBlog to fetch.
     */
    where?: LikedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedBlogs to fetch.
     */
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedBlogs.
     */
    cursor?: LikedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedBlogs.
     */
    distinct?: LikedBlogScalarFieldEnum | LikedBlogScalarFieldEnum[]
  }

  /**
   * LikedBlog findFirstOrThrow
   */
  export type LikedBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter, which LikedBlog to fetch.
     */
    where?: LikedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedBlogs to fetch.
     */
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedBlogs.
     */
    cursor?: LikedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedBlogs.
     */
    distinct?: LikedBlogScalarFieldEnum | LikedBlogScalarFieldEnum[]
  }

  /**
   * LikedBlog findMany
   */
  export type LikedBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter, which LikedBlogs to fetch.
     */
    where?: LikedBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedBlogs to fetch.
     */
    orderBy?: LikedBlogOrderByWithRelationInput | LikedBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikedBlogs.
     */
    cursor?: LikedBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedBlogs.
     */
    skip?: number
    distinct?: LikedBlogScalarFieldEnum | LikedBlogScalarFieldEnum[]
  }

  /**
   * LikedBlog create
   */
  export type LikedBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * The data needed to create a LikedBlog.
     */
    data: XOR<LikedBlogCreateInput, LikedBlogUncheckedCreateInput>
  }

  /**
   * LikedBlog createMany
   */
  export type LikedBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikedBlogs.
     */
    data: LikedBlogCreateManyInput | LikedBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikedBlog createManyAndReturn
   */
  export type LikedBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * The data used to create many LikedBlogs.
     */
    data: LikedBlogCreateManyInput | LikedBlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikedBlog update
   */
  export type LikedBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * The data needed to update a LikedBlog.
     */
    data: XOR<LikedBlogUpdateInput, LikedBlogUncheckedUpdateInput>
    /**
     * Choose, which LikedBlog to update.
     */
    where: LikedBlogWhereUniqueInput
  }

  /**
   * LikedBlog updateMany
   */
  export type LikedBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikedBlogs.
     */
    data: XOR<LikedBlogUpdateManyMutationInput, LikedBlogUncheckedUpdateManyInput>
    /**
     * Filter which LikedBlogs to update
     */
    where?: LikedBlogWhereInput
  }

  /**
   * LikedBlog updateManyAndReturn
   */
  export type LikedBlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * The data used to update LikedBlogs.
     */
    data: XOR<LikedBlogUpdateManyMutationInput, LikedBlogUncheckedUpdateManyInput>
    /**
     * Filter which LikedBlogs to update
     */
    where?: LikedBlogWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikedBlog upsert
   */
  export type LikedBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * The filter to search for the LikedBlog to update in case it exists.
     */
    where: LikedBlogWhereUniqueInput
    /**
     * In case the LikedBlog found by the `where` argument doesn't exist, create a new LikedBlog with this data.
     */
    create: XOR<LikedBlogCreateInput, LikedBlogUncheckedCreateInput>
    /**
     * In case the LikedBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikedBlogUpdateInput, LikedBlogUncheckedUpdateInput>
  }

  /**
   * LikedBlog delete
   */
  export type LikedBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
    /**
     * Filter which LikedBlog to delete.
     */
    where: LikedBlogWhereUniqueInput
  }

  /**
   * LikedBlog deleteMany
   */
  export type LikedBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedBlogs to delete
     */
    where?: LikedBlogWhereInput
  }

  /**
   * LikedBlog without action
   */
  export type LikedBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedBlog
     */
    select?: LikedBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedBlog
     */
    omit?: LikedBlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedBlogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    refresh_Token: 'refresh_Token',
    password_hash: 'password_hash',
    googleUid: 'googleUid',
    resetPassword_Token: 'resetPassword_Token',
    profile_photo: 'profile_photo',
    user_name: 'user_name',
    phone_number: 'phone_number',
    role: 'role',
    wedding_date: 'wedding_date',
    wedding_location: 'wedding_location',
    created_at: 'created_at',
    is_verified: 'is_verified',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    booking_id: 'booking_id',
    service_id: 'service_id',
    vendor_id: 'vendor_id',
    booking_date: 'booking_date',
    status: 'status',
    negotiated_price: 'negotiated_price',
    is_negotiable: 'is_negotiable',
    totalAmount: 'totalAmount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const ChecklistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    items: 'items',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChecklistScalarFieldEnum = (typeof ChecklistScalarFieldEnum)[keyof typeof ChecklistScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventName: 'eventName',
    eventDescription: 'eventDescription',
    eventDate: 'eventDate',
    eventStartTime: 'eventStartTime',
    eventEndTime: 'eventEndTime',
    eventBudget: 'eventBudget',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventVendorsScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type EventVendorsScalarFieldEnum = (typeof EventVendorsScalarFieldEnum)[keyof typeof EventVendorsScalarFieldEnum]


  export const EventTaskScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    priority: 'priority',
    done: 'done',
    scheduleDate: 'scheduleDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventTaskScalarFieldEnum = (typeof EventTaskScalarFieldEnum)[keyof typeof EventTaskScalarFieldEnum]


  export const SubEventScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    subEventName: 'subEventName',
    subEventDescription: 'subEventDescription',
    subEventBudget: 'subEventBudget',
    subEventDate: 'subEventDate',
    subEventStartTime: 'subEventStartTime',
    subEventEndTime: 'subEventEndTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubEventScalarFieldEnum = (typeof SubEventScalarFieldEnum)[keyof typeof SubEventScalarFieldEnum]


  export const SubEventVendorsScalarFieldEnum: {
    id: 'id',
    subEventId: 'subEventId',
    userId: 'userId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type SubEventVendorsScalarFieldEnum = (typeof SubEventVendorsScalarFieldEnum)[keyof typeof SubEventVendorsScalarFieldEnum]


  export const SubEventTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subEventId: 'subEventId',
    items: 'items',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubEventTaskScalarFieldEnum = (typeof SubEventTaskScalarFieldEnum)[keyof typeof SubEventTaskScalarFieldEnum]


  export const OrderDetailsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    razorpayResponse: 'razorpayResponse',
    createdAt: 'createdAt',
    userId: 'userId',
    templateId: 'templateId'
  };

  export type OrderDetailsScalarFieldEnum = (typeof OrderDetailsScalarFieldEnum)[keyof typeof OrderDetailsScalarFieldEnum]


  export const PaymentDetailsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    paymentId: 'paymentId',
    razorpayResponse: 'razorpayResponse',
    status: 'status',
    purchasedAt: 'purchasedAt',
    userId: 'userId',
    templateId: 'templateId'
  };

  export type PaymentDetailsScalarFieldEnum = (typeof PaymentDetailsScalarFieldEnum)[keyof typeof PaymentDetailsScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    review_id: 'review_id',
    vendor_id: 'vendor_id',
    id: 'id',
    rating: 'rating',
    review_text: 'review_text',
    created_at: 'created_at'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const EventScheduleScalarFieldEnum: {
    event_id: 'event_id',
    vendor_id: 'vendor_id',
    media_id: 'media_id',
    event_name: 'event_name',
    event_start_date: 'event_start_date',
    event_end_date: 'event_end_date',
    event_location: 'event_location',
    description: 'description',
    created_at: 'created_at'
  };

  export type EventScheduleScalarFieldEnum = (typeof EventScheduleScalarFieldEnum)[keyof typeof EventScheduleScalarFieldEnum]


  export const GuestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuestScalarFieldEnum = (typeof GuestScalarFieldEnum)[keyof typeof GuestScalarFieldEnum]


  export const InvitationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    price: 'price',
    template_type: 'template_type',
    template_category: 'template_category',
    filter: 'filter',
    createdAt: 'createdAt'
  };

  export type InvitationTemplateScalarFieldEnum = (typeof InvitationTemplateScalarFieldEnum)[keyof typeof InvitationTemplateScalarFieldEnum]


  export const UserDataTemplateScalarFieldEnum: {
    userId: 'userId',
    template_id: 'template_id',
    eventHeading: 'eventHeading',
    eventSubheading: 'eventSubheading',
    brideName: 'brideName',
    groomName: 'groomName',
    eventDate: 'eventDate',
    weddingTime: 'weddingTime',
    weddingLocation: 'weddingLocation',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserDataTemplateScalarFieldEnum = (typeof UserDataTemplateScalarFieldEnum)[keyof typeof UserDataTemplateScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    tags: 'tags',
    content: 'content',
    viewCount: 'viewCount',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    blogId: 'blogId',
    authorId: 'authorId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikedBlogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    blogId: 'blogId'
  };

  export type LikedBlogScalarFieldEnum = (typeof LikedBlogScalarFieldEnum)[keyof typeof LikedBlogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'GuestStatus'
   */
  export type EnumGuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuestStatus'>
    


  /**
   * Reference to a field of type 'GuestStatus[]'
   */
  export type ListEnumGuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuestStatus[]'>
    


  /**
   * Reference to a field of type 'template_category'
   */
  export type Enumtemplate_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'template_category'>
    


  /**
   * Reference to a field of type 'template_category[]'
   */
  export type ListEnumtemplate_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'template_category[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    refresh_Token?: StringNullableFilter<"User"> | string | null
    password_hash?: StringNullableFilter<"User"> | string | null
    googleUid?: StringNullableFilter<"User"> | string | null
    resetPassword_Token?: StringNullableFilter<"User"> | string | null
    profile_photo?: StringNullableFilter<"User"> | string | null
    user_name?: StringFilter<"User"> | string
    phone_number?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    wedding_date?: DateTimeNullableFilter<"User"> | Date | string | null
    wedding_location?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    is_verified?: BoolFilter<"User"> | boolean
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    cart?: CartListRelationFilter
    checklists?: ChecklistListRelationFilter
    guests?: GuestListRelationFilter
    paymentDetails?: PaymentDetailsListRelationFilter
    orderDetails?: OrderDetailsListRelationFilter
    userDataTemplate?: UserDataTemplateListRelationFilter
    event?: EventListRelationFilter
    likedBlogs?: LikedBlogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    refresh_Token?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    googleUid?: SortOrderInput | SortOrder
    resetPassword_Token?: SortOrderInput | SortOrder
    profile_photo?: SortOrderInput | SortOrder
    user_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    role?: SortOrder
    wedding_date?: SortOrderInput | SortOrder
    wedding_location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    cart?: CartOrderByRelationAggregateInput
    checklists?: ChecklistOrderByRelationAggregateInput
    guests?: GuestOrderByRelationAggregateInput
    paymentDetails?: PaymentDetailsOrderByRelationAggregateInput
    orderDetails?: OrderDetailsOrderByRelationAggregateInput
    userDataTemplate?: UserDataTemplateOrderByRelationAggregateInput
    event?: EventOrderByRelationAggregateInput
    likedBlogs?: LikedBlogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleUid?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    refresh_Token?: StringNullableFilter<"User"> | string | null
    password_hash?: StringNullableFilter<"User"> | string | null
    resetPassword_Token?: StringNullableFilter<"User"> | string | null
    profile_photo?: StringNullableFilter<"User"> | string | null
    user_name?: StringFilter<"User"> | string
    phone_number?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    wedding_date?: DateTimeNullableFilter<"User"> | Date | string | null
    wedding_location?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    is_verified?: BoolFilter<"User"> | boolean
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    cart?: CartListRelationFilter
    checklists?: ChecklistListRelationFilter
    guests?: GuestListRelationFilter
    paymentDetails?: PaymentDetailsListRelationFilter
    orderDetails?: OrderDetailsListRelationFilter
    userDataTemplate?: UserDataTemplateListRelationFilter
    event?: EventListRelationFilter
    likedBlogs?: LikedBlogListRelationFilter
  }, "id" | "email" | "googleUid">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    refresh_Token?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    googleUid?: SortOrderInput | SortOrder
    resetPassword_Token?: SortOrderInput | SortOrder
    profile_photo?: SortOrderInput | SortOrder
    user_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    role?: SortOrder
    wedding_date?: SortOrderInput | SortOrder
    wedding_location?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    refresh_Token?: StringNullableWithAggregatesFilter<"User"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleUid?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPassword_Token?: StringNullableWithAggregatesFilter<"User"> | string | null
    profile_photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    user_name?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    wedding_date?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    wedding_location?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    is_verified?: BoolWithAggregatesFilter<"User"> | boolean
    updated_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    booking_id?: StringFilter<"Booking"> | string
    service_id?: StringFilter<"Booking"> | string
    vendor_id?: StringFilter<"Booking"> | string
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    negotiated_price?: FloatNullableFilter<"Booking"> | number | null
    is_negotiable?: BoolFilter<"Booking"> | boolean
    totalAmount?: FloatFilter<"Booking"> | number
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    userId?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    service_id?: SortOrder
    vendor_id?: SortOrder
    booking_date?: SortOrder
    status?: SortOrder
    negotiated_price?: SortOrderInput | SortOrder
    is_negotiable?: SortOrder
    totalAmount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    userId?: UserOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    booking_id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    service_id?: StringFilter<"Booking"> | string
    vendor_id?: StringFilter<"Booking"> | string
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    negotiated_price?: FloatNullableFilter<"Booking"> | number | null
    is_negotiable?: BoolFilter<"Booking"> | boolean
    totalAmount?: FloatFilter<"Booking"> | number
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    userId?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "booking_id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    service_id?: SortOrder
    vendor_id?: SortOrder
    booking_date?: SortOrder
    status?: SortOrder
    negotiated_price?: SortOrderInput | SortOrder
    is_negotiable?: SortOrder
    totalAmount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    booking_id?: StringWithAggregatesFilter<"Booking"> | string
    service_id?: StringWithAggregatesFilter<"Booking"> | string
    vendor_id?: StringWithAggregatesFilter<"Booking"> | string
    booking_date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: StringWithAggregatesFilter<"Booking"> | string
    negotiated_price?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    is_negotiable?: BoolWithAggregatesFilter<"Booking"> | boolean
    totalAmount?: FloatWithAggregatesFilter<"Booking"> | number
    created_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    serviceId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_serviceId?: CartUserIdServiceIdCompoundUniqueInput
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userId?: StringFilter<"Cart"> | string
    serviceId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_serviceId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringWithAggregatesFilter<"Cart"> | string
    serviceId?: StringWithAggregatesFilter<"Cart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type ChecklistWhereInput = {
    AND?: ChecklistWhereInput | ChecklistWhereInput[]
    OR?: ChecklistWhereInput[]
    NOT?: ChecklistWhereInput | ChecklistWhereInput[]
    id?: StringFilter<"Checklist"> | string
    userId?: StringFilter<"Checklist"> | string
    items?: JsonFilter<"Checklist">
    createdAt?: DateTimeFilter<"Checklist"> | Date | string
    updatedAt?: DateTimeFilter<"Checklist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChecklistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChecklistWhereInput | ChecklistWhereInput[]
    OR?: ChecklistWhereInput[]
    NOT?: ChecklistWhereInput | ChecklistWhereInput[]
    userId?: StringFilter<"Checklist"> | string
    items?: JsonFilter<"Checklist">
    createdAt?: DateTimeFilter<"Checklist"> | Date | string
    updatedAt?: DateTimeFilter<"Checklist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChecklistCountOrderByAggregateInput
    _max?: ChecklistMaxOrderByAggregateInput
    _min?: ChecklistMinOrderByAggregateInput
  }

  export type ChecklistScalarWhereWithAggregatesInput = {
    AND?: ChecklistScalarWhereWithAggregatesInput | ChecklistScalarWhereWithAggregatesInput[]
    OR?: ChecklistScalarWhereWithAggregatesInput[]
    NOT?: ChecklistScalarWhereWithAggregatesInput | ChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Checklist"> | string
    userId?: StringWithAggregatesFilter<"Checklist"> | string
    items?: JsonWithAggregatesFilter<"Checklist">
    createdAt?: DateTimeWithAggregatesFilter<"Checklist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Checklist"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    eventName?: StringFilter<"Event"> | string
    eventDescription?: StringNullableFilter<"Event"> | string | null
    eventDate?: DateTimeFilter<"Event"> | Date | string
    eventStartTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventEndTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventBudget?: DecimalFilter<"Event"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    eventTask?: EventTaskListRelationFilter
    eventVendors?: EventVendorsListRelationFilter
    subEvent?: SubEventListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    eventStartTime?: SortOrderInput | SortOrder
    eventEndTime?: SortOrderInput | SortOrder
    eventBudget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    eventTask?: EventTaskOrderByRelationAggregateInput
    eventVendors?: EventVendorsOrderByRelationAggregateInput
    subEvent?: SubEventOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    userId?: StringFilter<"Event"> | string
    eventName?: StringFilter<"Event"> | string
    eventDescription?: StringNullableFilter<"Event"> | string | null
    eventDate?: DateTimeFilter<"Event"> | Date | string
    eventStartTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventEndTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventBudget?: DecimalFilter<"Event"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    eventTask?: EventTaskListRelationFilter
    eventVendors?: EventVendorsListRelationFilter
    subEvent?: SubEventListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    eventStartTime?: SortOrderInput | SortOrder
    eventEndTime?: SortOrderInput | SortOrder
    eventBudget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    userId?: StringWithAggregatesFilter<"Event"> | string
    eventName?: StringWithAggregatesFilter<"Event"> | string
    eventDescription?: StringNullableWithAggregatesFilter<"Event"> | string | null
    eventDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    eventStartTime?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    eventEndTime?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    eventBudget?: DecimalWithAggregatesFilter<"Event"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventVendorsWhereInput = {
    AND?: EventVendorsWhereInput | EventVendorsWhereInput[]
    OR?: EventVendorsWhereInput[]
    NOT?: EventVendorsWhereInput | EventVendorsWhereInput[]
    id?: StringFilter<"EventVendors"> | string
    eventId?: StringFilter<"EventVendors"> | string
    serviceId?: StringFilter<"EventVendors"> | string
    createdAt?: DateTimeFilter<"EventVendors"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type EventVendorsOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventVendorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_serviceId?: EventVendorsEventIdServiceIdCompoundUniqueInput
    AND?: EventVendorsWhereInput | EventVendorsWhereInput[]
    OR?: EventVendorsWhereInput[]
    NOT?: EventVendorsWhereInput | EventVendorsWhereInput[]
    eventId?: StringFilter<"EventVendors"> | string
    serviceId?: StringFilter<"EventVendors"> | string
    createdAt?: DateTimeFilter<"EventVendors"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id" | "eventId_serviceId">

  export type EventVendorsOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    _count?: EventVendorsCountOrderByAggregateInput
    _max?: EventVendorsMaxOrderByAggregateInput
    _min?: EventVendorsMinOrderByAggregateInput
  }

  export type EventVendorsScalarWhereWithAggregatesInput = {
    AND?: EventVendorsScalarWhereWithAggregatesInput | EventVendorsScalarWhereWithAggregatesInput[]
    OR?: EventVendorsScalarWhereWithAggregatesInput[]
    NOT?: EventVendorsScalarWhereWithAggregatesInput | EventVendorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventVendors"> | string
    eventId?: StringWithAggregatesFilter<"EventVendors"> | string
    serviceId?: StringWithAggregatesFilter<"EventVendors"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventVendors"> | Date | string
  }

  export type EventTaskWhereInput = {
    AND?: EventTaskWhereInput | EventTaskWhereInput[]
    OR?: EventTaskWhereInput[]
    NOT?: EventTaskWhereInput | EventTaskWhereInput[]
    id?: StringFilter<"EventTask"> | string
    eventId?: StringFilter<"EventTask"> | string
    name?: StringFilter<"EventTask"> | string
    priority?: StringFilter<"EventTask"> | string
    done?: BoolFilter<"EventTask"> | boolean
    scheduleDate?: DateTimeNullableFilter<"EventTask"> | Date | string | null
    createdAt?: DateTimeFilter<"EventTask"> | Date | string
    updatedAt?: DateTimeFilter<"EventTask"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type EventTaskOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    done?: SortOrder
    scheduleDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventTaskWhereInput | EventTaskWhereInput[]
    OR?: EventTaskWhereInput[]
    NOT?: EventTaskWhereInput | EventTaskWhereInput[]
    eventId?: StringFilter<"EventTask"> | string
    name?: StringFilter<"EventTask"> | string
    priority?: StringFilter<"EventTask"> | string
    done?: BoolFilter<"EventTask"> | boolean
    scheduleDate?: DateTimeNullableFilter<"EventTask"> | Date | string | null
    createdAt?: DateTimeFilter<"EventTask"> | Date | string
    updatedAt?: DateTimeFilter<"EventTask"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id">

  export type EventTaskOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    done?: SortOrder
    scheduleDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventTaskCountOrderByAggregateInput
    _max?: EventTaskMaxOrderByAggregateInput
    _min?: EventTaskMinOrderByAggregateInput
  }

  export type EventTaskScalarWhereWithAggregatesInput = {
    AND?: EventTaskScalarWhereWithAggregatesInput | EventTaskScalarWhereWithAggregatesInput[]
    OR?: EventTaskScalarWhereWithAggregatesInput[]
    NOT?: EventTaskScalarWhereWithAggregatesInput | EventTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventTask"> | string
    eventId?: StringWithAggregatesFilter<"EventTask"> | string
    name?: StringWithAggregatesFilter<"EventTask"> | string
    priority?: StringWithAggregatesFilter<"EventTask"> | string
    done?: BoolWithAggregatesFilter<"EventTask"> | boolean
    scheduleDate?: DateTimeNullableWithAggregatesFilter<"EventTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventTask"> | Date | string
  }

  export type SubEventWhereInput = {
    AND?: SubEventWhereInput | SubEventWhereInput[]
    OR?: SubEventWhereInput[]
    NOT?: SubEventWhereInput | SubEventWhereInput[]
    id?: StringFilter<"SubEvent"> | string
    eventId?: StringFilter<"SubEvent"> | string
    subEventName?: StringFilter<"SubEvent"> | string
    subEventDescription?: StringFilter<"SubEvent"> | string
    subEventBudget?: DecimalFilter<"SubEvent"> | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFilter<"SubEvent"> | Date | string
    subEventStartTime?: DateTimeFilter<"SubEvent"> | Date | string
    subEventEndTime?: DateTimeFilter<"SubEvent"> | Date | string
    createdAt?: DateTimeFilter<"SubEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubEvent"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    subEventTask?: SubEventTaskListRelationFilter
    subEventVendors?: SubEventVendorsListRelationFilter
  }

  export type SubEventOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    subEventName?: SortOrder
    subEventDescription?: SortOrder
    subEventBudget?: SortOrder
    subEventDate?: SortOrder
    subEventStartTime?: SortOrder
    subEventEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    subEventTask?: SubEventTaskOrderByRelationAggregateInput
    subEventVendors?: SubEventVendorsOrderByRelationAggregateInput
  }

  export type SubEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubEventWhereInput | SubEventWhereInput[]
    OR?: SubEventWhereInput[]
    NOT?: SubEventWhereInput | SubEventWhereInput[]
    eventId?: StringFilter<"SubEvent"> | string
    subEventName?: StringFilter<"SubEvent"> | string
    subEventDescription?: StringFilter<"SubEvent"> | string
    subEventBudget?: DecimalFilter<"SubEvent"> | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFilter<"SubEvent"> | Date | string
    subEventStartTime?: DateTimeFilter<"SubEvent"> | Date | string
    subEventEndTime?: DateTimeFilter<"SubEvent"> | Date | string
    createdAt?: DateTimeFilter<"SubEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubEvent"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    subEventTask?: SubEventTaskListRelationFilter
    subEventVendors?: SubEventVendorsListRelationFilter
  }, "id">

  export type SubEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    subEventName?: SortOrder
    subEventDescription?: SortOrder
    subEventBudget?: SortOrder
    subEventDate?: SortOrder
    subEventStartTime?: SortOrder
    subEventEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubEventCountOrderByAggregateInput
    _avg?: SubEventAvgOrderByAggregateInput
    _max?: SubEventMaxOrderByAggregateInput
    _min?: SubEventMinOrderByAggregateInput
    _sum?: SubEventSumOrderByAggregateInput
  }

  export type SubEventScalarWhereWithAggregatesInput = {
    AND?: SubEventScalarWhereWithAggregatesInput | SubEventScalarWhereWithAggregatesInput[]
    OR?: SubEventScalarWhereWithAggregatesInput[]
    NOT?: SubEventScalarWhereWithAggregatesInput | SubEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubEvent"> | string
    eventId?: StringWithAggregatesFilter<"SubEvent"> | string
    subEventName?: StringWithAggregatesFilter<"SubEvent"> | string
    subEventDescription?: StringWithAggregatesFilter<"SubEvent"> | string
    subEventBudget?: DecimalWithAggregatesFilter<"SubEvent"> | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeWithAggregatesFilter<"SubEvent"> | Date | string
    subEventStartTime?: DateTimeWithAggregatesFilter<"SubEvent"> | Date | string
    subEventEndTime?: DateTimeWithAggregatesFilter<"SubEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SubEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubEvent"> | Date | string
  }

  export type SubEventVendorsWhereInput = {
    AND?: SubEventVendorsWhereInput | SubEventVendorsWhereInput[]
    OR?: SubEventVendorsWhereInput[]
    NOT?: SubEventVendorsWhereInput | SubEventVendorsWhereInput[]
    id?: StringFilter<"SubEventVendors"> | string
    subEventId?: StringFilter<"SubEventVendors"> | string
    userId?: StringFilter<"SubEventVendors"> | string
    serviceId?: StringFilter<"SubEventVendors"> | string
    createdAt?: DateTimeFilter<"SubEventVendors"> | Date | string
    subEvent?: XOR<SubEventScalarRelationFilter, SubEventWhereInput>
  }

  export type SubEventVendorsOrderByWithRelationInput = {
    id?: SortOrder
    subEventId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    subEvent?: SubEventOrderByWithRelationInput
  }

  export type SubEventVendorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subEventId_serviceId?: SubEventVendorsSubEventIdServiceIdCompoundUniqueInput
    AND?: SubEventVendorsWhereInput | SubEventVendorsWhereInput[]
    OR?: SubEventVendorsWhereInput[]
    NOT?: SubEventVendorsWhereInput | SubEventVendorsWhereInput[]
    subEventId?: StringFilter<"SubEventVendors"> | string
    userId?: StringFilter<"SubEventVendors"> | string
    serviceId?: StringFilter<"SubEventVendors"> | string
    createdAt?: DateTimeFilter<"SubEventVendors"> | Date | string
    subEvent?: XOR<SubEventScalarRelationFilter, SubEventWhereInput>
  }, "id" | "subEventId_serviceId">

  export type SubEventVendorsOrderByWithAggregationInput = {
    id?: SortOrder
    subEventId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    _count?: SubEventVendorsCountOrderByAggregateInput
    _max?: SubEventVendorsMaxOrderByAggregateInput
    _min?: SubEventVendorsMinOrderByAggregateInput
  }

  export type SubEventVendorsScalarWhereWithAggregatesInput = {
    AND?: SubEventVendorsScalarWhereWithAggregatesInput | SubEventVendorsScalarWhereWithAggregatesInput[]
    OR?: SubEventVendorsScalarWhereWithAggregatesInput[]
    NOT?: SubEventVendorsScalarWhereWithAggregatesInput | SubEventVendorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubEventVendors"> | string
    subEventId?: StringWithAggregatesFilter<"SubEventVendors"> | string
    userId?: StringWithAggregatesFilter<"SubEventVendors"> | string
    serviceId?: StringWithAggregatesFilter<"SubEventVendors"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubEventVendors"> | Date | string
  }

  export type SubEventTaskWhereInput = {
    AND?: SubEventTaskWhereInput | SubEventTaskWhereInput[]
    OR?: SubEventTaskWhereInput[]
    NOT?: SubEventTaskWhereInput | SubEventTaskWhereInput[]
    id?: StringFilter<"SubEventTask"> | string
    userId?: StringFilter<"SubEventTask"> | string
    subEventId?: StringFilter<"SubEventTask"> | string
    items?: JsonFilter<"SubEventTask">
    createdAt?: DateTimeFilter<"SubEventTask"> | Date | string
    updatedAt?: DateTimeFilter<"SubEventTask"> | Date | string
    subEvent?: XOR<SubEventScalarRelationFilter, SubEventWhereInput>
  }

  export type SubEventTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subEventId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subEvent?: SubEventOrderByWithRelationInput
  }

  export type SubEventTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubEventTaskWhereInput | SubEventTaskWhereInput[]
    OR?: SubEventTaskWhereInput[]
    NOT?: SubEventTaskWhereInput | SubEventTaskWhereInput[]
    userId?: StringFilter<"SubEventTask"> | string
    subEventId?: StringFilter<"SubEventTask"> | string
    items?: JsonFilter<"SubEventTask">
    createdAt?: DateTimeFilter<"SubEventTask"> | Date | string
    updatedAt?: DateTimeFilter<"SubEventTask"> | Date | string
    subEvent?: XOR<SubEventScalarRelationFilter, SubEventWhereInput>
  }, "id">

  export type SubEventTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subEventId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubEventTaskCountOrderByAggregateInput
    _max?: SubEventTaskMaxOrderByAggregateInput
    _min?: SubEventTaskMinOrderByAggregateInput
  }

  export type SubEventTaskScalarWhereWithAggregatesInput = {
    AND?: SubEventTaskScalarWhereWithAggregatesInput | SubEventTaskScalarWhereWithAggregatesInput[]
    OR?: SubEventTaskScalarWhereWithAggregatesInput[]
    NOT?: SubEventTaskScalarWhereWithAggregatesInput | SubEventTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubEventTask"> | string
    userId?: StringWithAggregatesFilter<"SubEventTask"> | string
    subEventId?: StringWithAggregatesFilter<"SubEventTask"> | string
    items?: JsonWithAggregatesFilter<"SubEventTask">
    createdAt?: DateTimeWithAggregatesFilter<"SubEventTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubEventTask"> | Date | string
  }

  export type OrderDetailsWhereInput = {
    AND?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    OR?: OrderDetailsWhereInput[]
    NOT?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    id?: StringFilter<"OrderDetails"> | string
    orderId?: StringFilter<"OrderDetails"> | string
    amount?: FloatFilter<"OrderDetails"> | number
    currency?: StringFilter<"OrderDetails"> | string
    status?: StringFilter<"OrderDetails"> | string
    razorpayResponse?: JsonFilter<"OrderDetails">
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    userId?: StringFilter<"OrderDetails"> | string
    templateId?: StringNullableFilter<"OrderDetails"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    InvitationTemplate?: XOR<InvitationTemplateNullableScalarRelationFilter, InvitationTemplateWhereInput> | null
  }

  export type OrderDetailsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    razorpayResponse?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    InvitationTemplate?: InvitationTemplateOrderByWithRelationInput
  }

  export type OrderDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    OR?: OrderDetailsWhereInput[]
    NOT?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    amount?: FloatFilter<"OrderDetails"> | number
    currency?: StringFilter<"OrderDetails"> | string
    status?: StringFilter<"OrderDetails"> | string
    razorpayResponse?: JsonFilter<"OrderDetails">
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    userId?: StringFilter<"OrderDetails"> | string
    templateId?: StringNullableFilter<"OrderDetails"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    InvitationTemplate?: XOR<InvitationTemplateNullableScalarRelationFilter, InvitationTemplateWhereInput> | null
  }, "id" | "orderId">

  export type OrderDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    razorpayResponse?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    _count?: OrderDetailsCountOrderByAggregateInput
    _avg?: OrderDetailsAvgOrderByAggregateInput
    _max?: OrderDetailsMaxOrderByAggregateInput
    _min?: OrderDetailsMinOrderByAggregateInput
    _sum?: OrderDetailsSumOrderByAggregateInput
  }

  export type OrderDetailsScalarWhereWithAggregatesInput = {
    AND?: OrderDetailsScalarWhereWithAggregatesInput | OrderDetailsScalarWhereWithAggregatesInput[]
    OR?: OrderDetailsScalarWhereWithAggregatesInput[]
    NOT?: OrderDetailsScalarWhereWithAggregatesInput | OrderDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderDetails"> | string
    orderId?: StringWithAggregatesFilter<"OrderDetails"> | string
    amount?: FloatWithAggregatesFilter<"OrderDetails"> | number
    currency?: StringWithAggregatesFilter<"OrderDetails"> | string
    status?: StringWithAggregatesFilter<"OrderDetails"> | string
    razorpayResponse?: JsonWithAggregatesFilter<"OrderDetails">
    createdAt?: DateTimeWithAggregatesFilter<"OrderDetails"> | Date | string
    userId?: StringWithAggregatesFilter<"OrderDetails"> | string
    templateId?: StringNullableWithAggregatesFilter<"OrderDetails"> | string | null
  }

  export type PaymentDetailsWhereInput = {
    AND?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    OR?: PaymentDetailsWhereInput[]
    NOT?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    id?: StringFilter<"PaymentDetails"> | string
    orderId?: StringFilter<"PaymentDetails"> | string
    paymentId?: StringNullableFilter<"PaymentDetails"> | string | null
    razorpayResponse?: JsonFilter<"PaymentDetails">
    status?: StringFilter<"PaymentDetails"> | string
    purchasedAt?: DateTimeNullableFilter<"PaymentDetails"> | Date | string | null
    userId?: StringFilter<"PaymentDetails"> | string
    templateId?: StringNullableFilter<"PaymentDetails"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    InvitationTemplate?: XOR<InvitationTemplateNullableScalarRelationFilter, InvitationTemplateWhereInput> | null
  }

  export type PaymentDetailsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    razorpayResponse?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    InvitationTemplate?: InvitationTemplateOrderByWithRelationInput
  }

  export type PaymentDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    OR?: PaymentDetailsWhereInput[]
    NOT?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    paymentId?: StringNullableFilter<"PaymentDetails"> | string | null
    razorpayResponse?: JsonFilter<"PaymentDetails">
    status?: StringFilter<"PaymentDetails"> | string
    purchasedAt?: DateTimeNullableFilter<"PaymentDetails"> | Date | string | null
    userId?: StringFilter<"PaymentDetails"> | string
    templateId?: StringNullableFilter<"PaymentDetails"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    InvitationTemplate?: XOR<InvitationTemplateNullableScalarRelationFilter, InvitationTemplateWhereInput> | null
  }, "id" | "orderId">

  export type PaymentDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    razorpayResponse?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    _count?: PaymentDetailsCountOrderByAggregateInput
    _max?: PaymentDetailsMaxOrderByAggregateInput
    _min?: PaymentDetailsMinOrderByAggregateInput
  }

  export type PaymentDetailsScalarWhereWithAggregatesInput = {
    AND?: PaymentDetailsScalarWhereWithAggregatesInput | PaymentDetailsScalarWhereWithAggregatesInput[]
    OR?: PaymentDetailsScalarWhereWithAggregatesInput[]
    NOT?: PaymentDetailsScalarWhereWithAggregatesInput | PaymentDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentDetails"> | string
    orderId?: StringWithAggregatesFilter<"PaymentDetails"> | string
    paymentId?: StringNullableWithAggregatesFilter<"PaymentDetails"> | string | null
    razorpayResponse?: JsonWithAggregatesFilter<"PaymentDetails">
    status?: StringWithAggregatesFilter<"PaymentDetails"> | string
    purchasedAt?: DateTimeNullableWithAggregatesFilter<"PaymentDetails"> | Date | string | null
    userId?: StringWithAggregatesFilter<"PaymentDetails"> | string
    templateId?: StringNullableWithAggregatesFilter<"PaymentDetails"> | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    review_id?: StringFilter<"Review"> | string
    vendor_id?: StringFilter<"Review"> | string
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    review_text?: StringFilter<"Review"> | string
    created_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    review_id?: SortOrder
    vendor_id?: SortOrder
    id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    review_id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    vendor_id?: StringFilter<"Review"> | string
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    review_text?: StringFilter<"Review"> | string
    created_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "review_id">

  export type ReviewOrderByWithAggregationInput = {
    review_id?: SortOrder
    vendor_id?: SortOrder
    id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    review_id?: StringWithAggregatesFilter<"Review"> | string
    vendor_id?: StringWithAggregatesFilter<"Review"> | string
    id?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    review_text?: StringWithAggregatesFilter<"Review"> | string
    created_at?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type EventScheduleWhereInput = {
    AND?: EventScheduleWhereInput | EventScheduleWhereInput[]
    OR?: EventScheduleWhereInput[]
    NOT?: EventScheduleWhereInput | EventScheduleWhereInput[]
    event_id?: StringFilter<"EventSchedule"> | string
    vendor_id?: StringFilter<"EventSchedule"> | string
    media_id?: StringFilter<"EventSchedule"> | string
    event_name?: StringFilter<"EventSchedule"> | string
    event_start_date?: DateTimeFilter<"EventSchedule"> | Date | string
    event_end_date?: DateTimeFilter<"EventSchedule"> | Date | string
    event_location?: StringFilter<"EventSchedule"> | string
    description?: StringFilter<"EventSchedule"> | string
    created_at?: DateTimeFilter<"EventSchedule"> | Date | string
  }

  export type EventScheduleOrderByWithRelationInput = {
    event_id?: SortOrder
    vendor_id?: SortOrder
    media_id?: SortOrder
    event_name?: SortOrder
    event_start_date?: SortOrder
    event_end_date?: SortOrder
    event_location?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EventScheduleWhereUniqueInput = Prisma.AtLeast<{
    event_id?: string
    AND?: EventScheduleWhereInput | EventScheduleWhereInput[]
    OR?: EventScheduleWhereInput[]
    NOT?: EventScheduleWhereInput | EventScheduleWhereInput[]
    vendor_id?: StringFilter<"EventSchedule"> | string
    media_id?: StringFilter<"EventSchedule"> | string
    event_name?: StringFilter<"EventSchedule"> | string
    event_start_date?: DateTimeFilter<"EventSchedule"> | Date | string
    event_end_date?: DateTimeFilter<"EventSchedule"> | Date | string
    event_location?: StringFilter<"EventSchedule"> | string
    description?: StringFilter<"EventSchedule"> | string
    created_at?: DateTimeFilter<"EventSchedule"> | Date | string
  }, "event_id">

  export type EventScheduleOrderByWithAggregationInput = {
    event_id?: SortOrder
    vendor_id?: SortOrder
    media_id?: SortOrder
    event_name?: SortOrder
    event_start_date?: SortOrder
    event_end_date?: SortOrder
    event_location?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    _count?: EventScheduleCountOrderByAggregateInput
    _max?: EventScheduleMaxOrderByAggregateInput
    _min?: EventScheduleMinOrderByAggregateInput
  }

  export type EventScheduleScalarWhereWithAggregatesInput = {
    AND?: EventScheduleScalarWhereWithAggregatesInput | EventScheduleScalarWhereWithAggregatesInput[]
    OR?: EventScheduleScalarWhereWithAggregatesInput[]
    NOT?: EventScheduleScalarWhereWithAggregatesInput | EventScheduleScalarWhereWithAggregatesInput[]
    event_id?: StringWithAggregatesFilter<"EventSchedule"> | string
    vendor_id?: StringWithAggregatesFilter<"EventSchedule"> | string
    media_id?: StringWithAggregatesFilter<"EventSchedule"> | string
    event_name?: StringWithAggregatesFilter<"EventSchedule"> | string
    event_start_date?: DateTimeWithAggregatesFilter<"EventSchedule"> | Date | string
    event_end_date?: DateTimeWithAggregatesFilter<"EventSchedule"> | Date | string
    event_location?: StringWithAggregatesFilter<"EventSchedule"> | string
    description?: StringWithAggregatesFilter<"EventSchedule"> | string
    created_at?: DateTimeWithAggregatesFilter<"EventSchedule"> | Date | string
  }

  export type GuestWhereInput = {
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    id?: StringFilter<"Guest"> | string
    name?: StringFilter<"Guest"> | string
    phone?: StringFilter<"Guest"> | string
    status?: EnumGuestStatusFilter<"Guest"> | $Enums.GuestStatus
    userId?: StringFilter<"Guest"> | string
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GuestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    name?: StringFilter<"Guest"> | string
    phone?: StringFilter<"Guest"> | string
    status?: EnumGuestStatusFilter<"Guest"> | $Enums.GuestStatus
    userId?: StringFilter<"Guest"> | string
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GuestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuestCountOrderByAggregateInput
    _max?: GuestMaxOrderByAggregateInput
    _min?: GuestMinOrderByAggregateInput
  }

  export type GuestScalarWhereWithAggregatesInput = {
    AND?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    OR?: GuestScalarWhereWithAggregatesInput[]
    NOT?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guest"> | string
    name?: StringWithAggregatesFilter<"Guest"> | string
    phone?: StringWithAggregatesFilter<"Guest"> | string
    status?: EnumGuestStatusWithAggregatesFilter<"Guest"> | $Enums.GuestStatus
    userId?: StringWithAggregatesFilter<"Guest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
  }

  export type InvitationTemplateWhereInput = {
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    id?: StringFilter<"InvitationTemplate"> | string
    name?: StringFilter<"InvitationTemplate"> | string
    imageUrl?: JsonFilter<"InvitationTemplate">
    price?: FloatNullableFilter<"InvitationTemplate"> | number | null
    template_type?: Enumtemplate_categoryFilter<"InvitationTemplate"> | $Enums.template_category
    template_category?: StringFilter<"InvitationTemplate"> | string
    filter?: StringNullableFilter<"InvitationTemplate"> | string | null
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
    paymentDetails?: PaymentDetailsListRelationFilter
    orderDetails?: OrderDetailsListRelationFilter
  }

  export type InvitationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrderInput | SortOrder
    template_type?: SortOrder
    template_category?: SortOrder
    filter?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    paymentDetails?: PaymentDetailsOrderByRelationAggregateInput
    orderDetails?: OrderDetailsOrderByRelationAggregateInput
  }

  export type InvitationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    name?: StringFilter<"InvitationTemplate"> | string
    imageUrl?: JsonFilter<"InvitationTemplate">
    price?: FloatNullableFilter<"InvitationTemplate"> | number | null
    template_type?: Enumtemplate_categoryFilter<"InvitationTemplate"> | $Enums.template_category
    template_category?: StringFilter<"InvitationTemplate"> | string
    filter?: StringNullableFilter<"InvitationTemplate"> | string | null
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
    paymentDetails?: PaymentDetailsListRelationFilter
    orderDetails?: OrderDetailsListRelationFilter
  }, "id">

  export type InvitationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrderInput | SortOrder
    template_type?: SortOrder
    template_category?: SortOrder
    filter?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvitationTemplateCountOrderByAggregateInput
    _avg?: InvitationTemplateAvgOrderByAggregateInput
    _max?: InvitationTemplateMaxOrderByAggregateInput
    _min?: InvitationTemplateMinOrderByAggregateInput
    _sum?: InvitationTemplateSumOrderByAggregateInput
  }

  export type InvitationTemplateScalarWhereWithAggregatesInput = {
    AND?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    OR?: InvitationTemplateScalarWhereWithAggregatesInput[]
    NOT?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    name?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    imageUrl?: JsonWithAggregatesFilter<"InvitationTemplate">
    price?: FloatNullableWithAggregatesFilter<"InvitationTemplate"> | number | null
    template_type?: Enumtemplate_categoryWithAggregatesFilter<"InvitationTemplate"> | $Enums.template_category
    template_category?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    filter?: StringNullableWithAggregatesFilter<"InvitationTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvitationTemplate"> | Date | string
  }

  export type UserDataTemplateWhereInput = {
    AND?: UserDataTemplateWhereInput | UserDataTemplateWhereInput[]
    OR?: UserDataTemplateWhereInput[]
    NOT?: UserDataTemplateWhereInput | UserDataTemplateWhereInput[]
    userId?: StringFilter<"UserDataTemplate"> | string
    template_id?: StringFilter<"UserDataTemplate"> | string
    eventHeading?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventSubheading?: StringNullableFilter<"UserDataTemplate"> | string | null
    brideName?: StringNullableFilter<"UserDataTemplate"> | string | null
    groomName?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventDate?: DateTimeFilter<"UserDataTemplate"> | Date | string
    weddingTime?: StringNullableFilter<"UserDataTemplate"> | string | null
    weddingLocation?: StringNullableFilter<"UserDataTemplate"> | string | null
    description?: StringNullableFilter<"UserDataTemplate"> | string | null
    createdAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserDataTemplateOrderByWithRelationInput = {
    userId?: SortOrder
    template_id?: SortOrder
    eventHeading?: SortOrderInput | SortOrder
    eventSubheading?: SortOrderInput | SortOrder
    brideName?: SortOrderInput | SortOrder
    groomName?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    weddingTime?: SortOrderInput | SortOrder
    weddingLocation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDataTemplateWhereUniqueInput = Prisma.AtLeast<{
    template_id?: string
    AND?: UserDataTemplateWhereInput | UserDataTemplateWhereInput[]
    OR?: UserDataTemplateWhereInput[]
    NOT?: UserDataTemplateWhereInput | UserDataTemplateWhereInput[]
    userId?: StringFilter<"UserDataTemplate"> | string
    eventHeading?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventSubheading?: StringNullableFilter<"UserDataTemplate"> | string | null
    brideName?: StringNullableFilter<"UserDataTemplate"> | string | null
    groomName?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventDate?: DateTimeFilter<"UserDataTemplate"> | Date | string
    weddingTime?: StringNullableFilter<"UserDataTemplate"> | string | null
    weddingLocation?: StringNullableFilter<"UserDataTemplate"> | string | null
    description?: StringNullableFilter<"UserDataTemplate"> | string | null
    createdAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "template_id">

  export type UserDataTemplateOrderByWithAggregationInput = {
    userId?: SortOrder
    template_id?: SortOrder
    eventHeading?: SortOrderInput | SortOrder
    eventSubheading?: SortOrderInput | SortOrder
    brideName?: SortOrderInput | SortOrder
    groomName?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    weddingTime?: SortOrderInput | SortOrder
    weddingLocation?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserDataTemplateCountOrderByAggregateInput
    _max?: UserDataTemplateMaxOrderByAggregateInput
    _min?: UserDataTemplateMinOrderByAggregateInput
  }

  export type UserDataTemplateScalarWhereWithAggregatesInput = {
    AND?: UserDataTemplateScalarWhereWithAggregatesInput | UserDataTemplateScalarWhereWithAggregatesInput[]
    OR?: UserDataTemplateScalarWhereWithAggregatesInput[]
    NOT?: UserDataTemplateScalarWhereWithAggregatesInput | UserDataTemplateScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserDataTemplate"> | string
    template_id?: StringWithAggregatesFilter<"UserDataTemplate"> | string
    eventHeading?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    eventSubheading?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    brideName?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    groomName?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    eventDate?: DateTimeWithAggregatesFilter<"UserDataTemplate"> | Date | string
    weddingTime?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    weddingLocation?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserDataTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserDataTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserDataTemplate"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    tags?: StringNullableListFilter<"Blog">
    content?: StringFilter<"Blog"> | string
    viewCount?: IntFilter<"Blog"> | number
    likes?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    authorId?: StringFilter<"Blog"> | string
    comments?: CommentListRelationFilter
    likedBy?: LikedBlogListRelationFilter
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    tags?: SortOrder
    content?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    likedBy?: LikedBlogOrderByRelationAggregateInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    tags?: StringNullableListFilter<"Blog">
    content?: StringFilter<"Blog"> | string
    viewCount?: IntFilter<"Blog"> | number
    likes?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    authorId?: StringFilter<"Blog"> | string
    comments?: CommentListRelationFilter
    likedBy?: LikedBlogListRelationFilter
  }, "id" | "title">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    tags?: SortOrder
    content?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blog"> | string
    title?: StringWithAggregatesFilter<"Blog"> | string
    tags?: StringNullableListFilter<"Blog">
    content?: StringWithAggregatesFilter<"Blog"> | string
    viewCount?: IntWithAggregatesFilter<"Blog"> | number
    likes?: IntWithAggregatesFilter<"Blog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    authorId?: StringWithAggregatesFilter<"Blog"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    blogId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blogId?: SortOrder
    authorId?: SortOrder
    blog?: BlogOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    blogId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blogId?: SortOrder
    authorId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    blogId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
  }

  export type LikedBlogWhereInput = {
    AND?: LikedBlogWhereInput | LikedBlogWhereInput[]
    OR?: LikedBlogWhereInput[]
    NOT?: LikedBlogWhereInput | LikedBlogWhereInput[]
    id?: StringFilter<"LikedBlog"> | string
    userId?: StringFilter<"LikedBlog"> | string
    blogId?: StringFilter<"LikedBlog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }

  export type LikedBlogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    user?: UserOrderByWithRelationInput
    blog?: BlogOrderByWithRelationInput
  }

  export type LikedBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_blogId?: LikedBlogUserIdBlogIdCompoundUniqueInput
    AND?: LikedBlogWhereInput | LikedBlogWhereInput[]
    OR?: LikedBlogWhereInput[]
    NOT?: LikedBlogWhereInput | LikedBlogWhereInput[]
    userId?: StringFilter<"LikedBlog"> | string
    blogId?: StringFilter<"LikedBlog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }, "id" | "userId_blogId">

  export type LikedBlogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    _count?: LikedBlogCountOrderByAggregateInput
    _max?: LikedBlogMaxOrderByAggregateInput
    _min?: LikedBlogMinOrderByAggregateInput
  }

  export type LikedBlogScalarWhereWithAggregatesInput = {
    AND?: LikedBlogScalarWhereWithAggregatesInput | LikedBlogScalarWhereWithAggregatesInput[]
    OR?: LikedBlogScalarWhereWithAggregatesInput[]
    NOT?: LikedBlogScalarWhereWithAggregatesInput | LikedBlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikedBlog"> | string
    userId?: StringWithAggregatesFilter<"LikedBlog"> | string
    blogId?: StringWithAggregatesFilter<"LikedBlog"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateInput = {
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
    userId: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id: string
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateInput = {
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id: string
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistCreateInput = {
    id?: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChecklistsInput
  }

  export type ChecklistUncheckedCreateInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type ChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistCreateManyInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventInput
    eventTask?: EventTaskCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsCreateNestedManyWithoutEventInput
    subEvent?: SubEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    userId: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventTask?: EventTaskUncheckedCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsUncheckedCreateNestedManyWithoutEventInput
    subEvent?: SubEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventNestedInput
    eventTask?: EventTaskUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTask?: EventTaskUncheckedUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUncheckedUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    userId: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsCreateInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutEventVendorsInput
  }

  export type EventVendorsUncheckedCreateInput = {
    id?: string
    eventId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type EventVendorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutEventVendorsNestedInput
  }

  export type EventVendorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsCreateManyInput = {
    id?: string
    eventId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type EventVendorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTaskCreateInput = {
    id?: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutEventTaskInput
  }

  export type EventTaskUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutEventTaskNestedInput
  }

  export type EventTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTaskCreateManyInput = {
    id?: string
    eventId: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventCreateInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSubEventInput
    subEventTask?: SubEventTaskCreateNestedManyWithoutSubEventInput
    subEventVendors?: SubEventVendorsCreateNestedManyWithoutSubEventInput
  }

  export type SubEventUncheckedCreateInput = {
    id?: string
    eventId: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subEventTask?: SubEventTaskUncheckedCreateNestedManyWithoutSubEventInput
    subEventVendors?: SubEventVendorsUncheckedCreateNestedManyWithoutSubEventInput
  }

  export type SubEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSubEventNestedInput
    subEventTask?: SubEventTaskUpdateManyWithoutSubEventNestedInput
    subEventVendors?: SubEventVendorsUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventTask?: SubEventTaskUncheckedUpdateManyWithoutSubEventNestedInput
    subEventVendors?: SubEventVendorsUncheckedUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventCreateManyInput = {
    id?: string
    eventId: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsCreateInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
    subEvent: SubEventCreateNestedOneWithoutSubEventVendorsInput
  }

  export type SubEventVendorsUncheckedCreateInput = {
    id?: string
    subEventId: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventVendorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEvent?: SubEventUpdateOneRequiredWithoutSubEventVendorsNestedInput
  }

  export type SubEventVendorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsCreateManyInput = {
    id?: string
    subEventId: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventVendorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskCreateInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subEvent: SubEventCreateNestedOneWithoutSubEventTaskInput
  }

  export type SubEventTaskUncheckedCreateInput = {
    id?: string
    userId: string
    subEventId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEvent?: SubEventUpdateOneRequiredWithoutSubEventTaskNestedInput
  }

  export type SubEventTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subEventId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskCreateManyInput = {
    id?: string
    userId: string
    subEventId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subEventId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDetailsCreateInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutOrderDetailsInput
    InvitationTemplate?: InvitationTemplateCreateNestedOneWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    templateId?: string | null
  }

  export type OrderDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    InvitationTemplate?: InvitationTemplateUpdateOneWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderDetailsCreateManyInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    templateId?: string | null
  }

  export type OrderDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsCreateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentDetailsInput
    InvitationTemplate?: InvitationTemplateCreateNestedOneWithoutPaymentDetailsInput
  }

  export type PaymentDetailsUncheckedCreateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    userId: string
    templateId?: string | null
  }

  export type PaymentDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentDetailsNestedInput
    InvitationTemplate?: InvitationTemplateUpdateOneWithoutPaymentDetailsNestedInput
  }

  export type PaymentDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsCreateManyInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    userId: string
    templateId?: string | null
  }

  export type PaymentDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateInput = {
    review_id?: string
    vendor_id: string
    rating: number
    review_text: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    review_id?: string
    vendor_id: string
    id: string
    rating: number
    review_text: string
    created_at?: Date | string
  }

  export type ReviewUpdateInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    review_id?: string
    vendor_id: string
    id: string
    rating: number
    review_text: string
    created_at?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventScheduleCreateInput = {
    event_id?: string
    vendor_id: string
    media_id: string
    event_name: string
    event_start_date: Date | string
    event_end_date: Date | string
    event_location: string
    description: string
    created_at?: Date | string
  }

  export type EventScheduleUncheckedCreateInput = {
    event_id?: string
    vendor_id: string
    media_id: string
    event_name: string
    event_start_date: Date | string
    event_end_date: Date | string
    event_location: string
    description: string
    created_at?: Date | string
  }

  export type EventScheduleUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    media_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventScheduleUncheckedUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    media_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventScheduleCreateManyInput = {
    event_id?: string
    vendor_id: string
    media_id: string
    event_name: string
    event_start_date: Date | string
    event_end_date: Date | string
    event_location: string
    description: string
    created_at?: Date | string
  }

  export type EventScheduleUpdateManyMutationInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    media_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventScheduleUncheckedUpdateManyInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    media_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestCreateInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuestsInput
  }

  export type GuestUncheckedCreateInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuestsNestedInput
  }

  export type GuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestCreateManyInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateCreateInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutInvitationTemplateInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateUncheckedCreateInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDetails?: PaymentDetailsUpdateManyWithoutInvitationTemplateNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type InvitationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type InvitationTemplateCreateManyInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
  }

  export type InvitationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDataTemplateCreateInput = {
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserDataTemplateInput
  }

  export type UserDataTemplateUncheckedCreateInput = {
    userId: string
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDataTemplateUpdateInput = {
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserDataTemplateNestedInput
  }

  export type UserDataTemplateUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDataTemplateCreateManyInput = {
    userId: string
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDataTemplateUpdateManyMutationInput = {
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDataTemplateUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    comments?: CommentCreateNestedManyWithoutBlogInput
    likedBy?: LikedBlogCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
    likedBy?: LikedBlogUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutBlogNestedInput
    likedBy?: LikedBlogUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
    likedBy?: LikedBlogUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogCreateManyInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    blog: BlogCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    blogId: string
    authorId: string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    blog?: BlogUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    blogId: string
    authorId: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutLikedBlogsInput
    blog: BlogCreateNestedOneWithoutLikedByInput
  }

  export type LikedBlogUncheckedCreateInput = {
    id?: string
    userId: string
    blogId: string
  }

  export type LikedBlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLikedBlogsNestedInput
    blog?: BlogUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedBlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogCreateManyInput = {
    id?: string
    userId: string
    blogId: string
  }

  export type LikedBlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type ChecklistListRelationFilter = {
    every?: ChecklistWhereInput
    some?: ChecklistWhereInput
    none?: ChecklistWhereInput
  }

  export type GuestListRelationFilter = {
    every?: GuestWhereInput
    some?: GuestWhereInput
    none?: GuestWhereInput
  }

  export type PaymentDetailsListRelationFilter = {
    every?: PaymentDetailsWhereInput
    some?: PaymentDetailsWhereInput
    none?: PaymentDetailsWhereInput
  }

  export type OrderDetailsListRelationFilter = {
    every?: OrderDetailsWhereInput
    some?: OrderDetailsWhereInput
    none?: OrderDetailsWhereInput
  }

  export type UserDataTemplateListRelationFilter = {
    every?: UserDataTemplateWhereInput
    some?: UserDataTemplateWhereInput
    none?: UserDataTemplateWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type LikedBlogListRelationFilter = {
    every?: LikedBlogWhereInput
    some?: LikedBlogWhereInput
    none?: LikedBlogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDataTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikedBlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    refresh_Token?: SortOrder
    password_hash?: SortOrder
    googleUid?: SortOrder
    resetPassword_Token?: SortOrder
    profile_photo?: SortOrder
    user_name?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    wedding_date?: SortOrder
    wedding_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    refresh_Token?: SortOrder
    password_hash?: SortOrder
    googleUid?: SortOrder
    resetPassword_Token?: SortOrder
    profile_photo?: SortOrder
    user_name?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    wedding_date?: SortOrder
    wedding_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    refresh_Token?: SortOrder
    password_hash?: SortOrder
    googleUid?: SortOrder
    resetPassword_Token?: SortOrder
    profile_photo?: SortOrder
    user_name?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    wedding_date?: SortOrder
    wedding_location?: SortOrder
    created_at?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    service_id?: SortOrder
    vendor_id?: SortOrder
    booking_date?: SortOrder
    status?: SortOrder
    negotiated_price?: SortOrder
    is_negotiable?: SortOrder
    totalAmount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    negotiated_price?: SortOrder
    totalAmount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    service_id?: SortOrder
    vendor_id?: SortOrder
    booking_date?: SortOrder
    status?: SortOrder
    negotiated_price?: SortOrder
    is_negotiable?: SortOrder
    totalAmount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    service_id?: SortOrder
    vendor_id?: SortOrder
    booking_date?: SortOrder
    status?: SortOrder
    negotiated_price?: SortOrder
    is_negotiable?: SortOrder
    totalAmount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    negotiated_price?: SortOrder
    totalAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CartUserIdServiceIdCompoundUniqueInput = {
    userId: string
    serviceId: string
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EventTaskListRelationFilter = {
    every?: EventTaskWhereInput
    some?: EventTaskWhereInput
    none?: EventTaskWhereInput
  }

  export type EventVendorsListRelationFilter = {
    every?: EventVendorsWhereInput
    some?: EventVendorsWhereInput
    none?: EventVendorsWhereInput
  }

  export type SubEventListRelationFilter = {
    every?: SubEventWhereInput
    some?: SubEventWhereInput
    none?: SubEventWhereInput
  }

  export type EventTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventVendorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventDate?: SortOrder
    eventStartTime?: SortOrder
    eventEndTime?: SortOrder
    eventBudget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    eventBudget?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventDate?: SortOrder
    eventStartTime?: SortOrder
    eventEndTime?: SortOrder
    eventBudget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventDate?: SortOrder
    eventStartTime?: SortOrder
    eventEndTime?: SortOrder
    eventBudget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    eventBudget?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventVendorsEventIdServiceIdCompoundUniqueInput = {
    eventId: string
    serviceId: string
  }

  export type EventVendorsCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventVendorsMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventVendorsMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventTaskCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    done?: SortOrder
    scheduleDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    done?: SortOrder
    scheduleDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventTaskMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    done?: SortOrder
    scheduleDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventTaskListRelationFilter = {
    every?: SubEventTaskWhereInput
    some?: SubEventTaskWhereInput
    none?: SubEventTaskWhereInput
  }

  export type SubEventVendorsListRelationFilter = {
    every?: SubEventVendorsWhereInput
    some?: SubEventVendorsWhereInput
    none?: SubEventVendorsWhereInput
  }

  export type SubEventTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubEventVendorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subEventName?: SortOrder
    subEventDescription?: SortOrder
    subEventBudget?: SortOrder
    subEventDate?: SortOrder
    subEventStartTime?: SortOrder
    subEventEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventAvgOrderByAggregateInput = {
    subEventBudget?: SortOrder
  }

  export type SubEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subEventName?: SortOrder
    subEventDescription?: SortOrder
    subEventBudget?: SortOrder
    subEventDate?: SortOrder
    subEventStartTime?: SortOrder
    subEventEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subEventName?: SortOrder
    subEventDescription?: SortOrder
    subEventBudget?: SortOrder
    subEventDate?: SortOrder
    subEventStartTime?: SortOrder
    subEventEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventSumOrderByAggregateInput = {
    subEventBudget?: SortOrder
  }

  export type SubEventScalarRelationFilter = {
    is?: SubEventWhereInput
    isNot?: SubEventWhereInput
  }

  export type SubEventVendorsSubEventIdServiceIdCompoundUniqueInput = {
    subEventId: string
    serviceId: string
  }

  export type SubEventVendorsCountOrderByAggregateInput = {
    id?: SortOrder
    subEventId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubEventVendorsMaxOrderByAggregateInput = {
    id?: SortOrder
    subEventId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubEventVendorsMinOrderByAggregateInput = {
    id?: SortOrder
    subEventId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubEventTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subEventId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubEventTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationTemplateNullableScalarRelationFilter = {
    is?: InvitationTemplateWhereInput | null
    isNot?: InvitationTemplateWhereInput | null
  }

  export type OrderDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    razorpayResponse?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type OrderDetailsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type OrderDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type OrderDetailsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    razorpayResponse?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type PaymentDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type PaymentDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    status?: SortOrder
    purchasedAt?: SortOrder
    userId?: SortOrder
    templateId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ReviewCountOrderByAggregateInput = {
    review_id?: SortOrder
    vendor_id?: SortOrder
    id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    review_id?: SortOrder
    vendor_id?: SortOrder
    id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    review_id?: SortOrder
    vendor_id?: SortOrder
    id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EventScheduleCountOrderByAggregateInput = {
    event_id?: SortOrder
    vendor_id?: SortOrder
    media_id?: SortOrder
    event_name?: SortOrder
    event_start_date?: SortOrder
    event_end_date?: SortOrder
    event_location?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EventScheduleMaxOrderByAggregateInput = {
    event_id?: SortOrder
    vendor_id?: SortOrder
    media_id?: SortOrder
    event_name?: SortOrder
    event_start_date?: SortOrder
    event_end_date?: SortOrder
    event_location?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EventScheduleMinOrderByAggregateInput = {
    event_id?: SortOrder
    vendor_id?: SortOrder
    media_id?: SortOrder
    event_name?: SortOrder
    event_start_date?: SortOrder
    event_end_date?: SortOrder
    event_location?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EnumGuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuestStatus | EnumGuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuestStatusFilter<$PrismaModel> | $Enums.GuestStatus
  }

  export type GuestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuestStatus | EnumGuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuestStatusFilter<$PrismaModel>
    _max?: NestedEnumGuestStatusFilter<$PrismaModel>
  }

  export type Enumtemplate_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.template_category | Enumtemplate_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    not?: NestedEnumtemplate_categoryFilter<$PrismaModel> | $Enums.template_category
  }

  export type InvitationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    template_type?: SortOrder
    template_category?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type InvitationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    template_type?: SortOrder
    template_category?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    template_type?: SortOrder
    template_category?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type Enumtemplate_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.template_category | Enumtemplate_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    not?: NestedEnumtemplate_categoryWithAggregatesFilter<$PrismaModel> | $Enums.template_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtemplate_categoryFilter<$PrismaModel>
    _max?: NestedEnumtemplate_categoryFilter<$PrismaModel>
  }

  export type UserDataTemplateCountOrderByAggregateInput = {
    userId?: SortOrder
    template_id?: SortOrder
    eventHeading?: SortOrder
    eventSubheading?: SortOrder
    brideName?: SortOrder
    groomName?: SortOrder
    eventDate?: SortOrder
    weddingTime?: SortOrder
    weddingLocation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDataTemplateMaxOrderByAggregateInput = {
    userId?: SortOrder
    template_id?: SortOrder
    eventHeading?: SortOrder
    eventSubheading?: SortOrder
    brideName?: SortOrder
    groomName?: SortOrder
    eventDate?: SortOrder
    weddingTime?: SortOrder
    weddingLocation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDataTemplateMinOrderByAggregateInput = {
    userId?: SortOrder
    template_id?: SortOrder
    eventHeading?: SortOrder
    eventSubheading?: SortOrder
    brideName?: SortOrder
    groomName?: SortOrder
    eventDate?: SortOrder
    weddingTime?: SortOrder
    weddingLocation?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    tags?: SortOrder
    content?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    likes?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    viewCount?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    viewCount?: SortOrder
    likes?: SortOrder
  }

  export type BlogScalarRelationFilter = {
    is?: BlogWhereInput
    isNot?: BlogWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blogId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blogId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blogId?: SortOrder
    authorId?: SortOrder
  }

  export type LikedBlogUserIdBlogIdCompoundUniqueInput = {
    userId: string
    blogId: string
  }

  export type LikedBlogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
  }

  export type LikedBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
  }

  export type LikedBlogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
  }

  export type BookingCreateNestedManyWithoutUserIdInput = {
    create?: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput> | BookingCreateWithoutUserIdInput[] | BookingUncheckedCreateWithoutUserIdInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserIdInput | BookingCreateOrConnectWithoutUserIdInput[]
    createMany?: BookingCreateManyUserIdInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type ChecklistCreateNestedManyWithoutUserInput = {
    create?: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput> | ChecklistCreateWithoutUserInput[] | ChecklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChecklistCreateOrConnectWithoutUserInput | ChecklistCreateOrConnectWithoutUserInput[]
    createMany?: ChecklistCreateManyUserInputEnvelope
    connect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
  }

  export type GuestCreateNestedManyWithoutUserInput = {
    create?: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput> | GuestCreateWithoutUserInput[] | GuestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuestCreateOrConnectWithoutUserInput | GuestCreateOrConnectWithoutUserInput[]
    createMany?: GuestCreateManyUserInputEnvelope
    connect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
  }

  export type PaymentDetailsCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput> | PaymentDetailsCreateWithoutUserInput[] | PaymentDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutUserInput | PaymentDetailsCreateOrConnectWithoutUserInput[]
    createMany?: PaymentDetailsCreateManyUserInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type OrderDetailsCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type UserDataTemplateCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput> | UserDataTemplateCreateWithoutUserInput[] | UserDataTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDataTemplateCreateOrConnectWithoutUserInput | UserDataTemplateCreateOrConnectWithoutUserInput[]
    createMany?: UserDataTemplateCreateManyUserInputEnvelope
    connect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type LikedBlogCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput> | LikedBlogCreateWithoutUserInput[] | LikedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutUserInput | LikedBlogCreateOrConnectWithoutUserInput[]
    createMany?: LikedBlogCreateManyUserInputEnvelope
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserIdInput = {
    create?: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput> | BookingCreateWithoutUserIdInput[] | BookingUncheckedCreateWithoutUserIdInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserIdInput | BookingCreateOrConnectWithoutUserIdInput[]
    createMany?: BookingCreateManyUserIdInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type ChecklistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput> | ChecklistCreateWithoutUserInput[] | ChecklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChecklistCreateOrConnectWithoutUserInput | ChecklistCreateOrConnectWithoutUserInput[]
    createMany?: ChecklistCreateManyUserInputEnvelope
    connect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
  }

  export type GuestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput> | GuestCreateWithoutUserInput[] | GuestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuestCreateOrConnectWithoutUserInput | GuestCreateOrConnectWithoutUserInput[]
    createMany?: GuestCreateManyUserInputEnvelope
    connect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
  }

  export type PaymentDetailsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput> | PaymentDetailsCreateWithoutUserInput[] | PaymentDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutUserInput | PaymentDetailsCreateOrConnectWithoutUserInput[]
    createMany?: PaymentDetailsCreateManyUserInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type OrderDetailsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type UserDataTemplateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput> | UserDataTemplateCreateWithoutUserInput[] | UserDataTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDataTemplateCreateOrConnectWithoutUserInput | UserDataTemplateCreateOrConnectWithoutUserInput[]
    createMany?: UserDataTemplateCreateManyUserInputEnvelope
    connect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type LikedBlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput> | LikedBlogCreateWithoutUserInput[] | LikedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutUserInput | LikedBlogCreateOrConnectWithoutUserInput[]
    createMany?: LikedBlogCreateManyUserInputEnvelope
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BookingUpdateManyWithoutUserIdNestedInput = {
    create?: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput> | BookingCreateWithoutUserIdInput[] | BookingUncheckedCreateWithoutUserIdInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserIdInput | BookingCreateOrConnectWithoutUserIdInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserIdInput | BookingUpsertWithWhereUniqueWithoutUserIdInput[]
    createMany?: BookingCreateManyUserIdInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserIdInput | BookingUpdateWithWhereUniqueWithoutUserIdInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserIdInput | BookingUpdateManyWithWhereWithoutUserIdInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type ChecklistUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput> | ChecklistCreateWithoutUserInput[] | ChecklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChecklistCreateOrConnectWithoutUserInput | ChecklistCreateOrConnectWithoutUserInput[]
    upsert?: ChecklistUpsertWithWhereUniqueWithoutUserInput | ChecklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChecklistCreateManyUserInputEnvelope
    set?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    disconnect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    delete?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    connect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    update?: ChecklistUpdateWithWhereUniqueWithoutUserInput | ChecklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChecklistUpdateManyWithWhereWithoutUserInput | ChecklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChecklistScalarWhereInput | ChecklistScalarWhereInput[]
  }

  export type GuestUpdateManyWithoutUserNestedInput = {
    create?: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput> | GuestCreateWithoutUserInput[] | GuestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuestCreateOrConnectWithoutUserInput | GuestCreateOrConnectWithoutUserInput[]
    upsert?: GuestUpsertWithWhereUniqueWithoutUserInput | GuestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GuestCreateManyUserInputEnvelope
    set?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    disconnect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    delete?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    connect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    update?: GuestUpdateWithWhereUniqueWithoutUserInput | GuestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GuestUpdateManyWithWhereWithoutUserInput | GuestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GuestScalarWhereInput | GuestScalarWhereInput[]
  }

  export type PaymentDetailsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput> | PaymentDetailsCreateWithoutUserInput[] | PaymentDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutUserInput | PaymentDetailsCreateOrConnectWithoutUserInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutUserInput | PaymentDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentDetailsCreateManyUserInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutUserInput | PaymentDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutUserInput | PaymentDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type OrderDetailsUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserInput | OrderDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserInput | OrderDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserInput | OrderDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type UserDataTemplateUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput> | UserDataTemplateCreateWithoutUserInput[] | UserDataTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDataTemplateCreateOrConnectWithoutUserInput | UserDataTemplateCreateOrConnectWithoutUserInput[]
    upsert?: UserDataTemplateUpsertWithWhereUniqueWithoutUserInput | UserDataTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDataTemplateCreateManyUserInputEnvelope
    set?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    disconnect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    delete?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    connect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    update?: UserDataTemplateUpdateWithWhereUniqueWithoutUserInput | UserDataTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDataTemplateUpdateManyWithWhereWithoutUserInput | UserDataTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDataTemplateScalarWhereInput | UserDataTemplateScalarWhereInput[]
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type LikedBlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput> | LikedBlogCreateWithoutUserInput[] | LikedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutUserInput | LikedBlogCreateOrConnectWithoutUserInput[]
    upsert?: LikedBlogUpsertWithWhereUniqueWithoutUserInput | LikedBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedBlogCreateManyUserInputEnvelope
    set?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    disconnect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    delete?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    update?: LikedBlogUpdateWithWhereUniqueWithoutUserInput | LikedBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedBlogUpdateManyWithWhereWithoutUserInput | LikedBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserIdNestedInput = {
    create?: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput> | BookingCreateWithoutUserIdInput[] | BookingUncheckedCreateWithoutUserIdInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserIdInput | BookingCreateOrConnectWithoutUserIdInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserIdInput | BookingUpsertWithWhereUniqueWithoutUserIdInput[]
    createMany?: BookingCreateManyUserIdInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserIdInput | BookingUpdateWithWhereUniqueWithoutUserIdInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserIdInput | BookingUpdateManyWithWhereWithoutUserIdInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type ChecklistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput> | ChecklistCreateWithoutUserInput[] | ChecklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChecklistCreateOrConnectWithoutUserInput | ChecklistCreateOrConnectWithoutUserInput[]
    upsert?: ChecklistUpsertWithWhereUniqueWithoutUserInput | ChecklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChecklistCreateManyUserInputEnvelope
    set?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    disconnect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    delete?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    connect?: ChecklistWhereUniqueInput | ChecklistWhereUniqueInput[]
    update?: ChecklistUpdateWithWhereUniqueWithoutUserInput | ChecklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChecklistUpdateManyWithWhereWithoutUserInput | ChecklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChecklistScalarWhereInput | ChecklistScalarWhereInput[]
  }

  export type GuestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput> | GuestCreateWithoutUserInput[] | GuestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GuestCreateOrConnectWithoutUserInput | GuestCreateOrConnectWithoutUserInput[]
    upsert?: GuestUpsertWithWhereUniqueWithoutUserInput | GuestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GuestCreateManyUserInputEnvelope
    set?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    disconnect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    delete?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    connect?: GuestWhereUniqueInput | GuestWhereUniqueInput[]
    update?: GuestUpdateWithWhereUniqueWithoutUserInput | GuestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GuestUpdateManyWithWhereWithoutUserInput | GuestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GuestScalarWhereInput | GuestScalarWhereInput[]
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput> | PaymentDetailsCreateWithoutUserInput[] | PaymentDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutUserInput | PaymentDetailsCreateOrConnectWithoutUserInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutUserInput | PaymentDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentDetailsCreateManyUserInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutUserInput | PaymentDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutUserInput | PaymentDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserInput | OrderDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserInput | OrderDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserInput | OrderDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput> | UserDataTemplateCreateWithoutUserInput[] | UserDataTemplateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDataTemplateCreateOrConnectWithoutUserInput | UserDataTemplateCreateOrConnectWithoutUserInput[]
    upsert?: UserDataTemplateUpsertWithWhereUniqueWithoutUserInput | UserDataTemplateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDataTemplateCreateManyUserInputEnvelope
    set?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    disconnect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    delete?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    connect?: UserDataTemplateWhereUniqueInput | UserDataTemplateWhereUniqueInput[]
    update?: UserDataTemplateUpdateWithWhereUniqueWithoutUserInput | UserDataTemplateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDataTemplateUpdateManyWithWhereWithoutUserInput | UserDataTemplateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDataTemplateScalarWhereInput | UserDataTemplateScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type LikedBlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput> | LikedBlogCreateWithoutUserInput[] | LikedBlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutUserInput | LikedBlogCreateOrConnectWithoutUserInput[]
    upsert?: LikedBlogUpsertWithWhereUniqueWithoutUserInput | LikedBlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedBlogCreateManyUserInputEnvelope
    set?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    disconnect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    delete?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    update?: LikedBlogUpdateWithWhereUniqueWithoutUserInput | LikedBlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedBlogUpdateManyWithWhereWithoutUserInput | LikedBlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<UserCreateWithoutChecklistsInput, UserUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChecklistsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<UserCreateWithoutChecklistsInput, UserUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChecklistsInput
    upsert?: UserUpsertWithoutChecklistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChecklistsInput, UserUpdateWithoutChecklistsInput>, UserUncheckedUpdateWithoutChecklistsInput>
  }

  export type UserCreateNestedOneWithoutEventInput = {
    create?: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventInput
    connect?: UserWhereUniqueInput
  }

  export type EventTaskCreateNestedManyWithoutEventInput = {
    create?: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput> | EventTaskCreateWithoutEventInput[] | EventTaskUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTaskCreateOrConnectWithoutEventInput | EventTaskCreateOrConnectWithoutEventInput[]
    createMany?: EventTaskCreateManyEventInputEnvelope
    connect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
  }

  export type EventVendorsCreateNestedManyWithoutEventInput = {
    create?: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput> | EventVendorsCreateWithoutEventInput[] | EventVendorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventVendorsCreateOrConnectWithoutEventInput | EventVendorsCreateOrConnectWithoutEventInput[]
    createMany?: EventVendorsCreateManyEventInputEnvelope
    connect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
  }

  export type SubEventCreateNestedManyWithoutEventInput = {
    create?: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput> | SubEventCreateWithoutEventInput[] | SubEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SubEventCreateOrConnectWithoutEventInput | SubEventCreateOrConnectWithoutEventInput[]
    createMany?: SubEventCreateManyEventInputEnvelope
    connect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
  }

  export type EventTaskUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput> | EventTaskCreateWithoutEventInput[] | EventTaskUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTaskCreateOrConnectWithoutEventInput | EventTaskCreateOrConnectWithoutEventInput[]
    createMany?: EventTaskCreateManyEventInputEnvelope
    connect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
  }

  export type EventVendorsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput> | EventVendorsCreateWithoutEventInput[] | EventVendorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventVendorsCreateOrConnectWithoutEventInput | EventVendorsCreateOrConnectWithoutEventInput[]
    createMany?: EventVendorsCreateManyEventInputEnvelope
    connect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
  }

  export type SubEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput> | SubEventCreateWithoutEventInput[] | SubEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SubEventCreateOrConnectWithoutEventInput | SubEventCreateOrConnectWithoutEventInput[]
    createMany?: SubEventCreateManyEventInputEnvelope
    connect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventInput
    upsert?: UserUpsertWithoutEventInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventInput, UserUpdateWithoutEventInput>, UserUncheckedUpdateWithoutEventInput>
  }

  export type EventTaskUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput> | EventTaskCreateWithoutEventInput[] | EventTaskUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTaskCreateOrConnectWithoutEventInput | EventTaskCreateOrConnectWithoutEventInput[]
    upsert?: EventTaskUpsertWithWhereUniqueWithoutEventInput | EventTaskUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventTaskCreateManyEventInputEnvelope
    set?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    disconnect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    delete?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    connect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    update?: EventTaskUpdateWithWhereUniqueWithoutEventInput | EventTaskUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventTaskUpdateManyWithWhereWithoutEventInput | EventTaskUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventTaskScalarWhereInput | EventTaskScalarWhereInput[]
  }

  export type EventVendorsUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput> | EventVendorsCreateWithoutEventInput[] | EventVendorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventVendorsCreateOrConnectWithoutEventInput | EventVendorsCreateOrConnectWithoutEventInput[]
    upsert?: EventVendorsUpsertWithWhereUniqueWithoutEventInput | EventVendorsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventVendorsCreateManyEventInputEnvelope
    set?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    disconnect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    delete?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    connect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    update?: EventVendorsUpdateWithWhereUniqueWithoutEventInput | EventVendorsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventVendorsUpdateManyWithWhereWithoutEventInput | EventVendorsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventVendorsScalarWhereInput | EventVendorsScalarWhereInput[]
  }

  export type SubEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput> | SubEventCreateWithoutEventInput[] | SubEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SubEventCreateOrConnectWithoutEventInput | SubEventCreateOrConnectWithoutEventInput[]
    upsert?: SubEventUpsertWithWhereUniqueWithoutEventInput | SubEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SubEventCreateManyEventInputEnvelope
    set?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    disconnect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    delete?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    connect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    update?: SubEventUpdateWithWhereUniqueWithoutEventInput | SubEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SubEventUpdateManyWithWhereWithoutEventInput | SubEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SubEventScalarWhereInput | SubEventScalarWhereInput[]
  }

  export type EventTaskUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput> | EventTaskCreateWithoutEventInput[] | EventTaskUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventTaskCreateOrConnectWithoutEventInput | EventTaskCreateOrConnectWithoutEventInput[]
    upsert?: EventTaskUpsertWithWhereUniqueWithoutEventInput | EventTaskUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventTaskCreateManyEventInputEnvelope
    set?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    disconnect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    delete?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    connect?: EventTaskWhereUniqueInput | EventTaskWhereUniqueInput[]
    update?: EventTaskUpdateWithWhereUniqueWithoutEventInput | EventTaskUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventTaskUpdateManyWithWhereWithoutEventInput | EventTaskUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventTaskScalarWhereInput | EventTaskScalarWhereInput[]
  }

  export type EventVendorsUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput> | EventVendorsCreateWithoutEventInput[] | EventVendorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventVendorsCreateOrConnectWithoutEventInput | EventVendorsCreateOrConnectWithoutEventInput[]
    upsert?: EventVendorsUpsertWithWhereUniqueWithoutEventInput | EventVendorsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventVendorsCreateManyEventInputEnvelope
    set?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    disconnect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    delete?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    connect?: EventVendorsWhereUniqueInput | EventVendorsWhereUniqueInput[]
    update?: EventVendorsUpdateWithWhereUniqueWithoutEventInput | EventVendorsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventVendorsUpdateManyWithWhereWithoutEventInput | EventVendorsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventVendorsScalarWhereInput | EventVendorsScalarWhereInput[]
  }

  export type SubEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput> | SubEventCreateWithoutEventInput[] | SubEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SubEventCreateOrConnectWithoutEventInput | SubEventCreateOrConnectWithoutEventInput[]
    upsert?: SubEventUpsertWithWhereUniqueWithoutEventInput | SubEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SubEventCreateManyEventInputEnvelope
    set?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    disconnect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    delete?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    connect?: SubEventWhereUniqueInput | SubEventWhereUniqueInput[]
    update?: SubEventUpdateWithWhereUniqueWithoutEventInput | SubEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SubEventUpdateManyWithWhereWithoutEventInput | SubEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SubEventScalarWhereInput | SubEventScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutEventVendorsInput = {
    create?: XOR<EventCreateWithoutEventVendorsInput, EventUncheckedCreateWithoutEventVendorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventVendorsInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventVendorsNestedInput = {
    create?: XOR<EventCreateWithoutEventVendorsInput, EventUncheckedCreateWithoutEventVendorsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventVendorsInput
    upsert?: EventUpsertWithoutEventVendorsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventVendorsInput, EventUpdateWithoutEventVendorsInput>, EventUncheckedUpdateWithoutEventVendorsInput>
  }

  export type EventCreateNestedOneWithoutEventTaskInput = {
    create?: XOR<EventCreateWithoutEventTaskInput, EventUncheckedCreateWithoutEventTaskInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventTaskInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventTaskNestedInput = {
    create?: XOR<EventCreateWithoutEventTaskInput, EventUncheckedCreateWithoutEventTaskInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventTaskInput
    upsert?: EventUpsertWithoutEventTaskInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventTaskInput, EventUpdateWithoutEventTaskInput>, EventUncheckedUpdateWithoutEventTaskInput>
  }

  export type EventCreateNestedOneWithoutSubEventInput = {
    create?: XOR<EventCreateWithoutSubEventInput, EventUncheckedCreateWithoutSubEventInput>
    connectOrCreate?: EventCreateOrConnectWithoutSubEventInput
    connect?: EventWhereUniqueInput
  }

  export type SubEventTaskCreateNestedManyWithoutSubEventInput = {
    create?: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput> | SubEventTaskCreateWithoutSubEventInput[] | SubEventTaskUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventTaskCreateOrConnectWithoutSubEventInput | SubEventTaskCreateOrConnectWithoutSubEventInput[]
    createMany?: SubEventTaskCreateManySubEventInputEnvelope
    connect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
  }

  export type SubEventVendorsCreateNestedManyWithoutSubEventInput = {
    create?: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput> | SubEventVendorsCreateWithoutSubEventInput[] | SubEventVendorsUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventVendorsCreateOrConnectWithoutSubEventInput | SubEventVendorsCreateOrConnectWithoutSubEventInput[]
    createMany?: SubEventVendorsCreateManySubEventInputEnvelope
    connect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
  }

  export type SubEventTaskUncheckedCreateNestedManyWithoutSubEventInput = {
    create?: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput> | SubEventTaskCreateWithoutSubEventInput[] | SubEventTaskUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventTaskCreateOrConnectWithoutSubEventInput | SubEventTaskCreateOrConnectWithoutSubEventInput[]
    createMany?: SubEventTaskCreateManySubEventInputEnvelope
    connect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
  }

  export type SubEventVendorsUncheckedCreateNestedManyWithoutSubEventInput = {
    create?: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput> | SubEventVendorsCreateWithoutSubEventInput[] | SubEventVendorsUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventVendorsCreateOrConnectWithoutSubEventInput | SubEventVendorsCreateOrConnectWithoutSubEventInput[]
    createMany?: SubEventVendorsCreateManySubEventInputEnvelope
    connect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
  }

  export type EventUpdateOneRequiredWithoutSubEventNestedInput = {
    create?: XOR<EventCreateWithoutSubEventInput, EventUncheckedCreateWithoutSubEventInput>
    connectOrCreate?: EventCreateOrConnectWithoutSubEventInput
    upsert?: EventUpsertWithoutSubEventInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutSubEventInput, EventUpdateWithoutSubEventInput>, EventUncheckedUpdateWithoutSubEventInput>
  }

  export type SubEventTaskUpdateManyWithoutSubEventNestedInput = {
    create?: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput> | SubEventTaskCreateWithoutSubEventInput[] | SubEventTaskUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventTaskCreateOrConnectWithoutSubEventInput | SubEventTaskCreateOrConnectWithoutSubEventInput[]
    upsert?: SubEventTaskUpsertWithWhereUniqueWithoutSubEventInput | SubEventTaskUpsertWithWhereUniqueWithoutSubEventInput[]
    createMany?: SubEventTaskCreateManySubEventInputEnvelope
    set?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    disconnect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    delete?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    connect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    update?: SubEventTaskUpdateWithWhereUniqueWithoutSubEventInput | SubEventTaskUpdateWithWhereUniqueWithoutSubEventInput[]
    updateMany?: SubEventTaskUpdateManyWithWhereWithoutSubEventInput | SubEventTaskUpdateManyWithWhereWithoutSubEventInput[]
    deleteMany?: SubEventTaskScalarWhereInput | SubEventTaskScalarWhereInput[]
  }

  export type SubEventVendorsUpdateManyWithoutSubEventNestedInput = {
    create?: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput> | SubEventVendorsCreateWithoutSubEventInput[] | SubEventVendorsUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventVendorsCreateOrConnectWithoutSubEventInput | SubEventVendorsCreateOrConnectWithoutSubEventInput[]
    upsert?: SubEventVendorsUpsertWithWhereUniqueWithoutSubEventInput | SubEventVendorsUpsertWithWhereUniqueWithoutSubEventInput[]
    createMany?: SubEventVendorsCreateManySubEventInputEnvelope
    set?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    disconnect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    delete?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    connect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    update?: SubEventVendorsUpdateWithWhereUniqueWithoutSubEventInput | SubEventVendorsUpdateWithWhereUniqueWithoutSubEventInput[]
    updateMany?: SubEventVendorsUpdateManyWithWhereWithoutSubEventInput | SubEventVendorsUpdateManyWithWhereWithoutSubEventInput[]
    deleteMany?: SubEventVendorsScalarWhereInput | SubEventVendorsScalarWhereInput[]
  }

  export type SubEventTaskUncheckedUpdateManyWithoutSubEventNestedInput = {
    create?: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput> | SubEventTaskCreateWithoutSubEventInput[] | SubEventTaskUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventTaskCreateOrConnectWithoutSubEventInput | SubEventTaskCreateOrConnectWithoutSubEventInput[]
    upsert?: SubEventTaskUpsertWithWhereUniqueWithoutSubEventInput | SubEventTaskUpsertWithWhereUniqueWithoutSubEventInput[]
    createMany?: SubEventTaskCreateManySubEventInputEnvelope
    set?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    disconnect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    delete?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    connect?: SubEventTaskWhereUniqueInput | SubEventTaskWhereUniqueInput[]
    update?: SubEventTaskUpdateWithWhereUniqueWithoutSubEventInput | SubEventTaskUpdateWithWhereUniqueWithoutSubEventInput[]
    updateMany?: SubEventTaskUpdateManyWithWhereWithoutSubEventInput | SubEventTaskUpdateManyWithWhereWithoutSubEventInput[]
    deleteMany?: SubEventTaskScalarWhereInput | SubEventTaskScalarWhereInput[]
  }

  export type SubEventVendorsUncheckedUpdateManyWithoutSubEventNestedInput = {
    create?: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput> | SubEventVendorsCreateWithoutSubEventInput[] | SubEventVendorsUncheckedCreateWithoutSubEventInput[]
    connectOrCreate?: SubEventVendorsCreateOrConnectWithoutSubEventInput | SubEventVendorsCreateOrConnectWithoutSubEventInput[]
    upsert?: SubEventVendorsUpsertWithWhereUniqueWithoutSubEventInput | SubEventVendorsUpsertWithWhereUniqueWithoutSubEventInput[]
    createMany?: SubEventVendorsCreateManySubEventInputEnvelope
    set?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    disconnect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    delete?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    connect?: SubEventVendorsWhereUniqueInput | SubEventVendorsWhereUniqueInput[]
    update?: SubEventVendorsUpdateWithWhereUniqueWithoutSubEventInput | SubEventVendorsUpdateWithWhereUniqueWithoutSubEventInput[]
    updateMany?: SubEventVendorsUpdateManyWithWhereWithoutSubEventInput | SubEventVendorsUpdateManyWithWhereWithoutSubEventInput[]
    deleteMany?: SubEventVendorsScalarWhereInput | SubEventVendorsScalarWhereInput[]
  }

  export type SubEventCreateNestedOneWithoutSubEventVendorsInput = {
    create?: XOR<SubEventCreateWithoutSubEventVendorsInput, SubEventUncheckedCreateWithoutSubEventVendorsInput>
    connectOrCreate?: SubEventCreateOrConnectWithoutSubEventVendorsInput
    connect?: SubEventWhereUniqueInput
  }

  export type SubEventUpdateOneRequiredWithoutSubEventVendorsNestedInput = {
    create?: XOR<SubEventCreateWithoutSubEventVendorsInput, SubEventUncheckedCreateWithoutSubEventVendorsInput>
    connectOrCreate?: SubEventCreateOrConnectWithoutSubEventVendorsInput
    upsert?: SubEventUpsertWithoutSubEventVendorsInput
    connect?: SubEventWhereUniqueInput
    update?: XOR<XOR<SubEventUpdateToOneWithWhereWithoutSubEventVendorsInput, SubEventUpdateWithoutSubEventVendorsInput>, SubEventUncheckedUpdateWithoutSubEventVendorsInput>
  }

  export type SubEventCreateNestedOneWithoutSubEventTaskInput = {
    create?: XOR<SubEventCreateWithoutSubEventTaskInput, SubEventUncheckedCreateWithoutSubEventTaskInput>
    connectOrCreate?: SubEventCreateOrConnectWithoutSubEventTaskInput
    connect?: SubEventWhereUniqueInput
  }

  export type SubEventUpdateOneRequiredWithoutSubEventTaskNestedInput = {
    create?: XOR<SubEventCreateWithoutSubEventTaskInput, SubEventUncheckedCreateWithoutSubEventTaskInput>
    connectOrCreate?: SubEventCreateOrConnectWithoutSubEventTaskInput
    upsert?: SubEventUpsertWithoutSubEventTaskInput
    connect?: SubEventWhereUniqueInput
    update?: XOR<XOR<SubEventUpdateToOneWithWhereWithoutSubEventTaskInput, SubEventUpdateWithoutSubEventTaskInput>, SubEventUncheckedUpdateWithoutSubEventTaskInput>
  }

  export type UserCreateNestedOneWithoutOrderDetailsInput = {
    create?: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationTemplateCreateNestedOneWithoutOrderDetailsInput = {
    create?: XOR<InvitationTemplateCreateWithoutOrderDetailsInput, InvitationTemplateUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutOrderDetailsInput
    connect?: InvitationTemplateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrderDetailsNestedInput = {
    create?: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderDetailsInput
    upsert?: UserUpsertWithoutOrderDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderDetailsInput, UserUpdateWithoutOrderDetailsInput>, UserUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type InvitationTemplateUpdateOneWithoutOrderDetailsNestedInput = {
    create?: XOR<InvitationTemplateCreateWithoutOrderDetailsInput, InvitationTemplateUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutOrderDetailsInput
    upsert?: InvitationTemplateUpsertWithoutOrderDetailsInput
    disconnect?: InvitationTemplateWhereInput | boolean
    delete?: InvitationTemplateWhereInput | boolean
    connect?: InvitationTemplateWhereUniqueInput
    update?: XOR<XOR<InvitationTemplateUpdateToOneWithWhereWithoutOrderDetailsInput, InvitationTemplateUpdateWithoutOrderDetailsInput>, InvitationTemplateUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type UserCreateNestedOneWithoutPaymentDetailsInput = {
    create?: XOR<UserCreateWithoutPaymentDetailsInput, UserUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationTemplateCreateNestedOneWithoutPaymentDetailsInput = {
    create?: XOR<InvitationTemplateCreateWithoutPaymentDetailsInput, InvitationTemplateUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutPaymentDetailsInput
    connect?: InvitationTemplateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentDetailsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentDetailsInput, UserUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentDetailsInput
    upsert?: UserUpsertWithoutPaymentDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentDetailsInput, UserUpdateWithoutPaymentDetailsInput>, UserUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type InvitationTemplateUpdateOneWithoutPaymentDetailsNestedInput = {
    create?: XOR<InvitationTemplateCreateWithoutPaymentDetailsInput, InvitationTemplateUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutPaymentDetailsInput
    upsert?: InvitationTemplateUpsertWithoutPaymentDetailsInput
    disconnect?: InvitationTemplateWhereInput | boolean
    delete?: InvitationTemplateWhereInput | boolean
    connect?: InvitationTemplateWhereUniqueInput
    update?: XOR<XOR<InvitationTemplateUpdateToOneWithWhereWithoutPaymentDetailsInput, InvitationTemplateUpdateWithoutPaymentDetailsInput>, InvitationTemplateUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutGuestsInput = {
    create?: XOR<UserCreateWithoutGuestsInput, UserUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGuestStatusFieldUpdateOperationsInput = {
    set?: $Enums.GuestStatus
  }

  export type UserUpdateOneRequiredWithoutGuestsNestedInput = {
    create?: XOR<UserCreateWithoutGuestsInput, UserUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestsInput
    upsert?: UserUpsertWithoutGuestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGuestsInput, UserUpdateWithoutGuestsInput>, UserUncheckedUpdateWithoutGuestsInput>
  }

  export type PaymentDetailsCreateNestedManyWithoutInvitationTemplateInput = {
    create?: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput> | PaymentDetailsCreateWithoutInvitationTemplateInput[] | PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput | PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    createMany?: PaymentDetailsCreateManyInvitationTemplateInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type OrderDetailsCreateNestedManyWithoutInvitationTemplateInput = {
    create?: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput> | OrderDetailsCreateWithoutInvitationTemplateInput[] | OrderDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutInvitationTemplateInput | OrderDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    createMany?: OrderDetailsCreateManyInvitationTemplateInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type PaymentDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput = {
    create?: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput> | PaymentDetailsCreateWithoutInvitationTemplateInput[] | PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput | PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    createMany?: PaymentDetailsCreateManyInvitationTemplateInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type OrderDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput = {
    create?: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput> | OrderDetailsCreateWithoutInvitationTemplateInput[] | OrderDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutInvitationTemplateInput | OrderDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    createMany?: OrderDetailsCreateManyInvitationTemplateInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type Enumtemplate_categoryFieldUpdateOperationsInput = {
    set?: $Enums.template_category
  }

  export type PaymentDetailsUpdateManyWithoutInvitationTemplateNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput> | PaymentDetailsCreateWithoutInvitationTemplateInput[] | PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput | PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput | PaymentDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput[]
    createMany?: PaymentDetailsCreateManyInvitationTemplateInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput | PaymentDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutInvitationTemplateInput | PaymentDetailsUpdateManyWithWhereWithoutInvitationTemplateInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type OrderDetailsUpdateManyWithoutInvitationTemplateNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput> | OrderDetailsCreateWithoutInvitationTemplateInput[] | OrderDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutInvitationTemplateInput | OrderDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput | OrderDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput[]
    createMany?: OrderDetailsCreateManyInvitationTemplateInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput | OrderDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutInvitationTemplateInput | OrderDetailsUpdateManyWithWhereWithoutInvitationTemplateInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput> | PaymentDetailsCreateWithoutInvitationTemplateInput[] | PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput | PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput | PaymentDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput[]
    createMany?: PaymentDetailsCreateManyInvitationTemplateInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput | PaymentDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutInvitationTemplateInput | PaymentDetailsUpdateManyWithWhereWithoutInvitationTemplateInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type OrderDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput> | OrderDetailsCreateWithoutInvitationTemplateInput[] | OrderDetailsUncheckedCreateWithoutInvitationTemplateInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutInvitationTemplateInput | OrderDetailsCreateOrConnectWithoutInvitationTemplateInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput | OrderDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput[]
    createMany?: OrderDetailsCreateManyInvitationTemplateInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput | OrderDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutInvitationTemplateInput | OrderDetailsUpdateManyWithWhereWithoutInvitationTemplateInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserDataTemplateInput = {
    create?: XOR<UserCreateWithoutUserDataTemplateInput, UserUncheckedCreateWithoutUserDataTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDataTemplateInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserDataTemplateNestedInput = {
    create?: XOR<UserCreateWithoutUserDataTemplateInput, UserUncheckedCreateWithoutUserDataTemplateInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDataTemplateInput
    upsert?: UserUpsertWithoutUserDataTemplateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserDataTemplateInput, UserUpdateWithoutUserDataTemplateInput>, UserUncheckedUpdateWithoutUserDataTemplateInput>
  }

  export type BlogCreatetagsInput = {
    set: string[]
  }

  export type CommentCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikedBlogCreateNestedManyWithoutBlogInput = {
    create?: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput> | LikedBlogCreateWithoutBlogInput[] | LikedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutBlogInput | LikedBlogCreateOrConnectWithoutBlogInput[]
    createMany?: LikedBlogCreateManyBlogInputEnvelope
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikedBlogUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput> | LikedBlogCreateWithoutBlogInput[] | LikedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutBlogInput | LikedBlogCreateOrConnectWithoutBlogInput[]
    createMany?: LikedBlogCreateManyBlogInputEnvelope
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
  }

  export type BlogUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikedBlogUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput> | LikedBlogCreateWithoutBlogInput[] | LikedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutBlogInput | LikedBlogCreateOrConnectWithoutBlogInput[]
    upsert?: LikedBlogUpsertWithWhereUniqueWithoutBlogInput | LikedBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LikedBlogCreateManyBlogInputEnvelope
    set?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    disconnect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    delete?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    update?: LikedBlogUpdateWithWhereUniqueWithoutBlogInput | LikedBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LikedBlogUpdateManyWithWhereWithoutBlogInput | LikedBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikedBlogUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput> | LikedBlogCreateWithoutBlogInput[] | LikedBlogUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LikedBlogCreateOrConnectWithoutBlogInput | LikedBlogCreateOrConnectWithoutBlogInput[]
    upsert?: LikedBlogUpsertWithWhereUniqueWithoutBlogInput | LikedBlogUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LikedBlogCreateManyBlogInputEnvelope
    set?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    disconnect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    delete?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    connect?: LikedBlogWhereUniqueInput | LikedBlogWhereUniqueInput[]
    update?: LikedBlogUpdateWithWhereUniqueWithoutBlogInput | LikedBlogUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LikedBlogUpdateManyWithWhereWithoutBlogInput | LikedBlogUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
  }

  export type BlogCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentsInput
    connect?: BlogWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentsInput
    upsert?: BlogUpsertWithoutCommentsInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutCommentsInput, BlogUpdateWithoutCommentsInput>, BlogUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutLikedBlogsInput = {
    create?: XOR<UserCreateWithoutLikedBlogsInput, UserUncheckedCreateWithoutLikedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCreateNestedOneWithoutLikedByInput = {
    create?: XOR<BlogCreateWithoutLikedByInput, BlogUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLikedByInput
    connect?: BlogWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedBlogsNestedInput = {
    create?: XOR<UserCreateWithoutLikedBlogsInput, UserUncheckedCreateWithoutLikedBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedBlogsInput
    upsert?: UserUpsertWithoutLikedBlogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedBlogsInput, UserUpdateWithoutLikedBlogsInput>, UserUncheckedUpdateWithoutLikedBlogsInput>
  }

  export type BlogUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<BlogCreateWithoutLikedByInput, BlogUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLikedByInput
    upsert?: BlogUpsertWithoutLikedByInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutLikedByInput, BlogUpdateWithoutLikedByInput>, BlogUncheckedUpdateWithoutLikedByInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumGuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GuestStatus | EnumGuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuestStatusFilter<$PrismaModel> | $Enums.GuestStatus
  }

  export type NestedEnumGuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuestStatus | EnumGuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuestStatus[] | ListEnumGuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.GuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuestStatusFilter<$PrismaModel>
    _max?: NestedEnumGuestStatusFilter<$PrismaModel>
  }

  export type NestedEnumtemplate_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.template_category | Enumtemplate_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    not?: NestedEnumtemplate_categoryFilter<$PrismaModel> | $Enums.template_category
  }

  export type NestedEnumtemplate_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.template_category | Enumtemplate_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.template_category[] | ListEnumtemplate_categoryFieldRefInput<$PrismaModel>
    not?: NestedEnumtemplate_categoryWithAggregatesFilter<$PrismaModel> | $Enums.template_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtemplate_categoryFilter<$PrismaModel>
    _max?: NestedEnumtemplate_categoryFilter<$PrismaModel>
  }

  export type BookingCreateWithoutUserIdInput = {
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUncheckedCreateWithoutUserIdInput = {
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutUserIdInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput>
  }

  export type BookingCreateManyUserIdInputEnvelope = {
    data: BookingCreateManyUserIdInput | BookingCreateManyUserIdInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    review_id?: string
    vendor_id: string
    rating: number
    review_text: string
    created_at?: Date | string
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    review_id?: string
    vendor_id: string
    rating: number
    review_text: string
    created_at?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChecklistCreateWithoutUserInput = {
    id?: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistUncheckedCreateWithoutUserInput = {
    id?: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistCreateOrConnectWithoutUserInput = {
    where: ChecklistWhereUniqueInput
    create: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput>
  }

  export type ChecklistCreateManyUserInputEnvelope = {
    data: ChecklistCreateManyUserInput | ChecklistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GuestCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestCreateOrConnectWithoutUserInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput>
  }

  export type GuestCreateManyUserInputEnvelope = {
    data: GuestCreateManyUserInput | GuestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentDetailsCreateWithoutUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    InvitationTemplate?: InvitationTemplateCreateNestedOneWithoutPaymentDetailsInput
  }

  export type PaymentDetailsUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    templateId?: string | null
  }

  export type PaymentDetailsCreateOrConnectWithoutUserInput = {
    where: PaymentDetailsWhereUniqueInput
    create: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput>
  }

  export type PaymentDetailsCreateManyUserInputEnvelope = {
    data: PaymentDetailsCreateManyUserInput | PaymentDetailsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderDetailsCreateWithoutUserInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    InvitationTemplate?: InvitationTemplateCreateNestedOneWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    templateId?: string | null
  }

  export type OrderDetailsCreateOrConnectWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput>
  }

  export type OrderDetailsCreateManyUserInputEnvelope = {
    data: OrderDetailsCreateManyUserInput | OrderDetailsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDataTemplateCreateWithoutUserInput = {
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDataTemplateUncheckedCreateWithoutUserInput = {
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDataTemplateCreateOrConnectWithoutUserInput = {
    where: UserDataTemplateWhereUniqueInput
    create: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput>
  }

  export type UserDataTemplateCreateManyUserInputEnvelope = {
    data: UserDataTemplateCreateManyUserInput | UserDataTemplateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutUserInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventTask?: EventTaskCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsCreateNestedManyWithoutEventInput
    subEvent?: SubEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventTask?: EventTaskUncheckedCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsUncheckedCreateNestedManyWithoutEventInput
    subEvent?: SubEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikedBlogCreateWithoutUserInput = {
    id?: string
    blog: BlogCreateNestedOneWithoutLikedByInput
  }

  export type LikedBlogUncheckedCreateWithoutUserInput = {
    id?: string
    blogId: string
  }

  export type LikedBlogCreateOrConnectWithoutUserInput = {
    where: LikedBlogWhereUniqueInput
    create: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput>
  }

  export type LikedBlogCreateManyUserInputEnvelope = {
    data: LikedBlogCreateManyUserInput | LikedBlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutUserIdInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserIdInput, BookingUncheckedUpdateWithoutUserIdInput>
    create: XOR<BookingCreateWithoutUserIdInput, BookingUncheckedCreateWithoutUserIdInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserIdInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserIdInput, BookingUncheckedUpdateWithoutUserIdInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserIdInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserIdInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    booking_id?: StringFilter<"Booking"> | string
    service_id?: StringFilter<"Booking"> | string
    vendor_id?: StringFilter<"Booking"> | string
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    status?: StringFilter<"Booking"> | string
    negotiated_price?: FloatNullableFilter<"Booking"> | number | null
    is_negotiable?: BoolFilter<"Booking"> | boolean
    totalAmount?: FloatFilter<"Booking"> | number
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    review_id?: StringFilter<"Review"> | string
    vendor_id?: StringFilter<"Review"> | string
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    review_text?: StringFilter<"Review"> | string
    created_at?: DateTimeFilter<"Review"> | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    serviceId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type ChecklistUpsertWithWhereUniqueWithoutUserInput = {
    where: ChecklistWhereUniqueInput
    update: XOR<ChecklistUpdateWithoutUserInput, ChecklistUncheckedUpdateWithoutUserInput>
    create: XOR<ChecklistCreateWithoutUserInput, ChecklistUncheckedCreateWithoutUserInput>
  }

  export type ChecklistUpdateWithWhereUniqueWithoutUserInput = {
    where: ChecklistWhereUniqueInput
    data: XOR<ChecklistUpdateWithoutUserInput, ChecklistUncheckedUpdateWithoutUserInput>
  }

  export type ChecklistUpdateManyWithWhereWithoutUserInput = {
    where: ChecklistScalarWhereInput
    data: XOR<ChecklistUpdateManyMutationInput, ChecklistUncheckedUpdateManyWithoutUserInput>
  }

  export type ChecklistScalarWhereInput = {
    AND?: ChecklistScalarWhereInput | ChecklistScalarWhereInput[]
    OR?: ChecklistScalarWhereInput[]
    NOT?: ChecklistScalarWhereInput | ChecklistScalarWhereInput[]
    id?: StringFilter<"Checklist"> | string
    userId?: StringFilter<"Checklist"> | string
    items?: JsonFilter<"Checklist">
    createdAt?: DateTimeFilter<"Checklist"> | Date | string
    updatedAt?: DateTimeFilter<"Checklist"> | Date | string
  }

  export type GuestUpsertWithWhereUniqueWithoutUserInput = {
    where: GuestWhereUniqueInput
    update: XOR<GuestUpdateWithoutUserInput, GuestUncheckedUpdateWithoutUserInput>
    create: XOR<GuestCreateWithoutUserInput, GuestUncheckedCreateWithoutUserInput>
  }

  export type GuestUpdateWithWhereUniqueWithoutUserInput = {
    where: GuestWhereUniqueInput
    data: XOR<GuestUpdateWithoutUserInput, GuestUncheckedUpdateWithoutUserInput>
  }

  export type GuestUpdateManyWithWhereWithoutUserInput = {
    where: GuestScalarWhereInput
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyWithoutUserInput>
  }

  export type GuestScalarWhereInput = {
    AND?: GuestScalarWhereInput | GuestScalarWhereInput[]
    OR?: GuestScalarWhereInput[]
    NOT?: GuestScalarWhereInput | GuestScalarWhereInput[]
    id?: StringFilter<"Guest"> | string
    name?: StringFilter<"Guest"> | string
    phone?: StringFilter<"Guest"> | string
    status?: EnumGuestStatusFilter<"Guest"> | $Enums.GuestStatus
    userId?: StringFilter<"Guest"> | string
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
  }

  export type PaymentDetailsUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentDetailsWhereUniqueInput
    update: XOR<PaymentDetailsUpdateWithoutUserInput, PaymentDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentDetailsCreateWithoutUserInput, PaymentDetailsUncheckedCreateWithoutUserInput>
  }

  export type PaymentDetailsUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentDetailsWhereUniqueInput
    data: XOR<PaymentDetailsUpdateWithoutUserInput, PaymentDetailsUncheckedUpdateWithoutUserInput>
  }

  export type PaymentDetailsUpdateManyWithWhereWithoutUserInput = {
    where: PaymentDetailsScalarWhereInput
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentDetailsScalarWhereInput = {
    AND?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
    OR?: PaymentDetailsScalarWhereInput[]
    NOT?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
    id?: StringFilter<"PaymentDetails"> | string
    orderId?: StringFilter<"PaymentDetails"> | string
    paymentId?: StringNullableFilter<"PaymentDetails"> | string | null
    razorpayResponse?: JsonFilter<"PaymentDetails">
    status?: StringFilter<"PaymentDetails"> | string
    purchasedAt?: DateTimeNullableFilter<"PaymentDetails"> | Date | string | null
    userId?: StringFilter<"PaymentDetails"> | string
    templateId?: StringNullableFilter<"PaymentDetails"> | string | null
  }

  export type OrderDetailsUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    update: XOR<OrderDetailsUpdateWithoutUserInput, OrderDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput>
  }

  export type OrderDetailsUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    data: XOR<OrderDetailsUpdateWithoutUserInput, OrderDetailsUncheckedUpdateWithoutUserInput>
  }

  export type OrderDetailsUpdateManyWithWhereWithoutUserInput = {
    where: OrderDetailsScalarWhereInput
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderDetailsScalarWhereInput = {
    AND?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
    OR?: OrderDetailsScalarWhereInput[]
    NOT?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
    id?: StringFilter<"OrderDetails"> | string
    orderId?: StringFilter<"OrderDetails"> | string
    amount?: FloatFilter<"OrderDetails"> | number
    currency?: StringFilter<"OrderDetails"> | string
    status?: StringFilter<"OrderDetails"> | string
    razorpayResponse?: JsonFilter<"OrderDetails">
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    userId?: StringFilter<"OrderDetails"> | string
    templateId?: StringNullableFilter<"OrderDetails"> | string | null
  }

  export type UserDataTemplateUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDataTemplateWhereUniqueInput
    update: XOR<UserDataTemplateUpdateWithoutUserInput, UserDataTemplateUncheckedUpdateWithoutUserInput>
    create: XOR<UserDataTemplateCreateWithoutUserInput, UserDataTemplateUncheckedCreateWithoutUserInput>
  }

  export type UserDataTemplateUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDataTemplateWhereUniqueInput
    data: XOR<UserDataTemplateUpdateWithoutUserInput, UserDataTemplateUncheckedUpdateWithoutUserInput>
  }

  export type UserDataTemplateUpdateManyWithWhereWithoutUserInput = {
    where: UserDataTemplateScalarWhereInput
    data: XOR<UserDataTemplateUpdateManyMutationInput, UserDataTemplateUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDataTemplateScalarWhereInput = {
    AND?: UserDataTemplateScalarWhereInput | UserDataTemplateScalarWhereInput[]
    OR?: UserDataTemplateScalarWhereInput[]
    NOT?: UserDataTemplateScalarWhereInput | UserDataTemplateScalarWhereInput[]
    userId?: StringFilter<"UserDataTemplate"> | string
    template_id?: StringFilter<"UserDataTemplate"> | string
    eventHeading?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventSubheading?: StringNullableFilter<"UserDataTemplate"> | string | null
    brideName?: StringNullableFilter<"UserDataTemplate"> | string | null
    groomName?: StringNullableFilter<"UserDataTemplate"> | string | null
    eventDate?: DateTimeFilter<"UserDataTemplate"> | Date | string
    weddingTime?: StringNullableFilter<"UserDataTemplate"> | string | null
    weddingLocation?: StringNullableFilter<"UserDataTemplate"> | string | null
    description?: StringNullableFilter<"UserDataTemplate"> | string | null
    createdAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"UserDataTemplate"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    eventName?: StringFilter<"Event"> | string
    eventDescription?: StringNullableFilter<"Event"> | string | null
    eventDate?: DateTimeFilter<"Event"> | Date | string
    eventStartTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventEndTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    eventBudget?: DecimalFilter<"Event"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type LikedBlogUpsertWithWhereUniqueWithoutUserInput = {
    where: LikedBlogWhereUniqueInput
    update: XOR<LikedBlogUpdateWithoutUserInput, LikedBlogUncheckedUpdateWithoutUserInput>
    create: XOR<LikedBlogCreateWithoutUserInput, LikedBlogUncheckedCreateWithoutUserInput>
  }

  export type LikedBlogUpdateWithWhereUniqueWithoutUserInput = {
    where: LikedBlogWhereUniqueInput
    data: XOR<LikedBlogUpdateWithoutUserInput, LikedBlogUncheckedUpdateWithoutUserInput>
  }

  export type LikedBlogUpdateManyWithWhereWithoutUserInput = {
    where: LikedBlogScalarWhereInput
    data: XOR<LikedBlogUpdateManyMutationInput, LikedBlogUncheckedUpdateManyWithoutUserInput>
  }

  export type LikedBlogScalarWhereInput = {
    AND?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
    OR?: LikedBlogScalarWhereInput[]
    NOT?: LikedBlogScalarWhereInput | LikedBlogScalarWhereInput[]
    id?: StringFilter<"LikedBlog"> | string
    userId?: StringFilter<"LikedBlog"> | string
    blogId?: StringFilter<"LikedBlog"> | string
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCartInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
  }

  export type UserUpsertWithoutCartInput = {
    update: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChecklistsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChecklistsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChecklistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChecklistsInput, UserUncheckedCreateWithoutChecklistsInput>
  }

  export type UserUpsertWithoutChecklistsInput = {
    update: XOR<UserUpdateWithoutChecklistsInput, UserUncheckedUpdateWithoutChecklistsInput>
    create: XOR<UserCreateWithoutChecklistsInput, UserUncheckedCreateWithoutChecklistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChecklistsInput, UserUncheckedUpdateWithoutChecklistsInput>
  }

  export type UserUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEventInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
  }

  export type EventTaskCreateWithoutEventInput = {
    id?: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTaskUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTaskCreateOrConnectWithoutEventInput = {
    where: EventTaskWhereUniqueInput
    create: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput>
  }

  export type EventTaskCreateManyEventInputEnvelope = {
    data: EventTaskCreateManyEventInput | EventTaskCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventVendorsCreateWithoutEventInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type EventVendorsUncheckedCreateWithoutEventInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type EventVendorsCreateOrConnectWithoutEventInput = {
    where: EventVendorsWhereUniqueInput
    create: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput>
  }

  export type EventVendorsCreateManyEventInputEnvelope = {
    data: EventVendorsCreateManyEventInput | EventVendorsCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type SubEventCreateWithoutEventInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subEventTask?: SubEventTaskCreateNestedManyWithoutSubEventInput
    subEventVendors?: SubEventVendorsCreateNestedManyWithoutSubEventInput
  }

  export type SubEventUncheckedCreateWithoutEventInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subEventTask?: SubEventTaskUncheckedCreateNestedManyWithoutSubEventInput
    subEventVendors?: SubEventVendorsUncheckedCreateNestedManyWithoutSubEventInput
  }

  export type SubEventCreateOrConnectWithoutEventInput = {
    where: SubEventWhereUniqueInput
    create: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput>
  }

  export type SubEventCreateManyEventInputEnvelope = {
    data: SubEventCreateManyEventInput | SubEventCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEventInput = {
    update: XOR<UserUpdateWithoutEventInput, UserUncheckedUpdateWithoutEventInput>
    create: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventInput, UserUncheckedUpdateWithoutEventInput>
  }

  export type UserUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventTaskUpsertWithWhereUniqueWithoutEventInput = {
    where: EventTaskWhereUniqueInput
    update: XOR<EventTaskUpdateWithoutEventInput, EventTaskUncheckedUpdateWithoutEventInput>
    create: XOR<EventTaskCreateWithoutEventInput, EventTaskUncheckedCreateWithoutEventInput>
  }

  export type EventTaskUpdateWithWhereUniqueWithoutEventInput = {
    where: EventTaskWhereUniqueInput
    data: XOR<EventTaskUpdateWithoutEventInput, EventTaskUncheckedUpdateWithoutEventInput>
  }

  export type EventTaskUpdateManyWithWhereWithoutEventInput = {
    where: EventTaskScalarWhereInput
    data: XOR<EventTaskUpdateManyMutationInput, EventTaskUncheckedUpdateManyWithoutEventInput>
  }

  export type EventTaskScalarWhereInput = {
    AND?: EventTaskScalarWhereInput | EventTaskScalarWhereInput[]
    OR?: EventTaskScalarWhereInput[]
    NOT?: EventTaskScalarWhereInput | EventTaskScalarWhereInput[]
    id?: StringFilter<"EventTask"> | string
    eventId?: StringFilter<"EventTask"> | string
    name?: StringFilter<"EventTask"> | string
    priority?: StringFilter<"EventTask"> | string
    done?: BoolFilter<"EventTask"> | boolean
    scheduleDate?: DateTimeNullableFilter<"EventTask"> | Date | string | null
    createdAt?: DateTimeFilter<"EventTask"> | Date | string
    updatedAt?: DateTimeFilter<"EventTask"> | Date | string
  }

  export type EventVendorsUpsertWithWhereUniqueWithoutEventInput = {
    where: EventVendorsWhereUniqueInput
    update: XOR<EventVendorsUpdateWithoutEventInput, EventVendorsUncheckedUpdateWithoutEventInput>
    create: XOR<EventVendorsCreateWithoutEventInput, EventVendorsUncheckedCreateWithoutEventInput>
  }

  export type EventVendorsUpdateWithWhereUniqueWithoutEventInput = {
    where: EventVendorsWhereUniqueInput
    data: XOR<EventVendorsUpdateWithoutEventInput, EventVendorsUncheckedUpdateWithoutEventInput>
  }

  export type EventVendorsUpdateManyWithWhereWithoutEventInput = {
    where: EventVendorsScalarWhereInput
    data: XOR<EventVendorsUpdateManyMutationInput, EventVendorsUncheckedUpdateManyWithoutEventInput>
  }

  export type EventVendorsScalarWhereInput = {
    AND?: EventVendorsScalarWhereInput | EventVendorsScalarWhereInput[]
    OR?: EventVendorsScalarWhereInput[]
    NOT?: EventVendorsScalarWhereInput | EventVendorsScalarWhereInput[]
    id?: StringFilter<"EventVendors"> | string
    eventId?: StringFilter<"EventVendors"> | string
    serviceId?: StringFilter<"EventVendors"> | string
    createdAt?: DateTimeFilter<"EventVendors"> | Date | string
  }

  export type SubEventUpsertWithWhereUniqueWithoutEventInput = {
    where: SubEventWhereUniqueInput
    update: XOR<SubEventUpdateWithoutEventInput, SubEventUncheckedUpdateWithoutEventInput>
    create: XOR<SubEventCreateWithoutEventInput, SubEventUncheckedCreateWithoutEventInput>
  }

  export type SubEventUpdateWithWhereUniqueWithoutEventInput = {
    where: SubEventWhereUniqueInput
    data: XOR<SubEventUpdateWithoutEventInput, SubEventUncheckedUpdateWithoutEventInput>
  }

  export type SubEventUpdateManyWithWhereWithoutEventInput = {
    where: SubEventScalarWhereInput
    data: XOR<SubEventUpdateManyMutationInput, SubEventUncheckedUpdateManyWithoutEventInput>
  }

  export type SubEventScalarWhereInput = {
    AND?: SubEventScalarWhereInput | SubEventScalarWhereInput[]
    OR?: SubEventScalarWhereInput[]
    NOT?: SubEventScalarWhereInput | SubEventScalarWhereInput[]
    id?: StringFilter<"SubEvent"> | string
    eventId?: StringFilter<"SubEvent"> | string
    subEventName?: StringFilter<"SubEvent"> | string
    subEventDescription?: StringFilter<"SubEvent"> | string
    subEventBudget?: DecimalFilter<"SubEvent"> | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFilter<"SubEvent"> | Date | string
    subEventStartTime?: DateTimeFilter<"SubEvent"> | Date | string
    subEventEndTime?: DateTimeFilter<"SubEvent"> | Date | string
    createdAt?: DateTimeFilter<"SubEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubEvent"> | Date | string
  }

  export type EventCreateWithoutEventVendorsInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventInput
    eventTask?: EventTaskCreateNestedManyWithoutEventInput
    subEvent?: SubEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventVendorsInput = {
    id?: string
    userId: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventTask?: EventTaskUncheckedCreateNestedManyWithoutEventInput
    subEvent?: SubEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventVendorsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventVendorsInput, EventUncheckedCreateWithoutEventVendorsInput>
  }

  export type EventUpsertWithoutEventVendorsInput = {
    update: XOR<EventUpdateWithoutEventVendorsInput, EventUncheckedUpdateWithoutEventVendorsInput>
    create: XOR<EventCreateWithoutEventVendorsInput, EventUncheckedCreateWithoutEventVendorsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventVendorsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventVendorsInput, EventUncheckedUpdateWithoutEventVendorsInput>
  }

  export type EventUpdateWithoutEventVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventNestedInput
    eventTask?: EventTaskUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTask?: EventTaskUncheckedUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutEventTaskInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventInput
    eventVendors?: EventVendorsCreateNestedManyWithoutEventInput
    subEvent?: SubEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventTaskInput = {
    id?: string
    userId: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventVendors?: EventVendorsUncheckedCreateNestedManyWithoutEventInput
    subEvent?: SubEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventTaskInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventTaskInput, EventUncheckedCreateWithoutEventTaskInput>
  }

  export type EventUpsertWithoutEventTaskInput = {
    update: XOR<EventUpdateWithoutEventTaskInput, EventUncheckedUpdateWithoutEventTaskInput>
    create: XOR<EventCreateWithoutEventTaskInput, EventUncheckedCreateWithoutEventTaskInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventTaskInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventTaskInput, EventUncheckedUpdateWithoutEventTaskInput>
  }

  export type EventUpdateWithoutEventTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventNestedInput
    eventVendors?: EventVendorsUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventVendors?: EventVendorsUncheckedUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutSubEventInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventInput
    eventTask?: EventTaskCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSubEventInput = {
    id?: string
    userId: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventTask?: EventTaskUncheckedCreateNestedManyWithoutEventInput
    eventVendors?: EventVendorsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSubEventInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSubEventInput, EventUncheckedCreateWithoutSubEventInput>
  }

  export type SubEventTaskCreateWithoutSubEventInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventTaskUncheckedCreateWithoutSubEventInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventTaskCreateOrConnectWithoutSubEventInput = {
    where: SubEventTaskWhereUniqueInput
    create: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput>
  }

  export type SubEventTaskCreateManySubEventInputEnvelope = {
    data: SubEventTaskCreateManySubEventInput | SubEventTaskCreateManySubEventInput[]
    skipDuplicates?: boolean
  }

  export type SubEventVendorsCreateWithoutSubEventInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventVendorsUncheckedCreateWithoutSubEventInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventVendorsCreateOrConnectWithoutSubEventInput = {
    where: SubEventVendorsWhereUniqueInput
    create: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput>
  }

  export type SubEventVendorsCreateManySubEventInputEnvelope = {
    data: SubEventVendorsCreateManySubEventInput | SubEventVendorsCreateManySubEventInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutSubEventInput = {
    update: XOR<EventUpdateWithoutSubEventInput, EventUncheckedUpdateWithoutSubEventInput>
    create: XOR<EventCreateWithoutSubEventInput, EventUncheckedCreateWithoutSubEventInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutSubEventInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutSubEventInput, EventUncheckedUpdateWithoutSubEventInput>
  }

  export type EventUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventNestedInput
    eventTask?: EventTaskUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTask?: EventTaskUncheckedUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUncheckedUpdateManyWithoutEventNestedInput
  }

  export type SubEventTaskUpsertWithWhereUniqueWithoutSubEventInput = {
    where: SubEventTaskWhereUniqueInput
    update: XOR<SubEventTaskUpdateWithoutSubEventInput, SubEventTaskUncheckedUpdateWithoutSubEventInput>
    create: XOR<SubEventTaskCreateWithoutSubEventInput, SubEventTaskUncheckedCreateWithoutSubEventInput>
  }

  export type SubEventTaskUpdateWithWhereUniqueWithoutSubEventInput = {
    where: SubEventTaskWhereUniqueInput
    data: XOR<SubEventTaskUpdateWithoutSubEventInput, SubEventTaskUncheckedUpdateWithoutSubEventInput>
  }

  export type SubEventTaskUpdateManyWithWhereWithoutSubEventInput = {
    where: SubEventTaskScalarWhereInput
    data: XOR<SubEventTaskUpdateManyMutationInput, SubEventTaskUncheckedUpdateManyWithoutSubEventInput>
  }

  export type SubEventTaskScalarWhereInput = {
    AND?: SubEventTaskScalarWhereInput | SubEventTaskScalarWhereInput[]
    OR?: SubEventTaskScalarWhereInput[]
    NOT?: SubEventTaskScalarWhereInput | SubEventTaskScalarWhereInput[]
    id?: StringFilter<"SubEventTask"> | string
    userId?: StringFilter<"SubEventTask"> | string
    subEventId?: StringFilter<"SubEventTask"> | string
    items?: JsonFilter<"SubEventTask">
    createdAt?: DateTimeFilter<"SubEventTask"> | Date | string
    updatedAt?: DateTimeFilter<"SubEventTask"> | Date | string
  }

  export type SubEventVendorsUpsertWithWhereUniqueWithoutSubEventInput = {
    where: SubEventVendorsWhereUniqueInput
    update: XOR<SubEventVendorsUpdateWithoutSubEventInput, SubEventVendorsUncheckedUpdateWithoutSubEventInput>
    create: XOR<SubEventVendorsCreateWithoutSubEventInput, SubEventVendorsUncheckedCreateWithoutSubEventInput>
  }

  export type SubEventVendorsUpdateWithWhereUniqueWithoutSubEventInput = {
    where: SubEventVendorsWhereUniqueInput
    data: XOR<SubEventVendorsUpdateWithoutSubEventInput, SubEventVendorsUncheckedUpdateWithoutSubEventInput>
  }

  export type SubEventVendorsUpdateManyWithWhereWithoutSubEventInput = {
    where: SubEventVendorsScalarWhereInput
    data: XOR<SubEventVendorsUpdateManyMutationInput, SubEventVendorsUncheckedUpdateManyWithoutSubEventInput>
  }

  export type SubEventVendorsScalarWhereInput = {
    AND?: SubEventVendorsScalarWhereInput | SubEventVendorsScalarWhereInput[]
    OR?: SubEventVendorsScalarWhereInput[]
    NOT?: SubEventVendorsScalarWhereInput | SubEventVendorsScalarWhereInput[]
    id?: StringFilter<"SubEventVendors"> | string
    subEventId?: StringFilter<"SubEventVendors"> | string
    userId?: StringFilter<"SubEventVendors"> | string
    serviceId?: StringFilter<"SubEventVendors"> | string
    createdAt?: DateTimeFilter<"SubEventVendors"> | Date | string
  }

  export type SubEventCreateWithoutSubEventVendorsInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSubEventInput
    subEventTask?: SubEventTaskCreateNestedManyWithoutSubEventInput
  }

  export type SubEventUncheckedCreateWithoutSubEventVendorsInput = {
    id?: string
    eventId: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subEventTask?: SubEventTaskUncheckedCreateNestedManyWithoutSubEventInput
  }

  export type SubEventCreateOrConnectWithoutSubEventVendorsInput = {
    where: SubEventWhereUniqueInput
    create: XOR<SubEventCreateWithoutSubEventVendorsInput, SubEventUncheckedCreateWithoutSubEventVendorsInput>
  }

  export type SubEventUpsertWithoutSubEventVendorsInput = {
    update: XOR<SubEventUpdateWithoutSubEventVendorsInput, SubEventUncheckedUpdateWithoutSubEventVendorsInput>
    create: XOR<SubEventCreateWithoutSubEventVendorsInput, SubEventUncheckedCreateWithoutSubEventVendorsInput>
    where?: SubEventWhereInput
  }

  export type SubEventUpdateToOneWithWhereWithoutSubEventVendorsInput = {
    where?: SubEventWhereInput
    data: XOR<SubEventUpdateWithoutSubEventVendorsInput, SubEventUncheckedUpdateWithoutSubEventVendorsInput>
  }

  export type SubEventUpdateWithoutSubEventVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSubEventNestedInput
    subEventTask?: SubEventTaskUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventUncheckedUpdateWithoutSubEventVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventTask?: SubEventTaskUncheckedUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventCreateWithoutSubEventTaskInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutSubEventInput
    subEventVendors?: SubEventVendorsCreateNestedManyWithoutSubEventInput
  }

  export type SubEventUncheckedCreateWithoutSubEventTaskInput = {
    id?: string
    eventId: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subEventVendors?: SubEventVendorsUncheckedCreateNestedManyWithoutSubEventInput
  }

  export type SubEventCreateOrConnectWithoutSubEventTaskInput = {
    where: SubEventWhereUniqueInput
    create: XOR<SubEventCreateWithoutSubEventTaskInput, SubEventUncheckedCreateWithoutSubEventTaskInput>
  }

  export type SubEventUpsertWithoutSubEventTaskInput = {
    update: XOR<SubEventUpdateWithoutSubEventTaskInput, SubEventUncheckedUpdateWithoutSubEventTaskInput>
    create: XOR<SubEventCreateWithoutSubEventTaskInput, SubEventUncheckedCreateWithoutSubEventTaskInput>
    where?: SubEventWhereInput
  }

  export type SubEventUpdateToOneWithWhereWithoutSubEventTaskInput = {
    where?: SubEventWhereInput
    data: XOR<SubEventUpdateWithoutSubEventTaskInput, SubEventUncheckedUpdateWithoutSubEventTaskInput>
  }

  export type SubEventUpdateWithoutSubEventTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutSubEventNestedInput
    subEventVendors?: SubEventVendorsUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventUncheckedUpdateWithoutSubEventTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventVendors?: SubEventVendorsUncheckedUpdateManyWithoutSubEventNestedInput
  }

  export type UserCreateWithoutOrderDetailsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderDetailsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
  }

  export type InvitationTemplateCreateWithoutOrderDetailsInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateUncheckedCreateWithoutOrderDetailsInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateCreateOrConnectWithoutOrderDetailsInput = {
    where: InvitationTemplateWhereUniqueInput
    create: XOR<InvitationTemplateCreateWithoutOrderDetailsInput, InvitationTemplateUncheckedCreateWithoutOrderDetailsInput>
  }

  export type UserUpsertWithoutOrderDetailsInput = {
    update: XOR<UserUpdateWithoutOrderDetailsInput, UserUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderDetailsInput, UserUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type UserUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvitationTemplateUpsertWithoutOrderDetailsInput = {
    update: XOR<InvitationTemplateUpdateWithoutOrderDetailsInput, InvitationTemplateUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<InvitationTemplateCreateWithoutOrderDetailsInput, InvitationTemplateUncheckedCreateWithoutOrderDetailsInput>
    where?: InvitationTemplateWhereInput
  }

  export type InvitationTemplateUpdateToOneWithWhereWithoutOrderDetailsInput = {
    where?: InvitationTemplateWhereInput
    data: XOR<InvitationTemplateUpdateWithoutOrderDetailsInput, InvitationTemplateUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type InvitationTemplateUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDetails?: PaymentDetailsUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type InvitationTemplateUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type UserCreateWithoutPaymentDetailsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentDetailsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentDetailsInput, UserUncheckedCreateWithoutPaymentDetailsInput>
  }

  export type InvitationTemplateCreateWithoutPaymentDetailsInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    orderDetails?: OrderDetailsCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateUncheckedCreateWithoutPaymentDetailsInput = {
    id?: string
    name: string
    imageUrl: JsonNullValueInput | InputJsonValue
    price?: number | null
    template_type: $Enums.template_category
    template_category: string
    filter?: string | null
    createdAt?: Date | string
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutInvitationTemplateInput
  }

  export type InvitationTemplateCreateOrConnectWithoutPaymentDetailsInput = {
    where: InvitationTemplateWhereUniqueInput
    create: XOR<InvitationTemplateCreateWithoutPaymentDetailsInput, InvitationTemplateUncheckedCreateWithoutPaymentDetailsInput>
  }

  export type UserUpsertWithoutPaymentDetailsInput = {
    update: XOR<UserUpdateWithoutPaymentDetailsInput, UserUncheckedUpdateWithoutPaymentDetailsInput>
    create: XOR<UserCreateWithoutPaymentDetailsInput, UserUncheckedCreateWithoutPaymentDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentDetailsInput, UserUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type UserUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvitationTemplateUpsertWithoutPaymentDetailsInput = {
    update: XOR<InvitationTemplateUpdateWithoutPaymentDetailsInput, InvitationTemplateUncheckedUpdateWithoutPaymentDetailsInput>
    create: XOR<InvitationTemplateCreateWithoutPaymentDetailsInput, InvitationTemplateUncheckedCreateWithoutPaymentDetailsInput>
    where?: InvitationTemplateWhereInput
  }

  export type InvitationTemplateUpdateToOneWithWhereWithoutPaymentDetailsInput = {
    where?: InvitationTemplateWhereInput
    data: XOR<InvitationTemplateUpdateWithoutPaymentDetailsInput, InvitationTemplateUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type InvitationTemplateUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDetails?: OrderDetailsUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type InvitationTemplateUncheckedUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: JsonNullValueInput | InputJsonValue
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    template_type?: Enumtemplate_categoryFieldUpdateOperationsInput | $Enums.template_category
    template_category?: StringFieldUpdateOperationsInput | string
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutInvitationTemplateNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGuestsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGuestsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuestsInput, UserUncheckedCreateWithoutGuestsInput>
  }

  export type UserUpsertWithoutGuestsInput = {
    update: XOR<UserUpdateWithoutGuestsInput, UserUncheckedUpdateWithoutGuestsInput>
    create: XOR<UserCreateWithoutGuestsInput, UserUncheckedCreateWithoutGuestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGuestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGuestsInput, UserUncheckedUpdateWithoutGuestsInput>
  }

  export type UserUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentDetailsCreateWithoutInvitationTemplateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentDetailsInput
  }

  export type PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    userId: string
  }

  export type PaymentDetailsCreateOrConnectWithoutInvitationTemplateInput = {
    where: PaymentDetailsWhereUniqueInput
    create: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput>
  }

  export type PaymentDetailsCreateManyInvitationTemplateInputEnvelope = {
    data: PaymentDetailsCreateManyInvitationTemplateInput | PaymentDetailsCreateManyInvitationTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrderDetailsCreateWithoutInvitationTemplateInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutInvitationTemplateInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type OrderDetailsCreateOrConnectWithoutInvitationTemplateInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput>
  }

  export type OrderDetailsCreateManyInvitationTemplateInputEnvelope = {
    data: OrderDetailsCreateManyInvitationTemplateInput | OrderDetailsCreateManyInvitationTemplateInput[]
    skipDuplicates?: boolean
  }

  export type PaymentDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput = {
    where: PaymentDetailsWhereUniqueInput
    update: XOR<PaymentDetailsUpdateWithoutInvitationTemplateInput, PaymentDetailsUncheckedUpdateWithoutInvitationTemplateInput>
    create: XOR<PaymentDetailsCreateWithoutInvitationTemplateInput, PaymentDetailsUncheckedCreateWithoutInvitationTemplateInput>
  }

  export type PaymentDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput = {
    where: PaymentDetailsWhereUniqueInput
    data: XOR<PaymentDetailsUpdateWithoutInvitationTemplateInput, PaymentDetailsUncheckedUpdateWithoutInvitationTemplateInput>
  }

  export type PaymentDetailsUpdateManyWithWhereWithoutInvitationTemplateInput = {
    where: PaymentDetailsScalarWhereInput
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyWithoutInvitationTemplateInput>
  }

  export type OrderDetailsUpsertWithWhereUniqueWithoutInvitationTemplateInput = {
    where: OrderDetailsWhereUniqueInput
    update: XOR<OrderDetailsUpdateWithoutInvitationTemplateInput, OrderDetailsUncheckedUpdateWithoutInvitationTemplateInput>
    create: XOR<OrderDetailsCreateWithoutInvitationTemplateInput, OrderDetailsUncheckedCreateWithoutInvitationTemplateInput>
  }

  export type OrderDetailsUpdateWithWhereUniqueWithoutInvitationTemplateInput = {
    where: OrderDetailsWhereUniqueInput
    data: XOR<OrderDetailsUpdateWithoutInvitationTemplateInput, OrderDetailsUncheckedUpdateWithoutInvitationTemplateInput>
  }

  export type OrderDetailsUpdateManyWithWhereWithoutInvitationTemplateInput = {
    where: OrderDetailsScalarWhereInput
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyWithoutInvitationTemplateInput>
  }

  export type UserCreateWithoutUserDataTemplateInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserDataTemplateInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
    likedBlogs?: LikedBlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserDataTemplateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDataTemplateInput, UserUncheckedCreateWithoutUserDataTemplateInput>
  }

  export type UserUpsertWithoutUserDataTemplateInput = {
    update: XOR<UserUpdateWithoutUserDataTemplateInput, UserUncheckedUpdateWithoutUserDataTemplateInput>
    create: XOR<UserCreateWithoutUserDataTemplateInput, UserUncheckedCreateWithoutUserDataTemplateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserDataTemplateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserDataTemplateInput, UserUncheckedUpdateWithoutUserDataTemplateInput>
  }

  export type UserUpdateWithoutUserDataTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDataTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
    likedBlogs?: LikedBlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutBlogInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
  }

  export type CommentUncheckedCreateWithoutBlogInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
  }

  export type CommentCreateOrConnectWithoutBlogInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentCreateManyBlogInputEnvelope = {
    data: CommentCreateManyBlogInput | CommentCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type LikedBlogCreateWithoutBlogInput = {
    id?: string
    user: UserCreateNestedOneWithoutLikedBlogsInput
  }

  export type LikedBlogUncheckedCreateWithoutBlogInput = {
    id?: string
    userId: string
  }

  export type LikedBlogCreateOrConnectWithoutBlogInput = {
    where: LikedBlogWhereUniqueInput
    create: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput>
  }

  export type LikedBlogCreateManyBlogInputEnvelope = {
    data: LikedBlogCreateManyBlogInput | LikedBlogCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
  }

  export type CommentUpdateManyWithWhereWithoutBlogInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutBlogInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    blogId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
  }

  export type LikedBlogUpsertWithWhereUniqueWithoutBlogInput = {
    where: LikedBlogWhereUniqueInput
    update: XOR<LikedBlogUpdateWithoutBlogInput, LikedBlogUncheckedUpdateWithoutBlogInput>
    create: XOR<LikedBlogCreateWithoutBlogInput, LikedBlogUncheckedCreateWithoutBlogInput>
  }

  export type LikedBlogUpdateWithWhereUniqueWithoutBlogInput = {
    where: LikedBlogWhereUniqueInput
    data: XOR<LikedBlogUpdateWithoutBlogInput, LikedBlogUncheckedUpdateWithoutBlogInput>
  }

  export type LikedBlogUpdateManyWithWhereWithoutBlogInput = {
    where: LikedBlogScalarWhereInput
    data: XOR<LikedBlogUpdateManyMutationInput, LikedBlogUncheckedUpdateManyWithoutBlogInput>
  }

  export type BlogCreateWithoutCommentsInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    likedBy?: LikedBlogCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    likedBy?: LikedBlogUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutCommentsInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
  }

  export type BlogUpsertWithoutCommentsInput = {
    update: XOR<BlogUpdateWithoutCommentsInput, BlogUncheckedUpdateWithoutCommentsInput>
    create: XOR<BlogCreateWithoutCommentsInput, BlogUncheckedCreateWithoutCommentsInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutCommentsInput, BlogUncheckedUpdateWithoutCommentsInput>
  }

  export type BlogUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    likedBy?: LikedBlogUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    likedBy?: LikedBlogUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type UserCreateWithoutLikedBlogsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingCreateNestedManyWithoutUserIdInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedManyWithoutUserInput
    checklists?: ChecklistCreateNestedManyWithoutUserInput
    guests?: GuestCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedBlogsInput = {
    id?: string
    email: string
    refresh_Token?: string | null
    password_hash?: string | null
    googleUid?: string | null
    resetPassword_Token?: string | null
    profile_photo?: string | null
    user_name: string
    phone_number?: string | null
    role: $Enums.Role
    wedding_date?: Date | string | null
    wedding_location?: string | null
    created_at?: Date | string
    is_verified?: boolean
    updated_at?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserIdInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedManyWithoutUserInput
    checklists?: ChecklistUncheckedCreateNestedManyWithoutUserInput
    guests?: GuestUncheckedCreateNestedManyWithoutUserInput
    paymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutUserInput
    orderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    userDataTemplate?: UserDataTemplateUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedBlogsInput, UserUncheckedCreateWithoutLikedBlogsInput>
  }

  export type BlogCreateWithoutLikedByInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    comments?: CommentCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    tags?: BlogCreatetagsInput | string[]
    content: string
    viewCount?: number
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    comments?: CommentUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutLikedByInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutLikedByInput, BlogUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedBlogsInput = {
    update: XOR<UserUpdateWithoutLikedBlogsInput, UserUncheckedUpdateWithoutLikedBlogsInput>
    create: XOR<UserCreateWithoutLikedBlogsInput, UserUncheckedCreateWithoutLikedBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedBlogsInput, UserUncheckedUpdateWithoutLikedBlogsInput>
  }

  export type UserUpdateWithoutLikedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cart?: CartUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUpdateManyWithoutUserNestedInput
    guests?: GuestUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    refresh_Token?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    googleUid?: NullableStringFieldUpdateOperationsInput | string | null
    resetPassword_Token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_photo?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    wedding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wedding_location?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserIdNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    checklists?: ChecklistUncheckedUpdateManyWithoutUserNestedInput
    guests?: GuestUncheckedUpdateManyWithoutUserNestedInput
    paymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutUserNestedInput
    orderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    userDataTemplate?: UserDataTemplateUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogUpsertWithoutLikedByInput = {
    update: XOR<BlogUpdateWithoutLikedByInput, BlogUncheckedUpdateWithoutLikedByInput>
    create: XOR<BlogCreateWithoutLikedByInput, BlogUncheckedCreateWithoutLikedByInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutLikedByInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutLikedByInput, BlogUncheckedUpdateWithoutLikedByInput>
  }

  export type BlogUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    content?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BookingCreateManyUserIdInput = {
    booking_id?: string
    service_id: string
    vendor_id: string
    booking_date: Date | string
    status?: string
    negotiated_price?: number | null
    is_negotiable?: boolean
    totalAmount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    review_id?: string
    vendor_id: string
    rating: number
    review_text: string
    created_at?: Date | string
  }

  export type CartCreateManyUserInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type ChecklistCreateManyUserInput = {
    id?: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestCreateManyUserInput = {
    id?: string
    name: string
    phone: string
    status?: $Enums.GuestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentDetailsCreateManyUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    templateId?: string | null
  }

  export type OrderDetailsCreateManyUserInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    templateId?: string | null
  }

  export type UserDataTemplateCreateManyUserInput = {
    template_id?: string
    eventHeading?: string | null
    eventSubheading?: string | null
    brideName?: string | null
    groomName?: string | null
    eventDate: Date | string
    weddingTime?: string | null
    weddingLocation?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyUserInput = {
    id?: string
    eventName: string
    eventDescription?: string | null
    eventDate: Date | string
    eventStartTime?: Date | string | null
    eventEndTime?: Date | string | null
    eventBudget: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedBlogCreateManyUserInput = {
    id?: string
    blogId: string
  }

  export type BookingUpdateWithoutUserIdInput = {
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateWithoutUserIdInput = {
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutUserIdInput = {
    booking_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    negotiated_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_negotiable?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    review_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumGuestStatusFieldUpdateOperationsInput | $Enums.GuestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    InvitationTemplate?: InvitationTemplateUpdateOneWithoutPaymentDetailsNestedInput
  }

  export type PaymentDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InvitationTemplate?: InvitationTemplateUpdateOneWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDataTemplateUpdateWithoutUserInput = {
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDataTemplateUncheckedUpdateWithoutUserInput = {
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDataTemplateUncheckedUpdateManyWithoutUserInput = {
    template_id?: StringFieldUpdateOperationsInput | string
    eventHeading?: NullableStringFieldUpdateOperationsInput | string | null
    eventSubheading?: NullableStringFieldUpdateOperationsInput | string | null
    brideName?: NullableStringFieldUpdateOperationsInput | string | null
    groomName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weddingTime?: NullableStringFieldUpdateOperationsInput | string | null
    weddingLocation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTask?: EventTaskUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTask?: EventTaskUncheckedUpdateManyWithoutEventNestedInput
    eventVendors?: EventVendorsUncheckedUpdateManyWithoutEventNestedInput
    subEvent?: SubEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedBlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blog?: BlogUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedBlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
  }

  export type EventTaskCreateManyEventInput = {
    id?: string
    name: string
    priority?: string
    done?: boolean
    scheduleDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventVendorsCreateManyEventInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventCreateManyEventInput = {
    id?: string
    subEventName: string
    subEventDescription: string
    subEventBudget: Decimal | DecimalJsLike | number | string
    subEventDate: Date | string
    subEventStartTime: Date | string
    subEventEndTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTaskUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTaskUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTaskUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    done?: BoolFieldUpdateOperationsInput | boolean
    scheduleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventVendorsUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventTask?: SubEventTaskUpdateManyWithoutSubEventNestedInput
    subEventVendors?: SubEventVendorsUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventTask?: SubEventTaskUncheckedUpdateManyWithoutSubEventNestedInput
    subEventVendors?: SubEventVendorsUncheckedUpdateManyWithoutSubEventNestedInput
  }

  export type SubEventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subEventName?: StringFieldUpdateOperationsInput | string
    subEventDescription?: StringFieldUpdateOperationsInput | string
    subEventBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subEventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventStartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    subEventEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskCreateManySubEventInput = {
    id?: string
    userId: string
    items: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubEventVendorsCreateManySubEventInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type SubEventTaskUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskUncheckedUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventTaskUncheckedUpdateManyWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsUncheckedUpdateWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubEventVendorsUncheckedUpdateManyWithoutSubEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentDetailsCreateManyInvitationTemplateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    razorpayResponse: JsonNullValueInput | InputJsonValue
    status?: string
    purchasedAt?: Date | string | null
    userId: string
  }

  export type OrderDetailsCreateManyInvitationTemplateInput = {
    id?: string
    orderId: string
    amount: number
    currency?: string
    status?: string
    razorpayResponse: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type PaymentDetailsUpdateWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentDetailsNestedInput
  }

  export type PaymentDetailsUncheckedUpdateWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderDetailsUpdateWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderDetailsUncheckedUpdateManyWithoutInvitationTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    razorpayResponse?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyBlogInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
  }

  export type LikedBlogCreateManyBlogInput = {
    id?: string
    userId: string
  }

  export type CommentUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLikedBlogsNestedInput
  }

  export type LikedBlogUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedBlogUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}